# 单元测试

## 基本概念

- 黑盒测试：不看代码的功能测试
- 白盒测试：根据业务逻辑测试输入输出
- E2E：浏览器客户端等点击是否有预期效果

一般对工具性的组件去做单元测试，不用全部去写。如果是开源程序，覆盖率一定要高
现在的话一般使用 jest



## 准备工作

在使用 `vue create xx`时，需要选择单测环境，我们选用 jest。然后项目根目录下出现`tests`目录和`jest.config.js`配置文件
> 完成测试任务，需要测试框架去跑测试，需要断言库去编写测试用例，以及一些编程框架特有的测试套件。


- mocha + chai ：分别是测试库和断言库
- jest，同时包含两者
- vue 组件测试，还需要 `vue-test-utils` 套件库

之前在初始化 vue 项目时，就应该勾选 单元测试和 E2E测试选项

- cypress, E2E测试库

若在已有项目中去另外集成这些测试库

- vue add @vue/unit-jest
- vue add @vue/e2e-cypress



## 编写单元测试

### 文件命名规范
单元测试目录 `根目录/tests/unit`， 测试文件规范 `*.spec.js`

### 测试代码写法
> 执行测试 `npm run test:unit`
> 安装完插件会自动到 `package.json`中加入执行命令 `test:unit:vue-cli-service tst:unit`


```javascript
// 引入需要测试的东西
function add(num1, num2) {
  return num1+num2
}

// 编写测试套件
describe('xxxxx'. () => {
  // 编写测试用例
  if('测试add函数', () => {
    // 断言 API，看测试库文档
    expect(add(1, 3)).toBe(3)
    expect(add(1, 3)).toBe(4)
    expect(add(-2, 3)).toBe(1)
  })
})
```

### 单测配置
更改 jest.config.js
```javascript
module.exports = {
  // 需要测试的文件类型后缀
  moduleFileExtensions: ['js', 'jsx', 'json', 'vue'],
  // 类似 webpack 中的 loader。前面是正则匹配文件，后面指定用包 
  transform: {
    '^.+\\.vue$': 'vue-jest',
    '.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$':
      'jest-transform-stub',
    '^.+\\.jsx?$': 'babel-jest'
  },
  // 忽略文件
  transformIgnorePaterns:['/node_modules/'],
  // 起别名，下面就是用 @ 取代了后面的路径
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  // 生成快照格式化
  snapshotSerializers: ['jest-serializer-vue'],
  // 1 去掉 **/tests/unit 头路径，现在是所有 spec 结尾文件都需要被测试
  // 指定要走单元测试的路径和文件类型
  // 一般我们测试文件的命名就是 组件名.spec.js
  testMatch: [
    '**/tests/unit/**/*.spec.(js|jsx|ts|tsx)|**/__tests__/*.(js|jsx|ts|tsx)'
  ],
  // 2 开启测试报告,一般是判断环境变量
  collectCoverage:process.env.COVERAGE === 'true', 
  // 3 作为测试报告依据的文件
  // src/utils和src/components 里的 js|vue 文件，忽略 auth 和 request 文件
  collectCoverageFrom: ['src/utils/**/*.{js,vue}', '!src/utils/auth.js', '!src/utils/request.js', 'src/components/**/*.{js,vue}'],

  testURL: 'http://localhost/' // 用于支持 JS DOM
}
```

打开 eslint
```javascript
// .eslintrc.js 打开 Jest 选项
module.exports = {
  env:{
    node:true,
    jest:true
  }
}
```



## 测试 vue 组件

> 专用测试套件， @vue/test-utils

```javascript
// 导入 Vue.js 和组件，进行测试
// import Vue from 'vue'
import xxxComp from '@/components/xxx.vue'

describe('xxxComp', () => {
  // 1 检查原始组件选项
  // 就是看用户有没有设置 created 方法函数
  it('由created生命周期', () => {
    expect(typeof xxxComp.created).toBe('function')
  })

  // 评估原始组件选项中的函数的结果
  it('初始data是vue-text', () => {
    // 检查data函数存在性
    expect(typeof xxxComp.data).toBe('function')
    // 检查data返回的默认值
    const defaultData = xxxComp.data()
    expect(defaultData.message).toBe('hello!')
  })
})
```

当引入测试套件库之后的写法
> 可以看官方文档说明

```javascript
import { shallowMount } from '@vue/test-utils'
import HelloWorld from '@/components/HelloWorld.vue'

describe('HelloWorld.vue', () => {
  it('renders props.msg when passed', () => {
    const msg = 'new message'
    // 模拟挂载
    const wrapper = shallowMount(HelloWorld, {
      propsData: { msg }
    })
    expect(wrapper.text()).toMatch(msg)
  })
})
```


完整测试文件示例
执行`npm run test --watch` 监听代码变化，实时测试
```javascript
// 组件渲染帮助方法，shallowMount 浅层,mount 深层
import { shallowMount,mount } from '@vue/test-utils' 
// 引入要测试的组件， @ 符号在之前的配置文件中已经指定
import SvgIcon from '@/components/SvgIcon/index.vue'
// 安装 npm i -D sinon 来提升测试,简化测试代码
import sinon from 'sinon'

// 这是一个单元测试
describe('SvgIcon.vue', () => {
  // 监听事件,s是否被触发标识
  let isCalled = false
  const input = sinon.spy() // 用 sinon 绑定个监听间谍
  // 渲染组件
  const wrapper = mount(SvgIcon, {
    listeners:{
      change(){ // change 事件触发，改变标识
        isCalled=true
      },
      input
    }
  })

  // 1 断言，相当于是创建组件的渲染环境
  it('iconClass', () => {
    const wrapper = mount(SvgIcon, {
      // 相当于是给组件<SvgIcon/>的 iconClass 属性写了 test 值
      propsData: {
        iconClass: 'test'
      }
    })
    // 期望和实际值的比较
    expect(wrapper.find('use').attributes().href).toBe('#icon-test')
  })

  // 2 生成 HTML 内容快照，如果后面出现变化则会报错
  it('renders html', () => {
    // 目录下出现快照文件
    expect(wrapper.html()).toMatchSnapshot()
  })

  // 3 按钮点击操作，测试 data 值
  it('count++', () => {
    const btn = wrapper.find('button')
    button.trigger('click') // 点击按钮
    expect(wrapper.vm.count).toBe(2)
    expect(idCalled).toBe(true) // 事件被触发
    expect(input.called).toBe(true) // input 事件在 sinon 监听下第一次触发
    button.trigger('click') // 再次点击按钮
    expect(input.callCount).toBe(2) // 触发两次
  })
})
```



## 测试覆盖率

> jest 自带覆盖率。如果用 mocha 就要用 istanbul 来统计覆盖率


- 基于 package.json 配置，开启收集覆盖率的选项

```javascript
"jest":{
  "collectCoverage":true,
  "collectCoverage":["src/**/*.{js,vue}"]
}
```

- 基于 jest.config.js 配置方式

```javascript
module.exports = {
  "collectCoverage":true,
  "collectCoverage":["src/**/*.{js,vue}"]
}
```

执行测试后会出现一张表，列出所有被测试的文件情况

- %stmts 语句覆盖率。是否每个语句都执行了
- %Branch 分支覆盖率，是否执行每个 if 代码块
- %Funcs 函数覆盖率
- %Lines 行覆盖率



## E2E 测试

> 插件装完后，执行 `npm run test:e2e`
> cypress 就是一个跟浏览器打交道的库，模拟虚拟用户操作


```javascript
// tests/e2e/spec/tets.js
describe('My First Test', () => {
  it('Visits the app root url', () => {
    cy.visit('/')
    cy.contains('h1', 'Welcome to Your Vue.js App')
  })
})
```
