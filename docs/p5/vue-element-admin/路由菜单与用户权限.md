# 用户登录和鉴权

技术栈基于 `vue-element-admin`

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200110131130.png)

## 登录流程分析

- 路由权限校验，没有登录的去登录页面
- 用户鉴权（拿客户端传来的账号密码去 `数据库` 验证）
- 用户身份确认后，通过 `JWT` 生成 `token`
- 前端，保存 `token`，并通过 `axios` 拦截请求，把 token 附带到 `http Header` 中
- 后端校验 `token`，获取 `用户名` ，并查询用户信息
- 前端拿到用户信息，重定向（路由权限校验）到首页，并根据用户权限生成菜单



### 登录组件

> src/views/login.vue 登录页面

```vue
<template>
  <div>
    <h2>用户登录</h2>
    <div>
      <input type="text" v-model="username">
      <button @click="login">登录</button>
    </div>
  </div>
</template>
<script>
export default {
  data() {
    return {
      username: "admin"
    };
  },
  methods: {
    login() {
      // 1 派发一个登录 action
      this.$store
        .dispatch("user/login", { username: this.username })
        .then(() => {
          // 2 登录成功重定向页面
          this.$router.push({
            path: this.$route.query.redirect || "/"
          });
        })
        .catch(error => {
            alert(error)
        });
    }
  }
};
</script>
```



#### 细节一：页面启动后自动聚焦

检查用户名密码是否为空，空时自动聚焦

```js
mounted() {
  if (this.loginForm.username === '') {
    this.$refs.username.focus()
  } else if (this.loginForm.password === '') {
    this.$refs.password.focus()
  }
}
```



#### 细节二：显示密码后自动聚焦

切换密码显示状态后，自动聚焦密码输入框

```js
showPwd() {
  if (this.passwordType === 'password') {
    this.passwordType = ''
  } else {
    this.passwordType = 'password'
  }
  
  this.$nextTick(() => {
    this.$refs.password.focus()
  })
}
```



### user 模块（vuex）

 解决问题：用户登录，用户信息，用户登录注销 

```js
import { getToken, setToken, removeToken } from "@/utils/auth";
import {login, getInfo} from '@/api/user'; // 服务端接口

// 1 存储用户令牌和角色信息
const state = {
  token: getToken(),
  roles: []
  // 其他用户信息
};

// 2 两个操作 state 的 mutations
const mutations = {
  SET_TOKEN: (state, token) => {
    state.token = token;
  },
  SET_ROLES: (state, roles) => {
    state.roles = roles;
  }
};

// 3 异步操作方法
const actions = {
  // 3.1 登录接口
  // 用户登录动作 user/login  dispatch('user/login')
  login({ commit }, userInfo) {
    // 3.1.1 调用并处理结果，错误处理已拦截无需处理
    return login(userInfo).then((res) => {
      commit("SET_TOKEN", res.data); // 保存状态信息
      setToken(res.data); // 写入 cookie
    });
    // 模拟的登录请求
    // const { username } = userInfo;
    // return new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     if (username === "admin" || username === "jerry") {
    //         // 保存状态
    //       commit("SET_TOKEN", username);
    //     //   写入cookie
    //       setToken(username);
    //       resolve();
    //     } else {
    //       reject("用户名、密码错误");
    //     }
    //   }, 1000);
    // });
  },

  // 3.2 获取用户信息接口
  // 获取用户角色等信息
  getInfo({ commit, state }) {
    // 3.2.1 根据 token 获取用户的角色范围
    return getInfo(state.token).then(({data: roles}) => {
      commit("SET_ROLES", roles);
      return {roles}
    })
    // return new Promise((resolve) => {
    //   setTimeout(() => {
    //     const roles = state.token === 'admin' ? ['admin'] : ['editor']
    //     commit("SET_ROLES", roles);
    //     resolve({roles});
    //   }, 1000);
    // });
  },

  // 3.3 重置令牌接口（注销）
  // 重置令牌
  resetToken({ commit }) {
    return new Promise(resolve => {
      commit("SET_TOKEN", "");
      commit("SET_ROLES", []);
      removeToken();
      resolve();
    });
  }
};

export default {
  namespaced: true,
  state,
  mutations,
  actions
};
```





## 路由和权限校验

> 路由和权限放在一起做的，也就是处理路由和权限映射

### 路由的基本配置

路由主要分为两种路由

- 通用（静态）路由 `constRoutes` 
- 权限（动态）路由 `asyncRoutes`

后者就是需要经过登录等权限判断操作才能看到的路由。



#### constRoutes 通用（静态）路由配置

表示那些不需要动态判断权限的路由，如登录页、看板和404等通用页面

```js
// src/router/index.js
import Vue from "vue";
import Router from "vue-router";
import Layout from '@/layout'; // 1 布局页

Vue.use(Router);

// 2 通用页面：这里的配置时不需要权限的
// 如下面的：首页， 登录页面
export const constRoutes = [
  {
    path: "/login",
    component: () => import("@/views/Login"),
    hidden: true // 导航菜单忽略该项
  },
  {
    path: "/",
    component: Layout,// 2.1 应用父页面布局
    redirect: "/home", // 2.2 访问首页时，规定访问下面定义的 Home 子页面
    meta: {title: '首页', icon:'qq'},
    children: [
      {
        path: "home",
        component: () =>
          import(/* webpackChunkName: "home" */ "@/views/Home.vue"),
        name: "home",
        meta: { 
            title: "Home", // 导航菜单项标题
            icon: "qq" // 导航菜单项图标
        }
      },
      {
        path: "mua",
        component: () =>
          import(/* webpackChunkName: "home" */ "@/views/Home.vue"),
        name: "mua",
        meta: { 
            title: "波一个", // 导航菜单项标题
            icon: "wx" // 导航菜单项图标
        }
      }
    ]
  }
];

// 3 配置到 Router 中，作为常规配置
export default new Router({
  mode: "history",
  base: process.env.BASE_URL,
  routes: constRoutes
});
```



#### asyncRoutes 权限（动态）路由

接上上面的路由文件写

> 动态的路由
>
> 那些需要判断权限并通过 `addRoutes` 动态添加的页面
>
> asyncRoutes 保证安全性，建议是从后端传来

```js
// src/router/index.js
// ...
// 1 权限页面
export const asyncRoutes = [
    {
      path: "/about",
      component: Layout,
      redirect: "/about/index",  
     
      children: [
        {
          path: "index",
          component: () =>
            import(/* webpackChunkName: "home" */ "@/views/About.vue"),
          name: "about",
          // 2 meta 中定义的东西，将来是布局组件侧边栏中需要用到的内容
          // 是约定的内容
          meta: { 
              title: "用户中心", 
              icon: "qq",
                    // 3 权限控制
                // 这些角色是基于服务端给的角色类型约定的
              roles: ['editor']
          },
        },
        {
          path: "bla",
          component: () =>
            import(/* webpackChunkName: "home" */ "@/views/About.vue"),
          name: "bla",
          meta: { 
              title: "关于我们", 
              icon: "qq",
              roles: ['admin']
          },
        },
      ]
    }
  ];

// ...
```



### 路由处理逻辑分析

基于 `vue-element-admin` 的路由权限处理原理进行分析

> 这种中后台路由常用实现逻辑

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200110133744.png)

- 访问每个页面 `/xxx`，首先会被全局路由守卫 `beforeEach` 拦截
- 判断本地是否已经有 `token`
- 不存在 `token`，就看该路由是否在 `白名单`中
  - 是，访问该路由页面
  - 否，访问预定的重定向页面，比如 `登陆` 页面，并且携带上原本要访问的页面`/login?redirect=/xxx` 
- 存在 `token`，要判断是否为 `登陆` 页面
  - 是，重定向到首页 `/`
  - 否，生成角色、通过权限校验和匹配获取动态路由，使用 `replace` 访问路由 `/xxx`
  - 若在匹配路由的时候出现异常，则会重置 `token`, 然后重定向到登录页面 `/login?redirect=/xxx`（携带原本要访问的页面）
- 最后，若访问一个不存在的页面，则会跳到 `404` 页面

```js
// 会放在 asyncRoutes 最后一个
{path:'*', redirect: '/404', hidden: true}
```



### 路由逻辑源码

首先要创建一个 `permission.js` 用于定义全局路由守卫，然后在 `main.js` 中加载这个文件 `import './permission'`



在这个文件中，主要是使用了

- `beforeEach` 和 `afterEach`
- 还定义了 `whiteList` 路由白名单

> 如果要在项目中 debbuger 源码，首先开启 `source-map`

```js
// src/permission.js
import router from './router'
import store from './store'
import { Message } from 'element-ui'
import NProgress from 'nprogress' // 进度条
import 'nprogress/nprogress.css' // 进度条样式
import { getToken } from '@/utils/auth' // 操作 cookie
import getPageTitle from '@/utils/get-page-title' // 从路由中获取标题配置

NProgress.configure({ showSpinner: false }) // 隐藏进度条的加载小圆环

// 1 白名单
const whiteList = ['/login', '/auth-redirect'] 

// 2 路由守卫
router.beforeEach(async(to, from, next) => {
  // 2.1 进度条 UI
  // 通过后面的 .done() 关闭
  NProgress.start()

  // 2.2 通过路由配置项更改页面标题
  document.title = getPageTitle(to.meta.title)

  // 2.3 从 cookie 中拿 token
  const hasToken = getToken()

  if (hasToken) {
    // 2.4 有 token 时
    if (to.path === '/login') {
      // 2.4.1 若访问的是登录页面，则跳转到首页
      // 此时因为进行了路由访问，所以还是会进入路由守卫 beforeEach
      next({ path: '/' })
      NProgress.done()
    } else {
      // 2.4.2 有 token ，访问非登录页面时
      // 去 vuex 中拿 roles 角色信息
      const hasRoles = store.getters.roles && store.getters.roles.length > 0
      if (hasRoles) {
        // 2.4.3 roles 存在，直接访问页面
        next()
      } else {
        // 2.4.4 rules 不存在，调用接口去获取
        try {
          // 调用接口
          const { roles } = await store.dispatch('user/getInfo')

          // 生成动态路由表
          const accessRoutes = await store.dispatch('permission/generateRoutes', roles)

          // 与静态路由合并成新的路由表
          router.addRoutes(accessRoutes)

          // replace 到要去的页面，这样就不会返回到之前重定向的页面
          next({ ...to, replace: true })
        } catch (error) {
          // 2.4.5 处理异常情况
          // 重置 token：token置空，roles置空，清理cookie
          await store.dispatch('user/resetToken')
          // 打印错误日志
          Message.error(error || 'Has Error')
          // 重定向到登录页
          next(`/login?redirect=${to.path}`)
          NProgress.done()
        }
      }
    }
  } else {
    // 2.5 无 token 时
    if (whiteList.indexOf(to.path) !== -1) {
      // 2.5.1 判断要访问的路由是否在白名单内
      next()
    } else {
      // 2.5.2 没有在白名单里，重定向到首页，并携带上原本要访问页面的路由路径
      next(`/login?redirect=${to.path}`)
      NProgress.done()
    }
  }
})

router.afterEach(() => {
  // 去掉进度条
  NProgress.done()
})
```



#### 工具库 js-cookie 的操作

这里操作 `cookie` 的是 `js-cookie` 库

- 安装 elementUi：`vue add element`
- 安装 cookie 操作库：`npm i js-cookie -S`



```js
// src/util/auth.js
import Cookies from "js-cookie";

const Token = "token"; // 要操作的 key

export function getToken() {
  return Cookies.get(Token);
}

export function setToken(token) {
  return Cookies.set(Token, token);
}

export function removeToken() {
  return Cookies.remove(Token);
}
```



### 动态路由源码分析（Vuex）

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200110143439.png)

#### permission 模块

- 用户登录系统时，会动态生成路由，其中 constantRoutes 必然包含，asyncRoutes 会进行过滤；
- asyncRoutes 过滤的逻辑是看路由下是否包含 meta 和 meta.roles 属性，如果没有该属性，所以这是一个通用路由，不需要进行权限校验；如果包含 roles 属性则会判断用户的角色是否命中路由中的任意一个权限，如果命中，则将路由保存下来，如果未命中，则直接将该路由舍弃；
- asyncRoutes 处理完毕后，会和 constantRoutes 合并为一个新的路由对象，并保存到 vuex 的 permission/routes 中；
- 用户登录系统后，侧边栏会从 vuex 中获取 `state.permission.routes`，根据该路由动态渲染用户菜单。

```js
// src/store/modules/permission.js
import { asyncRoutes, constantRoutes } from '@/router'

// 判断是否有权限
function hasPermission(roles, route) {
  if (route.meta && route.meta.roles) {
    // 判断是否有路由的权限配置
    // roles 是否包含了该路由配置 meta.roles 数组中的某一项
    return roles.some(role => route.meta.roles.includes(role))
  } else {
    // 没有配置权限的时候，默认视作有权限
    return true
  }
}

// 遍历路由看是否有权限
export function filterAsyncRoutes(routes, roles) {
  const res = []

  routes.forEach(route => {
    const tmp = { ...route }
    if (hasPermission(roles, tmp)) {
      // 有对应权限才进行下面的递归操作
      if (tmp.children) {
        // 递归判断是否有下一项
        tmp.children = filterAsyncRoutes(tmp.children, roles)
      }
      res.push(tmp)
    }
  })

  return res
}

const state = {
  routes: [],
  addRoutes: []
}

const mutations = {
  SET_ROUTES: (state, routes) => {
    state.addRoutes = routes
    // 合并路由，其实这就是用于生成侧边栏菜单的依据
    state.routes = constantRoutes.concat(routes)
  }
}

const actions = {
  generateRoutes({ commit }, roles) {
    return new Promise(resolve => {
      let accessedRoutes
      if (roles.includes('admin')) {
        // 该路由中包含了 admin 权限
        accessedRoutes = asyncRoutes || []
      } else {
        accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)
      }
      // 调用 mutations 方法，更新 路由表
      commit('SET_ROUTES', accessedRoutes)
      resolve(accessedRoutes)
    })
  }
}
```



#### Vuex 模块化

```js
// src/store/index.js
import Vue from 'vue'
import Vuex from 'vuex'
// 2个子模块
import permission from './modules/permission'
import user from './modules/user'

Vue.use(Vuex)

const store = new Vuex.Store({
  // 1 模块化引入两个子模块
  modules: {permission, user},
  // 2 全局定义getters便于访问
  getters: {
    // 每次从 user 中拿出访问权限
    roles: state => state.user.roles,
    token: state => state.user.token,
    permission_routes: state => state.permission.routes,
  }
})

export default store
```

