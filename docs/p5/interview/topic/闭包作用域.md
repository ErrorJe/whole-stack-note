# 闭包作用域

## IIFE

### 立即执行函数

```js
const foo = (function() {
  var v = 0
  return () => {
    return v++
  }
}())

console.log(foo) // [Function]
for(let i=10; i>=0; i--) foo() // 变量v循环了10次，最后自由变量v的值是10
```



### 闭包实现单例模式

单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点

使用闭包可以保持实例的引用，不被垃圾回收机制回收

```js
function Person() {
  this.name = 'lucas'
}

const getSingleInstance = (function(){
  var singleInstance // 自由变量
  return function() {
    if (singleInstance) {
      return singleInstance
    } 
    return singleInstance = new Person()
  }
})()

const instance1 = new getSingleInstance()
const instance2 = new getSingleInstance()
console.log(instance1 === instance2) // true。单例，引用是一样的。
```



### 执行上下文

```js
var test = (function(i) {
    return function(){
        alert(i *= 2)
    }
})(2)
```



此时的自执行函数执行（函数执行，创建一个执行上下文，也是栈）后，返回另一个函数（只是返回，没有执行）

- 堆存放函数时：存储代码的字符串
- 堆存放对象时：存储 prototype 、length 等对象属性

然后 test 拿到的是函数执行表达式的返回值，也就是图右边的堆内存（存放引用对象）地址。

那么也就是说，该堆的上级作用域指向的是自执行函数创建的执行上下文（堆在哪里创建的，上级作用域就是谁）。

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119163312.png)

此时，执行 test(5)，又是函数执行，创建一个执行上下文。

若要执行 i *= 2，要先找 i，但是找不到，所以只能顺着作用域链找，然后找到上面那个执行上下文，i 为2，得到结果4。

最后，因为该新上下文里的东西没有被其他人使用，所以会被销毁（GC 垃圾回收）

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119163329.png)

关于闭包是怎么留下来的，就是上面那个堆，是被其他人用到了，就是那个 test 变量。所以会一直留着，然后可以一直拿上级上下文的变量 i 来使用



## 作用域

### 题1

```js
const foo = () => {
  var arr = []
  var i

  for (i = 0; i < 10; i++) {
    arr[i] = function () {
      console.log(i)
    }
  }

  return arr[0] 
}
foo()() // 10。foo()返回的是 arr[10], 他是个方法加上()执行，所以最后打印出来的是10
```



### 题2

```js
var fn = null
const foo = () => {
  var a = 2
  function innerFoo() { 
    console.log(a)
  }
  fn = innerFoo // 赋值给全局变量 fn，导致在innerFoo中用到的变量a也被保留   
}

const bar = () => {
  fn() // innerFoo() 打印的是2
}

foo() // 就是将 innerFoo 赋值给了全局变量，让用到的a变量保留
bar() // 2 
```



### 题3

```js
var fn = null
const foo = () => {
  var a = 2
  function innerFoo() { 
    console.log(c)            
    console.log(a)
  }
  fn = innerFoo
}

const bar = () => {
  var c = 100 
  fn() // 尽管在上面定义了c ，但此时 fn() 已经被赋值成 innerFoo，且没定义c
}

foo()
bar() // 报错。c is not defined
```





















