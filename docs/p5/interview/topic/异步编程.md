# 异步编程和 Event Loop

## 红绿灯任务控制

红灯3s亮一次，绿灯1s亮一次，黄灯2s亮一次。如何让3个等不断交替重复亮灯？

```js
function red() {
  console.log('red');
}
function green() {
  console.log('green');
}
function yellow() {
  console.log('yellow');
}
```

难点在于“交替重复”，而不是一锤子买卖



### callback 解决

```js
const task = (timer, light, callback) => {
  setTimeout(() => {
    if (light === 'red') {
      red()
    }
    else if (light === 'green') {
      green()
    }
    else if (light === 'yellow') {
      yellow()
    }
    callback()
  }, timer)
}

// 在这里还是执行了一次而已
task(3000, 'red', () => {
  task(2000, 'green', () => {
    task(1000, 'yellow', Function.prototype)
  })
})

// 要重复执行。就要递归亮灯的一个周期，这个周期封装了三个灯亮的函数
const step = () => {
  task(3000, 'red', () => {
    task(2000, 'green', () => {
      task(1000, 'yellow', step) // 黄灯亮完继续执行下一个周期
    })
  })
}

step()
```



### Promise 解决

```js
const task = (timer, light) => 
new Promise((resolve, reject) => {
  setTimeout(() => {
    if (light === 'red') {
      red()
    }
    else if (light === 'green') {
      green()
    }
    else if (light === 'yellow') {
      yellow()
    }
    resolve() // 每次亮灯后，resolve 当前的 promise
  }, timer)
})

const step = () => { // 要重复周期。就要把3个灯亮的任务都封装在一个函数，然后去递归调用
  task(3000, 'red')
    .then(() => task(2000, 'green'))
    .then(() => task(2100, 'yellow'))
    .then(step) // 黄灯亮完执行下一个周期
}

step()
```



### async/await 解决

对于理解比较舒服，等于是理解同步代码

```js
// 上面部分是一样的，都是一个promise

const taskRunner =  async () => {
  await task(3000, 'red')
  await task(2000, 'green')
  await task(2100, 'yellow')
  taskRunner()
}

taskRunner()
```



## 图片预加载

假设有 `urlIds` 数组，每一个项都是可以按照 `主Url` 拼接成完整图片的地址。根据这个数组一次请求图片进行预先加载。

### 图片请求方法

```js
const loadImg = urlId => {
  const url = `http://www.image.com/${urlId}` // 拼接的图片地址

  return new Promise((resolve, reject) => { // 封装个 promise
    const img = new Image()
    img.onerror = function() {
      reject(urlId) // 加载失败
    }
    img.onload = function() {
      resolve(urlId) // 加载成功
    }
    img.src = url
  })
}
```



### 依次请求图片

都是依次执行，只有成功加载完第一张图，才继续下一张图片的加载

#### reduce 控制  promise 的方式

```js
const urlIds = [1, 2, 3, 4, 5]

urlIds.reduce((prevPromise, urlId) => {
  return prevPromise.then(() => loadImg(urlId))
}, Promise.resolve())
```



#### 面向过程实现的方式

递归实现

```js
const loadImgOneByOne = index => {
  const length = urlIds.length

  loadImg(urlIds[index]).then(() => {
    if (index === length - 1) {
      return 
    }
    else {
      loadImgOneByOne(index++)
    }
  })

}
loadImgOneByOne(0)
```



#### async/await 方式

```js
const loadImgOneByOne = async () => {
  for (i of urlIds) {
    await loadImg(urlIds[i])
  }
}
loadImgOneByOne()
```



### 同时请求图片

```js
const urlIds = [1, 2, 3, 4, 5]

const promiseArray = urlIds.map(urlId => loadImg(urlId)) // promise数组

Promise.all(promiseArray) // Promise.all 同时发出请求
  .then(() => {
  console.log('finish load all')
})
  .catch(() => {
  console.log('promise all catch')
})
```



现在根据实际要求，控制最大并发数。如果在上限以下的并发请求，则同时发出。

实现一个 `loadByLimit` 函数

```js
const loadByLimit = (urlIds, loadImg, limit) => {
  const urlIdsCopy = [...urlIds] // 图片路径数组

  if (urlIdsCopy.length <= limit) { // 如果数组长度小于最大并发数，直接全部请求
    const promiseArray = urlIds.map(urlId => loadImg(urlId))
    return Promise.all(promiseArray)
  }

  // 注意 splice 方法会改变 urlIdsCopy 数组
  // 这是在限定并发数的一组promise请求数组，也是第一次用于 race 请求的初始组
  const promiseArray = urlIdsCopy.splice(0, limit).map(urlId => loadImg(urlId)) 

  urlIdsCopy.reduce( // 所有图片路径数组都拿进来reduce，但是每次只处理限定并发的那几个，来promise.race
    (prevPromise, urlId) => 
    prevPromise
    .then(() => Promise.race(promiseArray)) // 接受promise数组，返回第一个resolve的promise
    .catch(error => {console.log(error)})
    .then(resolvedId => { // 将 resolvedId 剔除出 promiseArray 数组。也就是第一个返回的promise
      let resolvedIdPostion = promiseArray.findIndex(id => resolvedId === id)
      promiseArray.splice(resolvedIdPostion, 1)

      // 从 urlIdsCopy 中补充一个 urlId promise 到 promiseArray 数组
      promiseArray.push(loadImg(urlId))
    })
    , 
    Promise.resolve()
  )
    .then(() => Promise.all(promiseArray)) // 将剩下的promise执行
}
```



## 阿里核心部门面试题

### 题目概述

后端有一个服务，支持批量返回书籍信息。接受一个数组作为请求数据，数组储存了需要获取书目信息的书目ID，该服务的 `fetchBooksInfo` 大概如下。

```js
const fetchBooksInfo = bookIdList => {
    // ...
    return ([{

            id: 123,
            // ...

        },
        {
            id: 456
            // ...
        },
        // ...
    ])
}
```

但是该接口最多支持100个id的查询，现在需要开发者实现 `getBooksInfo` 方法

- 支持调用单个书目信息

```js
getBooksInfo(123).then(data => {console.log(data.id)}) // 123
```

- 短时间（100ms）内多次连续调用，只发送一个请求，且获得各个书目信息

- - 就是在这个部分，只能发起一次请求，只调用一次 fetchBooksInfo 接口
  - 要考虑服务端出错，如请求[1, 2]， 只返回了1.此时要进行合理的错误处理
  - 对id重复进行处理

```js
getBooksInfo(123).then(data => {console.log(data.id)}) // 123
getBooksInfo(456).then(data => {console.log(data.id)}) // 456
```



### 解决方案

```js
// 1 储存将要请求的 id 数组
let bookIdListToFetch = []

// 2 储存每个 id 请求 promise 实例的 resolve 和 reject
// key 为 bookId，value 为 resolve 和 reject 方法，如： { 123: [{resolve, reject}]}
// 这里之所以使用数组存储 {resolve, reject}，是因为可能存在重复请求同一个 bookId 的情况。
// 其实这里我们进行了滤重，没有必要用数组。在需要支持重复的场景下，记得要用数组存储
let promiseMap = {}

// 用于数组去重
const getUniqueArray = array => Array.from(new Set(array))

// 定时器 id
let timer

// 请求方法
const getBooksInfo = bookId => new Promsie((resolve, reject) => {
  promiseMap[bookId] = promiseMap[bookId] || []
  promiseMap[bookId].push({
    resolve,
    reject
  })

  const clearTask = () => {
    // 清空任务和存储
    bookIdListToFetch = []
    promiseMap = {}
  } 

  if (bookIdListToFetch.length === 0) { // 当没有对应id需要请求时，push 当前的请求id
    bookIdListToFetch.push(bookId)

    timer = setTimeout(() => {
      handleFetch(bookIdListToFetch, promiseMap) // 统一请求

      clearTask() // 清除请求列表和promise列表
    }, 100)
  }
  else {
    bookIdListToFetch.push(bookId)

    bookIdListToFetch = getUniqueArray(bookIdListToFetch) // 数组去重

    if (bookIdListToFetch.length >= 100) { // 超过并发数
      clearTimeout(timer)

      handleFetch(bookIdListToFetch, promiseMap)

      clearTask()
    }
  }
})

// 统一请求方法
const handleFetch = (list, map) => {
  // fetchBooksInfo 是接口。
  fetchBooksInfo(list).then(resultArray => {
    const resultIdArray = resultArray.map(item => item.id) // 拿出返回的id数组

    // 处理存在的 bookId
    resultArray.forEach(data => promiseMap[data.id].forEach(item => {
      item.resolve(data)
    }))

    // 处理失败没拿到的 bookId
    let rejectIdArray ＝ []
    bookIdListToFetch.forEach(id => {
      // 返回的数组中，不含有某项 bookId，表示请求失败
      if (!resultIdArray.includes(id)) {
        rejectIdArray.push(id)
      }
    })

    // 对请求失败的数组进行 reject
    rejectIdArray.forEach(id => promiseMap[id].forEach(item => {
      item.reject()
    }))
  }, error => {
    console.log(error)
  })
}
```





## Event Loop

### 定时器

这里第一个宏任务，就是先打印了a，再打印了b。

然后执行异步resolve，这里定时器无论是多久都是一样的，最后是打印了c

```js
function sleep(duration) {
    return new Promise(function(resolve, reject) {
        console.log("b");
        setTimeout(resolve,duration);
    })
}
console.log("a");
sleep(5000).then(()=>console.log("c"));
```



### promise

- 同步代码执行 ，1， 2（后面是抛出了 resolve，后面对应的 4  promise.then 是个异步，放到任务队列中）， 3

- 同步代码全部执行完毕，开始执行任务队列中的任务。也就是 4, 5（抛出 resolve，对应后面的 6）

- 输出 6 ，7

```js
console.log('1 start here')
new Promise((resolve, reject) => {
    console.log('2 first promise constructor')
    resolve()
  })
  .then(() => {
    console.log('4 first promise then')
    return new Promise((resolve, reject) => {
        console.log('5 second promise')
        resolve()
      })
      .then(() => {
        console.log('6 second promise then')
      })
  })
  .then(() => {
    console.log('7 another first promise then')
  })
console.log('3 end here')
```



### promise 结合定时器

再详细分析一下例子：在当前的微任务没有执行完成的时候，是不会执行下一个宏任务的

```js
console.log('1 sync1'); // 宏任务1 微任务1 1

setTimeout(function () {
    console.log('5 setTimeout1') // 宏任务2
}, 0);

var promise = new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log('6 setTimeoutPromise') // 宏任务3
    }, 0);
    console.log('2 promise'); // 宏任务1 微任务1 2
    resolve(); // 在宏任务1中被调用，所以这个resolve对应的then也属于该宏任务
});


promise.then(() => {
    console.log('4 pro_then'); // 宏任务1 微任务2 1
    setTimeout(() => {
        console.log('8 pro_timeout'); // 宏任务5
    }, 0)
})

setTimeout(function () {
    console.log('7 last_setTimeout') // 宏任务4
}, 0);
console.log('3 sync2'); // 宏任务1 微任务1 3
```



### 微任务和宏任务

- 同步执行代码 1， 2， 3(遇到 setTimeout，放入宏任务队列，也就是最后再去考虑）

- 继续执行，碰到 promise1 ,的resolve（5，放入微任务队列）。继续执行，碰到第一个匿名promise的resolve（6 放入微任务队列）。
- 执行最后一个同步，4
- 开始执行微任务队列 5， 6
- 执行宏任务队列， 7

```js
console.log('1 start here')
const foo = () => (new Promise((resolve, reject) => {
  console.log('2 first promise constructor')
  let promise1 = new Promise((resolve, reject) => {
    console.log('3 second promise constructor')
    setTimeout(() => {
      console.log('7 setTimeout here')
      resolve()
    }, 0)
    resolve('5 promise1')
  })
  resolve('6 promise0')
  promise1.then(arg => {
    console.log(arg) // 5
  })
}))
foo().then(arg => {
  console.log(arg) // 6
})
console.log('4 end here')
```



### 网红题：Async

浏览器是多线程的，JS 是单线程的。浏览器只给一个线程来渲染 JS，这就是 JS 执行的主线程

另外，浏览器还给 JS 单独留了一个 任务队列，其中分为微任务和宏任务。

一个原则就是主线程执行完毕才会去执行任务队列里的代码。然后先执行微任务，微任务没了再执行宏任务。

接下来解析这道题的执行顺序



主线程第一次执行

- 创建函数 async1

- 创建函数 async2

- 输出 “1 script start”

- 设置定时器 （宏任务 A 放入宏任务队列），虽然是 0 ms，但浏览器最小是 4ms

- 函数执行 async1

- - 输出 “2 async1 start"

  - 执行 await async2 函数 （本质是promise，所以是个微任务 B）

  - - 输出 “3 async2”，并返回一个 resolve 值为 `undefined` 的 promise

  - 等待 await 结果返回

- 执行 new promise（会直接执行里面的 EC 函数，new 的时候是同步的）

- - 执行函数，输出 “4 promise1”
  - resolve （微任务 C）

- 后面没有代码， 直接输出 ”5 script end“



Event Loop 执行

- 先执行微任务

- - 微任务B 执行，输出 “6 async1 end”
  - 微任务C 执行，输出 “7 promise2”

- 最后执行宏任务

- - 宏任务A 执行，输出“8 setTimeout“

```js
async function async1() {
    console.log('2 async1 start') // step 4: 直接打印同步代码 async1 start
    await async2() // step 5: 遇见 await，首先执行其右侧逻辑，并在这里中断 async1 函数
    console.log('6 async1 end') // step 11: 再次回到 async1 函数，await 中断过后，打印代码 async1 end
}

async function async2() {
    console.log('3 async2') // step 6: 直接打印同步代码 async2，并返回一个 resolve 值为 `undefined` 的 promise (放入了微任务队列)
}

console.log('1 script start') // step 1: 直接打印同步代码 script start

// step 2: 将 setTimeout 回调放到宏任务中，此时 macroTasks: [setTimeout]
setTimeout(function() {            
    console.log('8 setTimeout') // step 13: 开始执行宏任务，输出 setTimeout
}, 0)  

async1() // step 3: 执行 async1

// step 7: async1 函数已经中断，继续执行到这里
new Promise(function(resolve) {
    console.log('4 promise1') // step 8: 直接打印同步代码 promise1
    resolve()
}).then(function() { // step 9: 将 then 逻辑放到微任务当中
    console.log('7 promise2') // step 12: 开始执行微任务，输出 promise2
})

console.log('5 script end') // step 10: 直接打印同步代码 script end，并回到 async1 函数中继续执行
```




