# 异步编程

## 红绿灯任务控制

红灯3s亮一次，绿灯1s亮一次，黄灯2s亮一次。如何让3个等不断交替重复亮灯？

```js
function red() {
  console.log('red');
}
function green() {
  console.log('green');
}
function yellow() {
  console.log('yellow');
}
```

难点在于“交替重复”，而不是一锤子买卖



### callback 解决

```js
const task = (timer, light, callback) => {
  setTimeout(() => {
    if (light === 'red') {
      red()
    }
    else if (light === 'green') {
      green()
    }
    else if (light === 'yellow') {
      yellow()
    }
    callback()
  }, timer)
}

// 在这里还是执行了一次而已
task(3000, 'red', () => {
  task(2000, 'green', () => {
    task(1000, 'yellow', Function.prototype)
  })
})

// 要重复执行。就要递归亮灯的一个周期，这个周期封装了三个灯亮的函数
const step = () => {
  task(3000, 'red', () => {
    task(2000, 'green', () => {
      task(1000, 'yellow', step) // 黄灯亮完继续执行下一个周期
    })
  })
}

step()
```



### Promise 解决

```js
const task = (timer, light) => 
new Promise((resolve, reject) => {
  setTimeout(() => {
    if (light === 'red') {
      red()
    }
    else if (light === 'green') {
      green()
    }
    else if (light === 'yellow') {
      yellow()
    }
    resolve() // 每次亮灯后，resolve 当前的 promise
  }, timer)
})

const step = () => { // 要重复周期。就要把3个灯亮的任务都封装在一个函数，然后去递归调用
  task(3000, 'red')
    .then(() => task(2000, 'green'))
    .then(() => task(2100, 'yellow'))
    .then(step) // 黄灯亮完执行下一个周期
}

step()
```



### async/await 解决

对于理解比较舒服，等于是理解同步代码

```js
// 上面部分是一样的，都是一个promise

const taskRunner =  async () => {
  await task(3000, 'red')
  await task(2000, 'green')
  await task(2100, 'yellow')
  taskRunner()
}

taskRunner()
```



## 图片预加载

假设有 `urlIds` 数组，每一个项都是可以按照 `主Url` 拼接成完整图片的地址。根据这个数组一次请求图片进行预先加载。

### 图片请求方法

```js
const loadImg = urlId => {
  const url = `http://www.image.com/${urlId}` // 拼接的图片地址

  return new Promise((resolve, reject) => { // 封装个 promise
    const img = new Image()
    img.onerror = function() {
      reject(urlId) // 加载失败
    }
    img.onload = function() {
      resolve(urlId) // 加载成功
    }
    img.src = url
  })
}
```



### 依次请求图片

都是依次执行，只有成功加载完第一张图，才继续下一张图片的加载

#### reduce 控制  promise 的方式

```js
const urlIds = [1, 2, 3, 4, 5]

urlIds.reduce((prevPromise, urlId) => {
  return prevPromise.then(() => loadImg(urlId))
}, Promise.resolve())
```



#### 面向过程实现的方式

递归实现

```js
const loadImgOneByOne = index => {
  const length = urlIds.length

  loadImg(urlIds[index]).then(() => {
    if (index === length - 1) {
      return 
    }
    else {
      loadImgOneByOne(index++)
    }
  })

}
loadImgOneByOne(0)
```



#### async/await 方式

```js
const loadImgOneByOne = async () => {
  for (i of urlIds) {
    await loadImg(urlIds[i])
  }
}
loadImgOneByOne()
```



### 同时请求图片

```js
const urlIds = [1, 2, 3, 4, 5]

const promiseArray = urlIds.map(urlId => loadImg(urlId)) // promise数组

Promise.all(promiseArray) // Promise.all 同时发出请求
  .then(() => {
  console.log('finish load all')
})
  .catch(() => {
  console.log('promise all catch')
})
```



现在根据实际要求，控制最大并发数。如果在上限以下的并发请求，则同时发出。

实现一个 `loadByLimit` 函数

```js
const loadByLimit = (urlIds, loadImg, limit) => {
  const urlIdsCopy = [...urlIds] // 图片路径数组

  if (urlIdsCopy.length <= limit) { // 如果数组长度小于最大并发数，直接全部请求
    const promiseArray = urlIds.map(urlId => loadImg(urlId))
    return Promise.all(promiseArray)
  }

  // 注意 splice 方法会改变 urlIdsCopy 数组
  // 这是在限定并发数的一组promise请求数组，也是第一次用于 race 请求的初始组
  const promiseArray = urlIdsCopy.splice(0, limit).map(urlId => loadImg(urlId)) 

  urlIdsCopy.reduce( // 所有图片路径数组都拿进来reduce，但是每次只处理限定并发的那几个，来promise.race
    (prevPromise, urlId) => 
    prevPromise
    .then(() => Promise.race(promiseArray)) // 接受promise数组，返回第一个resolve的promise
    .catch(error => {console.log(error)})
    .then(resolvedId => { // 将 resolvedId 剔除出 promiseArray 数组。也就是第一个返回的promise
      let resolvedIdPostion = promiseArray.findIndex(id => resolvedId === id)
      promiseArray.splice(resolvedIdPostion, 1)

      // 从 urlIdsCopy 中补充一个 urlId promise 到 promiseArray 数组
      promiseArray.push(loadImg(urlId))
    })
    , 
    Promise.resolve()
  )
    .then(() => Promise.all(promiseArray)) // 将剩下的promise执行
}
```



## 阿里核心部门面试题

### 题目概述

后端有一个服务，支持批量返回书籍信息。接受一个数组作为请求数据，数组储存了需要获取书目信息的书目ID，该服务的 `fetchBooksInfo` 大概如下。

```js
const fetchBooksInfo = bookIdList => {
    // ...
    return ([{

            id: 123,
            // ...

        },
        {
            id: 456
            // ...
        },
        // ...
    ])
}
```

但是该接口最多支持100个id的查询，现在需要开发者实现 `getBooksInfo` 方法

- 支持调用单个书目信息

```js
getBooksInfo(123).then(data => {console.log(data.id)}) // 123
```

- 短时间（100ms）内多次连续调用，只发送一个请求，且获得各个书目信息

- - 就是在这个部分，只能发起一次请求，只调用一次 fetchBooksInfo 接口
  - 要考虑服务端出错，如请求[1, 2]， 只返回了1.此时要进行合理的错误处理
  - 对id重复进行处理

```js
getBooksInfo(123).then(data => {console.log(data.id)}) // 123
getBooksInfo(456).then(data => {console.log(data.id)}) // 456
```



### 解决方案

```js
// 1 储存将要请求的 id 数组
let bookIdListToFetch = []

// 2 储存每个 id 请求 promise 实例的 resolve 和 reject
// key 为 bookId，value 为 resolve 和 reject 方法，如： { 123: [{resolve, reject}]}
// 这里之所以使用数组存储 {resolve, reject}，是因为可能存在重复请求同一个 bookId 的情况。
// 其实这里我们进行了滤重，没有必要用数组。在需要支持重复的场景下，记得要用数组存储
let promiseMap = {}

// 用于数组去重
const getUniqueArray = array => Array.from(new Set(array))

// 定时器 id
let timer

// 请求方法
const getBooksInfo = bookId => new Promsie((resolve, reject) => {
  promiseMap[bookId] = promiseMap[bookId] || []
  promiseMap[bookId].push({
    resolve,
    reject
  })

  const clearTask = () => {
    // 清空任务和存储
    bookIdListToFetch = []
    promiseMap = {}
  } 

  if (bookIdListToFetch.length === 0) { // 当没有对应id需要请求时，push 当前的请求id
    bookIdListToFetch.push(bookId)

    timer = setTimeout(() => {
      handleFetch(bookIdListToFetch, promiseMap) // 统一请求

      clearTask() // 清除请求列表和promise列表
    }, 100)
  }
  else {
    bookIdListToFetch.push(bookId)

    bookIdListToFetch = getUniqueArray(bookIdListToFetch) // 数组去重

    if (bookIdListToFetch.length >= 100) { // 超过并发数
      clearTimeout(timer)

      handleFetch(bookIdListToFetch, promiseMap)

      clearTask()
    }
  }
})

// 统一请求方法
const handleFetch = (list, map) => {
  // fetchBooksInfo 是接口。
  fetchBooksInfo(list).then(resultArray => {
    const resultIdArray = resultArray.map(item => item.id) // 拿出返回的id数组

    // 处理存在的 bookId
    resultArray.forEach(data => promiseMap[data.id].forEach(item => {
      item.resolve(data)
    }))

    // 处理失败没拿到的 bookId
    let rejectIdArray ＝ []
    bookIdListToFetch.forEach(id => {
      // 返回的数组中，不含有某项 bookId，表示请求失败
      if (!resultIdArray.includes(id)) {
        rejectIdArray.push(id)
      }
    })

    // 对请求失败的数组进行 reject
    rejectIdArray.forEach(id => promiseMap[id].forEach(item => {
      item.reject()
    }))
  }, error => {
    console.log(error)
  })
}
```

