# 面向对象

### 原型、new 优先级、变量提升

变量提升：当前作用域，var 变量提前声明，function 提前声明并定义赋值

- 提升函数 Foo 声明，并定义（函数引用是一个堆内存地址），Foo = AAAFFF000
- 提升变量 getName
- 提升函数 getName ，并定义 -> 5（功能是输出 5）

变量提升完后，开始执行代码

- Foo.getName 在 Foo 引用的堆上创建函数 getName->2
- Foo.prototype.getName，在 Foo 引用堆上的 prototype 上再创建一个原型对象引用（BBBFFF000），并在这个原型对象引用的堆上创建 getName->3
- 全局的 getName 赋值新函数 ->4，那之前的 ->5 函数被覆盖

```js
function Foo() {
  getName = function () {
    console.log(1);
  };
  return this;
}
Foo.getName = function () {
  console.log(2);
};
Foo.prototype.getName = function () {
  console.log(3);
};
var getName = function () {
  console.log(4);
};

function getName() {
  console.log(5);
}
Foo.getName(); // 2
getName(); // 4，执行全局的

// 1 ，先执行 Foo(), 发现 getName 不是在函数内定义的，所以向全局找，然后覆盖定义
// 此时全局的 getName 也变成了 -> 1
// Foo() 执行完返回 this ，普通函数的 this 就是 window
Foo().getName(); // 1 相当于执行了 window.getName()
getName(); // 1，函数定义已经被上一步修改

// 成员访问符优先级19，无参数 new 优先级18
// 所以先执行了 Foo.getName => 2
// 最后也是 new 了一下这个 Foo.getName ->2
new Foo.getName(); // 2 

// 有参数new优先级19，与成员访问符一样。所以正常从左到右执行
// 先创建了 Foo 的实例，然后调用了原型上的 getName -> 3
new Foo().getName(); // 3 

// 先执行了 new Foo()，创建了个实例 xxx
// 之后的代码实际上是 new xxx.getName()，所以是调用实例上，也就是原型方法
// xxx.getName() -> 3
new new Foo().getName(); // 3
```















































