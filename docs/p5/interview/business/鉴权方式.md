# 鉴权方式

 https://juejin.im/post/5e055d9ef265da33997a42cc#heading-0 

## Session-Cookie

> 这是把登录态放在服务器端存储的方式，前端存 sessionId（cookie）
>
> 现在有服务器集群（多台服务器），必须把信息放在持久化的地方以共享数据，如数据库DB和redis。

### 认证步骤

将登录信息保存在 session 中，说明是保存在服务器的。

在前端保存的是 cookie， 中有 session_id。访问服务器时携带这个 id。

服务器根据 id 知道用户是谁，然后拿出用户详细信息。

因为信息是写在服务器中的，所以也是安全可靠的。

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200108162423.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200108162423.png)</a>

- 登录请求，服务器创建 session，并产生唯一 `seesionId`，并在响应中设置 `cookie` ，属性名为 `jessionid`
- 客户端保存 `jessionid`，之后请求都会把这放入 `header` 请求头中
- 服务端每次从请求头中取出 sessionId 并进行用户身份认证



### 存在的问题

用户多起来后，用上 负载均衡 + redis 解决单点失败问题，但是一旦负责 session 存储的服务器出现什么问题，所有人都需要重新登录。



到这里位置，cookie-session 方式很难适应现代大体量的互联网应用，特别是移动应用，想办法让用户在浏览器自己管理 sessionId，所以就有了后来的 JWT。就是无状态的认证方式。



### 其他需要考虑的问题

#### cookie 的问题

- 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性

- 不要存储敏感数据，比如用户密码，账户余额

- 使用 httpOnly 在一定程度上提高安全性

- 尽量减少 cookie 的体积，能存储的数据量不能超过 4kb

- 设置正确的 domain 和 path，减少数据传输

- cookie 无法跨域

- 一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie

- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



#### session 的问题

- 将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session

- 当网站采用**集群部署**的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。

- 当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。

- **sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？** 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现

- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



## Token 认证、JWT 认证

### 基本认识

> JWT（ jsonWebToken），令牌认证，原理就是 JSON
>
> 是目前流行的跨域身份验证解决方案
>
> 是在前端存储 token ，服务端校验 token



通过令牌来识别身份。令牌有时效。

优点是部署简单。各个服务器都可以单独地去鉴权。是前后端分离架构使用的方式。

缺点就是，只认令牌，不认人。如果被别人拿到，就可以进行访问。



#### JWT 和 Token 解决的问题

- JWT 解决的是 `cookie-session` 有前后端状态的认证问题，不是为了解决安全问题
- JWT 适合一次性验证如右键激活（因为不需要后端存储用户和 token 中 signaure 的关系，只需要验签），Token 适合普通的 API 请求（ 需要服务端存储 Token 和用户的关系 ）
- 拦截无效请求，降低服务器处理压力；
- 实现第三方 API 授权，无需每次都输入用户名密码鉴权；
- 身份校验，防止 CSRF 攻击。



#### JWT 和 Token 的区别

**相同：**

- 都是访问资源的令牌
- 都可以记录用户的信息
- 都是使服务端无状态化
- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。





#### 与 session, cookie 的区别

- Session 保存在服务端，用于客户端与服务端连接时，临时保存用户信息，当用户释放连接后，Session 将被释放；
- Cookie 保存在客户端，当客户端发起请求时，Cookie 会附带在 http header 中，提供给服务端辨识用户身份；
- Token 请求时提供，用于校验用户是否具备访问接口的权限
- Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而 Token 是**令牌**，**访问资源接口（API）时所需要的资源凭证**。Token **使服务端无状态化，不会存储会话信息。**
- Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**
- 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**



#### 使用 token 时需要考虑的问题

- 如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
- **token 完全由应用管理，所以它可以避开同源策略**
- **token 可以避免 CSRF 攻击(因为不需要 cookie 了)**
- **移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token**



#### 使用 JWT 时需要考虑的问题

- 因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
- JWT 不加密的情况下，不能将秘密数据写入 JWT。
- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
- JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
- JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
- JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
- 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。



#### 使用加密算法时需要考虑的问题

- 绝不要以**明文存储**密码
- **永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码**。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。
- 绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。
- 绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 **一次性的**（这点很重要）密码，然后把这个密码发送给用户。



### Token 使用（服务器交互过程）

> 前端对于 token ，只能是判断有没有登录。之后就是请求时携带 token。

#### 用户访问某页面

- 客户端请求服务端
- 服务端判断是否携带令牌，没有则返回 401 状态

#### 重定向登录页

- 用户操作登录，客户端请求服务端验证登录
- 服务端登录成功，给客户端签发 token 令牌

#### 客户端缓存 token

- 前端一般存到 `sessionStorage`
- 之后每次请求服务器，都要携带 token
  - 一般是放于 header 请求头中
- 服务器验证 token，验证后返回数据
  - 是否存在
  - 是否正确
  - 是否过期



### Bearer Token 规范（前端部分）

> 在用 HTTP 访问 OAuth2 保护资源时如何使用令牌的一个规范

- 特点：令牌就是身份证明，无需证明令牌的所有权
- 具体规定和实现：在请求头中定义 `Authorization`

```js
// 固定字符串 Bearer（后有一个空格）
Authorization: Bearer <token>
```

用这种规范实际应用的代码

> 这样使用后，不管后台使用什么语言。只要按照这个规范都能正确解析出 token

```js
if (token) { 
  config.headers.Authorization = 'Bearer ' + token 
}
```



### JWT 规范（后端部分规范）

> 令牌具体定义方式。jwt.io 这个网站可以去看 Token 的解析。

#### 令牌的组成

我们看到的 `token` 字符串实际上是有 3 部分组成的。类似 ` adfafdsfsadf.dfdswerwe.sfsxsdf3 `

- 令牌的组成：头 + 载荷 + 签名
  - 这些虽然经过加密，但都是明文。所以不能用于传递敏感信息
  - 载荷信息是能被反解的，但是秘钥是无法拿出来的

```js
Header.Payload.Signature
```

- Header 含加密算法，令牌类型等信息

```js
{
  "alg": "HS256"， // 标记签名的算法
  "typ": "JWT"
}
```

- Payload 载荷: 虽然用了 Base64 转换，但是可以转换回来，所以不要放隐私数据。一般会包含用户信息， 签发时间和过期时间等信息

```js
{
  "sub": "1234567890"， //  payload 这里是存我们的方存放的用户信息
  "name": "John Doe"，
  "admin": false，
  exp: number // 过期时间
  ......
}
```

- Signature 签名：根据头、载荷及服务端秘钥加密得到的哈希串
  - 默认算法：Hmac Sha1 256
  - 会把这3个组成经过加密成一个 32 位的字符串。保证前端无法预测

```js
const signature = HMACSHA256（
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),+ "." +secret);
res.send({signature: signature})
```





#### 具体实现（koa实现）

```js
// 服务端 -/server/server.js
const Koa = require('koa')
const Router = require('koa-router')
// 生成和验证令牌的模块
const jwt = require('jsonwebtoken')
const jwtAuth = require('koa-jwt')
// 服务端秘钥, 这个秘钥的生成规则不同。可能是根据密码之类的东西二次加密
const secret = 'it's a secret' 
const app = new Koa()
const router = new Router()

// 登录接口
router.get('/api/login', async ctx => {
  const {username, passwd} = ctx.query
  
  if(username == 'wjy' && passwd = '123') {
    // 账号密码验证成功， 生成令牌（三部分构成）
    const token = jwt.sign(
    	{
        data:{name:'wjy'}, // 用户信息数据
        exp:Math.floor(Date.now() / 1000) + 60 * 60 // 过期时间
      },
      secret
    )
    ctx.body = {code:1,token}
  } else {
    // 登录失败
    ctx.status = 401
    ctx.body = {code:0, message:'用户名或密码错误'}
  }
})

// 受保护的路由
// 因为前端的东西不可信，所以都是要后端来做验证
router.get(
	'/api/userinfo',
  jwtAuth({secret}), // 验证 token 有效性
  // 返回用户信息
  async ctx => {
    ctx.body = {code:1, data:{name:'jerry', age:20}}
  }
)
app.use(router.routes())
app.listen(3000)
```



#### 解决跨域

> 因为上面的 koa 服务开启的是 3000 端口，前端假设是 8000 端口。那么就跨域了。
>
> 去 vue.config.js 中配置代理服务器
>
> 如果是 mock 服务器的话，也是在 `devServer`中写中间件。现在是“真”的服务器，所以用 proxy 就行了

```js
// vue.config.js
export default {
  // ...
  devServer: {
    // 代理配置。前端访问 "/api" 时就转发到 target 的地址上去
    proxy:{
      '/api':{
        target:'http://127.0.0.1:3000/',
				changeOrigin:true
      }
    }
  },
  // mock 服务。before(app) {...}
}
```



#### 安全性控制

- 缩短 Token 有效时间
- secret 定时替换
- 使用 HTTPS 加密协议
- 对标准字段 iss、sub、aud、nbf、exp 进行校验



## OAuth2.0 开放授权

> 跳到第三方页面进行登录、授权再回来
>
> 推荐文章，阮一峰老师的： <http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html>
>
> 根据描述， Oauth2 有4种授权方式
>
> ​	授权码模式（主流使用，最完整严格），简化模式，密码模式，客户端模式
>
> 客户端必须得到用户的授权，才能获得令牌

我们不再需要在每个平台上注册，通过 oauth 可以从原来的平台（github，qq, 163等）拿到一些自己的用户信息，授权给某个平台使用。



### 鉴权流程

要在第三方平台配置3个东西

- client_id 标识
- client_secret 密钥
- redirect_uri 登录授权后重定向的地址

用户操作登录后，后端拿到3个字段再拼接成地址，然后给第三方进行校验，第三方回调 `redirect_uri` 并跟着 `token`

- token
- clinet_secret

去第三方获取 `accessToken`，然后凭这个就可以在第三方调用 API 获取用户信息，放入 cookie



### 访问的流程

- 用户访问客户端，后者将前者导向认证服务器（微信服务器）
- 用户选择是否给予客户端授权
- 若用户给予授权，认证服务器将向客户端指定“重定向URL”。同时给予授权码
- 客户端收到授权码，附上“重定向URL”，并向认证服务器申请令牌。该步骤在后台服务器上完成，对用户不可见
- 认证服务器核对授权码和重定向URL。无误后，向客户端发送访问令牌和更新令牌。

> 对于微信公众号来说，获取用户信息，就是相当于普通网页的用户登录

- 生成认证URL， 跳转微信认证服务， 回调服务端获取code，调用微信接口accessToken和openid，调用服务端接口

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109095453.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109095453.png)</a>



## SS0 单点登录

> 在多个应用系统中，只要登录一次，就可以访问其他相互信任的应用系统

### 同一级域名下处理

假设父级域名是 `a.com` 那么下面所有的域名都可以拿到 cookie

- 1.a.com
- 2.a.com
- 3.a.com

这样就解决了三个系统之间传递信息了，把用户登录态放在 `a.com` 的 cookie 中就行（就是设置这个 cookie 的 `Domain` 属性）

再搭配一个共享 `session` 池的服务器，完成单点登录（大多数公司内部系统的通信方式）。

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109110632.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109110632.png)</a>

### 多系统登录

- 同域名：cookie 共享，单服务或多服务没有区别
- 不同子域名：子级之间不共享，但可以拿到父级 cookie，所以可以设置在父级域名上
- 完全不同域名：不同域名下无法共享 cookie



### 跨域 CORS

要后端接口支持 `CORS` 访问，且浏览器为了安全，不允许 `withCredentials` 配置 `*` 符号，所以要明确设置可访问的域名名单。

也可以通过访问的 `Referrer` 解析请求来源域名，作为可访问名单。但是这样不够安全。



### 单点登录 CAS

就是采用`通用session` 的方式登录多个完全不同域的系统。只需要在某个系统下验证后，就可以拿到 session，然后就可以访问所有系统





## LDAP 认证

>  轻量目录访问协议，这个协议是基于 TCP/IP 的，意思是它的数据存储是基于目录文件的。 

就是很多的系统，每次都要登录，但是登录的账号密码都是一样的。

跟 `sso`  的区别在于 sso 是到专门的一个页面去登录，`LDAP` 需要每次都进行登录。



## 扫码登录

> 二维码的本质就是一个 URL

生成二维码的同时会提供一个 `uuid` 到 URL 上，比如

```js
http://www.a.com?uuid=xxxxx
```

当手机扫码后，会带上 `uuid` 和 `用户信息`。后端解析后就知道用户登录进来的，二维码页面跳转到某个页面。



我们利用 `qrcode.js` 这个库完成二维码的生成

```js
// 1 引入 qrcode.js

// 2 创建二维码实例
new QRCode(document.querySelector('#id'), 'url')

// 3 做一个 setInterval 轮询，获取后端是否知道用户已经登录
const isLogin = () => {
  axios.get("users/isLogin").then(res => {
    // 判断是否登录
    if (res.data.islogin) {
      document.querySelector("#qrcode").style.display= "none";
      setTimeout(() =>{
        alert("登陆成功!");
        // 跳转到其他页面之类的
      },100);
			
      // 清理定时器
      clearInterval(interval);
    }
  });
} 
const interval =  setInterval(isLogin,3000); // 轮询是否登录
```

