# 鉴权方式

 https://gitbook.cn/books/5d6c7ed186f522620c0bf2b3/index.html#cookie-1 

## Session-Cookie

> 这是把登录态放在服务器端存储的方式，前端存 sessionId（cookie）
>
> 现在有服务器集群（多台服务器），必须把信息放在持久化的地方以共享数据，如数据库DB和redis。

### 认证步骤

将登录信息保存在 session 中，说明是保存在服务器的。

在前端保存的是 cookie， 中有 session_id。访问服务器时携带这个 id。

服务器根据 id 知道用户是谁，然后拿出用户详细信息。

因为信息是写在服务器中的，所以也是安全可靠的。

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200108162423.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200108162423.png)</a>

- 登录请求，服务器创建 session，并产生唯一 `seesionId`，并在响应中设置 `cookie` ，属性名为 `jessionid`
- 客户端保存 `jessionid`，之后请求都会把这放入 `header` 请求头中
- 服务端每次从请求头中取出 sessionId 并进行用户身份认证



### 存在的问题

用户多起来后，用上 负载均衡 + redis 解决单点失败问题，但是一旦负责 session 存储的服务器出现什么问题，所有人都需要重新登录。



到这里位置，cookie-session 方式很难适应现代大体量的互联网应用，特别是移动应用，想办法让用户在浏览器自己管理 sessionId，所以就有了后来的 JWT。就是无状态的认证方式。



## Token 认证、JWT 认证

### 基本认识

> JWT（ jsonWebToken），令牌认证，原理就是 JSON
>
> 是目前流行的跨域身份验证解决方案
>
> 是在前端存储 token ，服务端校验 token



通过令牌来识别身份。令牌有时效。

优点是部署简单。各个服务器都可以单独地去鉴权。是前后端分离架构使用的方式。

缺点就是，只认令牌，不认人。如果被别人拿到，就可以进行访问。



#### JWT 和 Token 解决的问题

- JWT 解决的是 `cookie-session` 有前后端状态的认证问题，不是为了解决安全问题
- JWT 适合一次性验证如右键激活（因为不需要后端存储用户和 token 中 signaure 的关系，只需要验签），Token 适合普通的 API 请求（ 需要服务端存储 Token 和用户的关系 ）
- 拦截无效请求，降低服务器处理压力；
- 实现第三方 API 授权，无需每次都输入用户名密码鉴权；
- 身份校验，防止 CSRF 攻击。



#### 与 session, cookie 的区别

- ession 保存在服务端，用于客户端与服务端连接时，临时保存用户信息，当用户释放连接后，Session 将被释放；
- Cookie 保存在客户端，当客户端发起请求时，Cookie 会附带在 http header 中，提供给服务端辨识用户身份；
- Token 请求时提供，用于校验用户是否具备访问接口的权限



### Token 使用（服务器交互过程）

> 前端对于 token ，只能是判断有没有登录。之后就是请求时携带 token。

#### 用户访问某页面

- 客户端请求服务端
- 服务端判断是否携带令牌，没有则返回 401 状态

#### 重定向登录页

- 用户操作登录，客户端请求服务端验证登录
- 服务端登录成功，给客户端签发 token 令牌

#### 客户端缓存 token

- 前端一般存到 `sessionStorage`
- 之后每次请求服务器，都要携带 token
  - 一般是放于 header 请求头中
- 服务器验证 token，验证后返回数据
  - 是否存在
  - 是否正确
  - 是否过期



### Bearer Token 规范（前端部分）

> 在用 HTTP 访问 OAuth2 保护资源时如何使用令牌的一个规范

- 特点：令牌就是身份证明，无需证明令牌的所有权
- 具体规定和实现：在请求头中定义 `Authorization`

```js
// 固定字符串 Bearer（后有一个空格）
Authorization: Bearer <token>
```

用这种规范实际应用的代码

> 这样使用后，不管后台使用什么语言。只要按照这个规范都能正确解析出 token

```js
if (token) { 
  config.headers.Authorization = 'Bearer ' + token 
}
```



### JWT 规范（后端部分规范）

> 令牌具体定义方式。jwt.io 这个网站可以去看 Token 的解析。

#### 令牌的组成

我们看到的 `token` 字符串实际上是有 3 部分组成的。类似 ` adfafdsfsadf.dfdswerwe.sfsxsdf3 `

- 令牌的组成：头 + 载荷 + 签名
  - 这些虽然经过加密，但都是明文。所以不能用于传递敏感信息
  - 载荷信息是能被反解的，但是秘钥是无法拿出来的

```js
Header.Payload.Signature
```

- Header 含加密算法，令牌类型等信息

```js
{
  "alg": "HS256"， // 标记签名的算法
  "typ": "JWT"
}
```

- Payload 载荷: 虽然用了 Base64 转换，但是可以转换回来，所以不要放隐私数据。一般会包含用户信息， 签发时间和过期时间等信息

```js
{
  "sub": "1234567890"， //  payload 这里是存我们的方存放的用户信息
  "name": "John Doe"，
  "admin": false，
  exp: number // 过期时间
  ......
}
```

- Signature 签名：根据头、载荷及服务端秘钥加密得到的哈希串
  - 默认算法：Hmac Sha1 256
  - 会把这3个组成经过加密成一个 32 位的字符串。保证前端无法预测

```js
const signature = HMACSHA256（
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),+ "." +secret);
res.send({signature: signature})
```





#### 具体实现（koa实现）

```js
// 服务端 -/server/server.js
const Koa = require('koa')
const Router = require('koa-router')
// 生成和验证令牌的模块
const jwt = require('jsonwebtoken')
const jwtAuth = require('koa-jwt')
// 服务端秘钥, 这个秘钥的生成规则不同。可能是根据密码之类的东西二次加密
const secret = 'it's a secret' 
const app = new Koa()
const router = new Router()

// 登录接口
router.get('/api/login', async ctx => {
  const {username, passwd} = ctx.query
  
  if(username == 'wjy' && passwd = '123') {
    // 账号密码验证成功， 生成令牌（三部分构成）
    const token = jwt.sign(
    	{
        data:{name:'wjy'}, // 用户信息数据
        exp:Math.floor(Date.now() / 1000) + 60 * 60 // 过期时间
      },
      secret
    )
    ctx.body = {code:1,token}
  } else {
    // 登录失败
    ctx.status = 401
    ctx.body = {code:0, message:'用户名或密码错误'}
  }
})

// 受保护的路由
// 因为前端的东西不可信，所以都是要后端来做验证
router.get(
	'/api/userinfo',
  jwtAuth({secret}), // 验证 token 有效性
  // 返回用户信息
  async ctx => {
    ctx.body = {code:1, data:{name:'jerry', age:20}}
  }
)
app.use(router.routes())
app.listen(3000)
```



#### 解决跨域

> 因为上面的 koa 服务开启的是 3000 端口，前端假设是 8000 端口。那么就跨域了。
>
> 去 vue.config.js 中配置代理服务器
>
> 如果是 mock 服务器的话，也是在 `devServer`中写中间件。现在是“真”的服务器，所以用 proxy 就行了

```js
// vue.config.js
export default {
  // ...
  devServer: {
    // 代理配置。前端访问 "/api" 时就转发到 target 的地址上去
    proxy:{
      '/api':{
        target:'http://127.0.0.1:3000/',
				changeOrigin:true
      }
    }
  },
  // mock 服务。before(app) {...}
}
```



#### 安全性控制

- 缩短 Token 有效时间
- secret 定时替换
- 使用 HTTPS 加密协议
- 对标准字段 iss、sub、aud、nbf、exp 进行校验



## OAuth2.0 开放授权

> 跳到第三方页面进行登录、授权再回来
>
> 推荐文章，阮一峰老师的： <http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html>
>
> 根据描述， Oauth2 有4种授权方式
>
> ​	授权码模式（主流使用，最完整严格），简化模式，密码模式，客户端模式
>
> 客户端必须得到用户的授权，才能获得令牌

我们不再需要在每个平台上注册，通过 oauth 可以从原来的平台（github，qq, 163等）拿到一些自己的用户信息，授权给某个平台使用。



### 鉴权流程

要在第三方平台配置3个东西

- client_id 标识
- client_secret 密钥
- redirect_uri 登录授权后重定向的地址

用户操作登录后，后端拿到3个字段再拼接成地址，然后给第三方进行校验，第三方回调 `redirect_uri` 并跟着 `token`

- token
- clinet_secret

去第三方获取 `accessToken`，然后凭这个就可以在第三方调用 API 获取用户信息，放入 cookie



### 访问的流程

- 用户访问客户端，后者将前者导向认证服务器（微信服务器）
- 用户选择是否给予客户端授权
- 若用户给予授权，认证服务器将向客户端指定“重定向URL”。同时给予授权码
- 客户端收到授权码，附上“重定向URL”，并向认证服务器申请令牌。该步骤在后台服务器上完成，对用户不可见
- 认证服务器核对授权码和重定向URL。无误后，向客户端发送访问令牌和更新令牌。

> 对于微信公众号来说，获取用户信息，就是相当于普通网页的用户登录

- 生成认证URL， 跳转微信认证服务， 回调服务端获取code，调用微信接口accessToken和openid，调用服务端接口

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109095453.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109095453.png)</a>



## SS0 单点登录

> 在多个应用系统中，只要登录一次，就可以访问其他相互信任的应用系统

### 同一级域名下处理

假设父级域名是 `a.com` 那么下面所有的域名都可以拿到 cookie

- 1.a.com
- 2.a.com
- 3.a.com

这样就解决了三个系统之间传递信息了，把用户登录态放在 `a.com` 的 cookie 中就行（就是设置这个 cookie 的 `Domain` 属性）

再搭配一个共享 `session` 池的服务器，完成单点登录（大多数公司内部系统的通信方式）。

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109110632.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109110632.png)</a>

### 多系统登录

- 同域名：cookie 共享，单服务或多服务没有区别
- 不同子域名：子级之间不共享，但可以拿到父级 cookie，所以可以设置在父级域名上
- 完全不同域名：不同域名下无法共享 cookie



### 跨域 CORS

要后端接口支持 `CORS` 访问，且浏览器为了安全，不允许 `withCredentials` 配置 `*` 符号，所以要明确设置可访问的域名名单。

也可以通过访问的 `Referrer` 解析请求来源域名，作为可访问名单。但是这样不够安全。



### 单点登录 CAS

就是采用`通用session` 的方式登录多个完全不同域的系统。只需要在某个系统下验证后，就可以拿到 session，然后就可以访问所有系统





## LDAP 认证

>  轻量目录访问协议，这个协议是基于 TCP/IP 的，意思是它的数据存储是基于目录文件的。 

就是很多的系统，每次都要登录，但是登录的账号密码都是一样的。

跟 `sso`  的区别在于 sso 是到专门的一个页面去登录，`LDAP` 需要每次都进行登录。



## 扫码登录

> 二维码的本质就是一个 URL

生成二维码的同时会提供一个 `uuid` 到 URL 上，比如

```js
http://www.a.com?uuid=xxxxx
```

当手机扫码后，会带上 `uuid` 和 `用户信息`。后端解析后就知道用户登录进来的，二维码页面跳转到某个页面。



我们利用 `qrcode.js` 这个库完成二维码的生成

```js
// 1 引入 qrcode.js

// 2 创建二维码实例
new QRCode(document.querySelector('#id'), 'url')

// 3 做一个 setInterval 轮询，获取后端是否知道用户已经登录
const isLogin = () => {
  axios.get("users/isLogin").then(res => {
    // 判断是否登录
    if (res.data.islogin) {
      document.querySelector("#qrcode").style.display= "none";
      setTimeout(() =>{
        alert("登陆成功!");
        // 跳转到其他页面之类的
      },100);
			
      // 清理定时器
      clearInterval(interval);
    }
  });
} 
const interval =  setInterval(isLogin,3000); // 轮询是否登录
```

