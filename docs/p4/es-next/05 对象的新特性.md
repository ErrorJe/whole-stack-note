# 对象的新特性


## 新特性
### 基本语法

- 简略赋值
- 属性名动态表达式
- 方法名 name
- 可枚举属性遍历
- 对象属性取值
```javascript
// 1 简略赋值
let birth = '2000/01/01';
const Person = {
  birth //等同于birth: birth
};

// 对于函数也是一样
const obj = {
  // ES5 写法
  fn: function(){}
  
  // ES6 写法
  fn(){
    // 通过 ES6 简写的方法，有 this.name 属性，这里就是 'fn' 字符串
  }
}

// 2 属性名表达式（可计算属性名）
let propKey = 'foo';
let obj = {
  [propKey]: true, // 允许 [] 内写变量，相当于是动态赋值
  ['a' + 'bc']: 123 // ES5 的拼接写法
};

// 3 方法的名字
obj.fn.name

// 4 对象属性取值
obj.xxx // 属性key只包含字母和下划线
obj.['xxx'] // 属性key，可以取所有情况
obj.[2] // 假设该属性key，就是数字2
```



### 属性的可枚举性和遍历

```javascript
// 1 属性遍历（可枚举）
for (attr in obj) {}
```


#### 查看对象属性的描述对象

`Object.getOwnPropertyDescriptor` 获取到一个描述对象
```javascript
//  {
//    value: 123,
//    writable: true,
//    enumerable: true, 可枚举性
//    configurable: true
//  }
```

现在有4个操作会直接忽略不可枚举的属性：前三个是 ES5 的，最后一个是 ES6 的

- `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
- `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
- `JSON.stringify()`：只串行化对象自身的可枚举的属性。
- `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。



### 增强原型对象

#### 对象继承原型 proto

```javascript
let obj1 = {age:1}
let obj2 = {}

// 继承 obj1 作为原型，方法1
Object.setPrototypeOf(obj2, obj1)

// 方法2.与上面写法作用是一样的。
obj2.__proto__ = obj1

console.log(obj2.age); // 1
```



#### 原型方法

```js
Object.getPrototypeOf(obj) // 返回任意对象的原型
Object.setPrototypeOf(obj, fn) // 设置任意对象的原型
```



#### 调用父级（原型）属性或方法 super

`super` 就是 `Object.getPrototypeOf(this)` 的值

```javascript
let obj1 = {age:1, getFood() {
  return '面包'
}}
let obj3 = {
  // 继承 obj1
  __proto__: obj1,
  // 覆盖 从原型中继承的同名方法
  getFood(){
    // super 调用父级(原型)方法
    return '水果'+super.getFood()
  }
}
console.log(obj3.getFood()); // 水果面包
```



### 对象的扩展运算符

#### 解构赋值
```javascript
// 1 读取还未被读取的属性，也就是剩余部分。所以要放最后的位置
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }
// 注意对 Null 和 Undefined 的解构，因为无法转为对象所以报错
let { ...z } = null

// 2 解构引用类型是浅拷贝，进行修改会影响原先的对象
// 同时不会把原型对象的属性给拷贝过来
let o2 = { b: 2 };
let { ...o3 } = o2;
```



#### 扩展运算

```javascript
// 1 数组是特殊的对象，所以也可以用
let foo = { ...['a', 'b', 'c'] };
foo // {0: "a", 1: "b", 2: "c"}

// 2 自动转换不是对象的值为对象
// 等同于 {...Object(1)},会自动转为数值的包装对象Number{1}
// 由于该对象没有自身属性，所以返回一个空对象。
{...1} // {}, 

// 3 等于使用了 Object.assign
// 下面两句完全一样
let aClone = { ...a };
let aClone = Object.assign({}, a);

// 4 合并对象，下面两句意思一样
// 要注意，后面合并进来的属性会覆盖前面同名属性
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });

// 5 扩展符号后可以是表达式
const obj = {
  ...(x > 1 ? {a: 1} : {}),
  b: 2,
};
```



### 链判断运算符 ?.

> 最新版 Chrome 79 或者 opera 65 以上才被支持使用

使用场景就是我们如果要取到某个对象的属性值，首先这个对象得存在，于是我们会这样写

```javascript
obj && obj.attr && obj.attrrr // 深层的话就很麻烦
```

现在新的运算符 `?.`  一步到位，如果前面那个对象不存在直接返回 `undefined` ，如果存在就继续向下运算
```javascript
const firstName = message?.body?.user?.firstName || 'default';

// 主要有三种用法
obj?.prop // 对象属性
obj?.[expr] // 同上
func?.(...args) // 函数或对象方法的调用
arr?.[index] // 索引
```

当然也会有一些问题需要注意

```javascript
// 1 短路机制：若 a 是 undefined/null 就停止运算，也就是左侧一旦为真，右侧不再计算
a?.[++x] // 与下相等
a == null ? undefined : a[++x]

// 2 只对圆括号内部产生影响
(a?.b).c // 等价于， .c 总是执行。所以一般来说使用?.运算符的场合，不应该使用圆括号
(a == null ? undefined : a.b).c

// 3 报错的情况，一些写法是被禁止的，会报错
new a?.b() // 构造函数
super?.foo // 左侧是 super
a?.`{b}` // 右侧有模板字符串
a?.b = c // 用于赋值运算
// 被解析成foo ? .3 : 0
// 如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符
// 那个小数点会归属于后面的十进制数字，形成一个小数
foo?.3:0 
```



### null 判断运算符 ??

它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。
```javascript
const headerText = response.settings.headerText ?? 'Hello, world!';
```



## 常用 API

```javascript
// 1 判断相等
== // 会转换类型
=== // 存在的问题。NaN ！== NaN， +0 === -0
Object.is(NaN, NaN) // true.解决以上问题

// 2 对象合并:浅拷贝
const target = { a: 1 };
Object.assign(target, { b: 2 }); {a:1, b:2}

// 应用1：给对象添加属性
constructor(x, y) {
  Object.assign(this, {x, y});
}

// 应用2：给对象添加方法，如给原型对象添加几个方法
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 应用3 克隆对象
function clone(origin) {
  return Object.assign({}, origin);
}
// 应用4 合并多个对象
const merge =
  (...sources) => Object.assign({}, ...sources);

// 应用5 属性默认值
const Defualt = {
  log: 0
}
Object.assign({}, DEFAULTS)


// 3 取代 __proto__ 的读写方法
bject.getPrototypeOf(_thisObj)
setPrototypeOf(this, proto);

// 4 对象取值
Object.keys // 键名数字
Object.values // 键值数组
Object.entries() // 键值对数组 [ ["foo", "bar"], ["baz", 42] ]
Object.fromEntries() // entries 的逆操作
```



## 深浅拷贝

### 浅拷贝

```javascript
// es 5 的方式
let obj1 = {}
let obj2 = {}

for(let key in obj){
	if(!obj.hasOwnProperty(key)) break; // 遇到原型就返回了，原型 key 都是放在很后面
  obj2[key] = obj[key]
}

// es6 方式
obj2 = {...obj1}
```



### 深拷贝

```javascript
let obj1 = {
    name: 'wjy',
    home: {
        city: 'ningbo'
    }
}
// 浅拷贝 - 只是复制了对象引用，本质上指向同一片内存地址
let obj2 = {}
obj2 = Object.assign(obj2, obj1)
obj2.home.city = 'xiangshan' // 尝试更改值
console.log(obj1.home.city, obj2.home.city) // 同时被修改

// 深拷贝 - 复制值到自己的内存中，创建新的引用
let obj3 = {}
// 只能处理数组和对象。一般场景使用。对循环引用的情况不支持
obj3 = JSON.parse(JSON.stringify(obj1)) 
obj3.home.city = 'beijing'
console.log(obj3.home.city, obj2.home.city) // 值不一样了

// 深拷贝 - 使用递归赋值(这里只考虑对象，数组和其他类型数据需要另外判断)
function clone(obj) { // origin 要被拷贝的对象
  // 过滤一些数据类型
  if (obj === null) return null
  if (typeof obj !== 'object') return obj
  if (obj instanceof RegExp) {
  	// 返回一个新的正则实例
    return new RegExp(obj)
  }
  if (obj instanceof Date) {
  	return new Date(obj)
  }
  
  // 不直接创建空对象目的：克隆的结果和之前保持相同的所属类
  let newObj = new obj.constructor
  for (let key in obj) {
   if (obj.hasOwnProperty(key)) { // 只克隆对象自己的属性
   	newObj[key] = deepClone(obj[key])
   }
  }
  return newObj
}
let obj4 = clone(obj1)
obj4.home.city = 'shanghai'
console.log(obj4.home.city, obj2.home.city) // 值也不一样了
```

也有简单的深拷贝
> 问题就是在函数、正则、日期字符串化时跟预期不一样。函数和正则会转为空对象，日期会变成标准日期格式

```javascript
let str = JSON.stringify(obj) // 转为字符串
JSON.parse(str) // 转为JS对象
```

