# 数组的新特性


## 数组扩展运算符

```javascript
let args = [2, 3, 4]
console.log(1, ...args, 5) // 1 2 3 4 5

f(...args); // 函数参数的展开传入
[0, 1, 2].push(...args); // 数组尾部加入
args = [...args, 1, 2] // 数组合并
```



## 常用 API

```javascript
// 0 基本操作
arr.push(1) // 尾部增加
arr.unshift(2) // 顶部增加
arr.splice(2, 0, 3) // 从索引2开始增加“3”这个元素,若给第二个参数值，则表示从索引2开始删除 n 个元素，然后替换一个3进去
'1,2,3,4,5'.split(',') // 以，为分割标志，转为数组[ 1, 2, 3, 4, 5 ]

// 1 Array.from 将类数组转换为数组, 常与map和set一起用
Array.from(new Set(['a', 'b']) // ['a', 'b']，
// 第二个参数接受函数，类似于 map 方法，对每个元素进行处理
  function typesOf () {
  return Array.from(arguments, value => typeof value)
}
typesOf(null, [], NaN) // ['object', 'object', 'number']   

// 2 Array.of 将一组值转为数组。基本上用于代替 Array 和 new Array
Array.of(3, 11, 8) // [3,11,8]

new Array(3).fill(7) // 3 用给定值填充数组 [7, 7, 7]

arr.indexOf(x) // 4 返回元素 x 在 arr 首次出现的索引
arr.includes(x) arr // 5 是否包含元素 X
arr.find(callback) // 6 返回第一个通过 callback 回调函数过滤的元素
arr.findIndex(callback) // 7 找到 x 在数组中的索引
arr.filter(callback) // 8 返回通过 callback 回调函数过滤的所有元素的新数组， 每个元素返回 boolean 以确定是否满足条件

// 9 返回Boolean， 验证 arr 中是否存在元素能够通过callback过滤测试。当空数组时，永远返回 false
arr.some(callback) 
 [1,2,3].some(item => !2) {
   console.log('至少有一个元素不为 2')
 }
// every() 是相应的方法

// 10 与 for...of 配合 
for (let index of ['a', 'b'].keys()) {} // 数组索引
for (let index of ['a', 'b'].values()) {} // 数组元素
for (let index of ['a', 'b'].entries()) {} // 类似[0, 'a']

// 与 for...in 的区别
for (let index in ['a', 'b']){} // Index 是索引, 0, 1
for (let index of ['a', 'b']){} // index 是值, a, b

// 11 拉平数组
[1, 2, [3, [4, 5]]].flat() // [1, 2, 3, [4, 5]]
[1, 2, [3, [4, 5]]].flat(2) // [1, 2, 3, 4, 5] 搞定两层
[1, [2, [3]]].flat(Infinity) // 无论怎样都转为一层数组

// 12 处理元素后再拉平数组
[2, 3, 4].flatMap((x) => [x, x * 2]) // [2, 4, 3, 6, 4, 8]

// 13 调整元素位置，会覆盖原有的元素， 会改变原数组
// 参数：目标位置，开始的索引（默认为0），结束的索引（默认为数组长度，负数尾巴开始）
[1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]
```



## Reduce 应用

```javascript
// API 说明, 
arr.reduce((sum, x, idx, arr)=>{...}, firstValue)

  一般接受两个参数： callbackFn(处理回调) + initValue(初始值)
  1 在 callback 中，还有4个入参:
    sum 累积返回值, x当前值, idx当前索引[可选], arr原数组[可选]
  2 firstValue 作为累积第一个数的起始值[可选,若没有则用数组的第一个元素作为起始值]
```



### 应用1：map+filter 功能

```javascript
// 使用原生 map，filter 方法需要遍历2次数组。
const numbers = [10, 20, 30, 40]
let finalList = []
const doubleOver50 = numbers.reduce((filter, num) => {
  // 处理原数组元素都*2，筛选最后大于50的元素
  num = num*2
  if (num > 50) {
    finalList.push(num)
  }
  return finalList
}, [])
doubleOver50 // [60, 80]。reduce 不是方法，是处理数据的。所以直接使用
```



### 应用2：统计数组中相同项的个数

```javascript
var cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];

var carsObj = cars.reduce(function (obj, name) {
  obj[name] = obj[name] ? ++obj[name] : 1;
  return obj;
}, {});

carsObj; // => { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 }
```



## 常用 API 的原理

常见的有：
> 	map, reduce, reduceRight, filter, forEach
> 	some, find, findIndex, every
> 	from, of



### Array.prototype.filter 原理

> 返回通过 callback 回调函数过滤的所有元素的新数组


```javascript
let arr1 = [1, 2, 3, 4, 5]
let arr2 = arr1.filter(function(i) {
  return i >= 3
})
console.log(arr2);


// 原理
Array.prototype.filter = function(fn) {
  let newArr = []
  // 原型扩展中，this 就是实例
  for (let i=0; i<this.length; i++) {
    let flag = fn(this[i])
    flag && newArr.push(this[i]) // 若 flag 为 true， 则保存
  }
  return newArr
}
```



### Array.prototype.reduce 原理

```javascript
// reducer运算器， initialval结果值
Array.prototype.reduce = function(reducer, initialval) {
  for (let i=0; i<this.length; i++) {  
    // rudeceRight => (i=this.length-1; i>=0; i--)
    initialval = reducer(initialVal, this[i], i, this)
  }
  return initialval
}
```



### Array.prototype.fill 方法

```javascript
let arr = Array(3)
console.log(arr); // 3个占位符的空数组
arr.fill(2) // 用2填满数组
console.log(arr); // [2, 2, 2]
```



### Array.prototype.find（findIndex）原理

> 返回第一个通过 callback 回调函数过滤的元素（索引）


```javascript
let arr = [1, 2, 3]
let result1 = arr.find(function (item) {
  return item == 2
})
let result2 = arr.findIndex(function (item) {
  return item == 2
})
console.log(result1); // 元素 2 
console.log(result2); // 索引 1

// find 原理
Array.prototype.find = function (fn) {
  for (let i = 0; i < this.length; i++) {
    let flag = fn(this[i])
    if (flag) {
      return this[i]
    }
  }
}

// findIndex 原理
Array.prototype.findIndex = function (fn) {
  for (let i = 0; i < this.length; i++) {
    let flag = fn(this[i])
    if (flag) {
      return i
    }
  }
}
```



### Array.prototype.some 原理

> 有一个符合就返回 true， 全部不符合返回 false。当空数组时，永远返回 false


```javascript
// 原理
Array.prototype.some = function(fn) {
  for (let i = 0; i < this.length; i++) {
    let flag = fn(this[i])
    if(flag) return flag
  }
  return false
}
```



### Array.prototype.every 原理

> 要求每个元素都符合条件, 一个不满足就返回false


```javascript
Array.prototype.every = function(fn) {
  let flag = true
  for (let i = 0; i < this.length; i++) {
    let flag = fn(this[i])
    if(!flag) flag = false
  }
  return true
}
```



### Array.prototype.from 方法

> 将一个类数组，转换为数组
> 前两种方式都是老旧的方式，推荐第三种


```javascript
// 方法1
function print() {
  // arguments 是类数组, { '0': 1, '1': 2, '2': 3 }
  // 分割后 [1, 2, 3]
  let arr = Array.prototype.slice.call(arguments)
  arr.forEach(item => {
    console.log(item);
  });
}

// 方法2
function print2() {
  Array.prototype.forEach.call(arguments, function(item) {
    console.log(item);
  })
}

// 方法3
function print3() {
  Array.from(arguments).forEach(function(item) {
    console.log(item);
  })
}
print3(1, 2, 3)
```



### Array.prototype.of 方法

> 创建一个可变数量的新数组实例，


```javascript
let arr = Array(3)
console.log(arr);  // 空数组
let arr2 = Array.of(1, 2, 3)
console.log(arr2); // [1, 2, 3]
```

---






