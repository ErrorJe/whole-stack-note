# 函数的新特性

## 函数参数默认值和解构


### ES5 和 ES6 不同的处理方式

```javascript
// ES5 的处理方式 1.必传参没传报错 2.其他参数没传给个默认值
function ajax(url, method, dataType) {
  if (typeof url == 'undefined') throw Error('url不能为空')
  method = method?method:'GET'
  dataType = dataType || 'json'
}

// ES6 默认参数
function ajax(url=new Error('url不能为空'), method="GET", dataType="json") {
  console.log(url, method, dataType)
}
ajax('/user') // '/user', 'GET', 'json'
```



### 函数默认值限制

```javascript
// 与解构一起使用
function foo({x, y = 5} = {}) {
  console.log(x, y);
}

// 应用于默认必传参，不然报错
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
```



### 函数默认值需要注意的问题

- 函数参数默认值，传 undefined 会认为是没有传，传 null，那么这个参数值就是 null
- 一旦定义了默认参数，则函数的 `length` 属性失真
  - length 表示该函数预期传入的参数个数，但是设定默认值就不输入预期参数了，不计入参数个数





## rest 剩余操作符和函数名



### ES5 的 arguments

在之前会用  `arguments` 来指代函数的剩余传参，但是它是一个类数组，所以为了用数组的方法，要用 `slice` 转换一下
```javascript
// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) => numbers.sort();
```



###  ...rest 基本用法

- ...rest 只能是最后一个参数
- 函数的 length 属性计数同样不包括 ...rest 的参数
```javascript
// ...params
function sum(prefix, ...rest) {
  // 1 循环求和
  ley result = 0
  rest.forEach(function(item) {
    result += item
  })
  
  // 2 reduce 汇总计算，把一个数组中的一堆值算成一个值
  // val 上一次运算结果(可以赋默认值), item 每个元素, index 索引， origin 源数组
  // 第一次 val 的初始值，下面设置了 0。若没有初始值则用第一个元素
  rest.reduce(function(val, item, index, origin) {
    let sum =  val + item // 求和
    if (index == origin.length-1) {
      return sum/origin.length // 平均值
    } else {
      return sum
    }
  }, 0)
  
  // reduceRight(fn(), x), 是从末尾元素开始运算。要注意索引是从length-1开始的，结束是Index=0
  
  return prefix + (result)
}
console.log(sum('$', 1, 2, 3, 4))
```



### 函数名 name

```javascript
// 基本用法，这在 ES5 时是不支持的
var f = function () {};
f.name // 'f'

// 构造函数返回的函数实例
(new Function).name // "anonymous"

// bind 过的函数，前置 bound
function foo() {};
foo.bind({}).name // "bound foo"
```



## 展开运算符（...obj）

```javascript
// 数组拼接
let arr1 = [1, 2, 3]
let arr2 = [4, 5, 6]
// ES5 拼接
let arr3 = [].concat(arr5, arr6)
// ES6 拼接
let arr4 = [...arr1, ...arr2] // 解构、展开

// 应用场景 - 版本是 es7 
let arr = [1, 2, 3]
let max1 = Math.max(1, 2, 3) // 参数列表形式传入
let max2 = Math.max(arr)  // 不能传入引用对象
let max3 = Math.max.apply(Math, arr) // 使用原本不能用的方法
let max4 = Math.max(...arr) // 解构语法糖
console.log(max1, max2, max3, max4) // 3 NaN 3 3


// 应用场景2 - 解决对象赋值
let obj1 = {name:'wjy'}
let obj2 = {age:9}
let obj3 = {}

// ES5 用法
for(let key in obj1){
    obj3[key] = obj1[key] 
}
for(let key in obj2){
    obj3[key] = obj2[key] 
}
console.log('ES5赋值方式-obj3： ', obj3)
// ES6 用法
Object.assign(obj3, obj1, obj2)  // param1 = 目标对象, 后面参数都是源对象
console.log('ES6赋值方式-obj3： ', obj3)
// ES7 用法
obj3 = {...obj1, ...obj2}
console.log('ES7赋值方式-obj3： ', obj3)
```



## 箭头函数



### 基本特征

1. 不能用在构造函数的原型方法上，因为要用于指向实例
1. 使用动态回调，如绑定事件。使用箭头函数，this就找不到事件
1. 不能获取 arguments
```javascript
var f = v => v; // 箭头函数在定义时，指定了 this， 且后面不变

// 等同于
var f = function (v) {
  return v;
};
```

箭头函数常见的应用就是“箭头后面”怎么写的问题
```javascript
// 1 隐式返回值（关键字返回）
var f = v => v+1

// 2 多行语句返回 ()， 如返回一个对象文本
f = v => (
	Math.PI * v
)

// 3 正常函数体
f = v => {
  return v
}
```



### 箭头函数的 this 指向

> 箭头函数没有自己的this， 它的this是在定义的时候用的上层的this

```javascript
let obj = {
  name: 'wjy',
  fn: function(x) {
    var that = this
    console.log('对象真实this指向: ', this)
    setTimeout(x => {
      console.log('箭头函数this指向: ', this)
      return x*2
    }, 1000)
  }
}
obj.fn(1) // this 指向了 obj 实例自己
```



### 箭头函数不适用的情况

- 使用对象方法时
  - JS 中的作用域就是全局或者函数体， 外层指的就是外层的函数体或者全局

```javascript
let obj = {
  name: "wjy",
  // 箭头函数的 this 在声明时定死，指向外层 this。这里指向 obj 之外的 this 作用域
  getName: () => {
    console.log(this.name); // 指向了 window
  }
};
obj.getName(); // undefined
```

- 箭头函数，不能用在构造函数的原型方法上
  - 构造函数的原型方法要用 this 来获得实例，所以不能用 => 去限死
- 需要获得 `arguments` 时，也不能用， => 没有 arguments 这个伪数组
- 使用动态回调时，比如按钮事件的绑定
  - 因为`button`的监听函数是一个箭头函数，导致里面的`this`就是全局对象。如果改成普通函数，`this`就会动态指向被点击的按钮对象
- 不能作为构造函数，就是不能用 new 命令，不然报错
  - 因为箭头函数没有自己的 this，就是没有原型和原型链

```javascript
const btn = document.getElementById('btn')

btn.addEventListener('click', () => {
    console.log(this === window) // this 绑定的不是事件对象，而是 window
});
```



## 尾调用优化

> 函数的最后一步操作是调用某个函数，且不能做其他操作如赋值，函数再运算等。
> 尾调用优化，因为最后一步是调用了函数，所以最后的执行栈，就保留了最后一个函数的调用帧，外部函数的调用帧会被无视（要求是最后调用的函数内部，不能再使用外部函数的变量）。所以节省了内存空间


```javascript
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// => 等同于
function f() {
  return g(3);
}
f();

// => 等同于
g(3);
```



