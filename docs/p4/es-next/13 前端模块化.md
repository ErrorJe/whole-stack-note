# 前端模块化

## 模块化概念

### 基本概念

将复杂代码，针对其功能原子性进行拆分成几个互相独立的文件。内部完成逻辑，对外暴露一些数据或调用方法，与外部完成整合。

模块化和工程化结合，又有很多新的概念。

在 nodejs 中，一个 JS 文件都是模块



### 模块化原则

- 复用性
- 组合性
- 中心化
- 独立性



### 模块化意义

- 避免命名冲突。每个文件是模块，其中变量函数都是其私有变量。不会污染或被全局变量污染
- 更清晰的依赖关系。要显式声明对模块的引用，文件直接依赖关系明确。
- 高可维护性。模块功能职责单一，需要升级改动部分功能只需要针对具体模块进行改动。
- 高可复用性。
- 降低复杂度。解决代码的高内聚低耦合



## 模块化演进和未来趋势

主要经历了三个阶段

- 模拟的“假”模块化时代
- 规范标准时代
- ES 原生时代

每一次技术更迭，都在上一个时代技术的基础上演变。

> 前端模块化各个标准的区别。https://juejin.im/post/5aaa37c8f265da23945f365c



### 早期假模块化时代

#### 函数模式

借助 JS 函数作用域来模拟实现“假”的模块化。

缺点也很明显，不能保证不污染全局变量，没有解决问题。

```js
function fn() {
    // 早期的 JS 作用域只有全局和函数作用域
}
```



#### 对象模式

利用对象，实现命名空间（对象属性的键值对）的概念。

```js
const module1 = {
    foo: 'bar',
    f11: function f11 () { //... },
    f12: function f12 () { //... },
}
module1.f11() // 模拟命名空间调用方法
module1.foo = 'xxx' // 同样，任何人可以改变值，不安全
```



#### IIFE 模式

利用闭包（IIFE，立即执行函数）。构造一个私有作用域，再用闭包把数据和接口输出。

```js
// 1 IIFE 模块
const module = (function(){
    var foo = 'bar'
    var fn1 = function (){
        // ...
    }
    var fn2 = function fn2(){
        // ...
    }
    return {
        fn1: fn1,
        fn2: fn2
    }
})()

// 2 调用
module.fn1()
module.foo // undefined， 因为变量没有被 return 所以说是一个私有的
```



#### IIFE 进阶版：现代模块化基石

进阶版本，就是将 IIFE 挂载到 window 上。这样能够完全做到私有化。

符合一个模块的所有初级条件。

```js
// 1 传入 window 对象
(function(window) {
    var data = 'xxxx'

    function foo() {
        console.log(`foo executing, data is ${data}`)
    }
    function bar() {
        data = 'modified data'
        console.log(`bar executing, data is now ${data} `)
    }
    window.module1 = { foo, bar } // 2 挂载到 window 上
})(window)

// 2 如果 module1 没有提供暴露数据或者修改的方法，则无法去读写
module1.foo() // foo executing, data is xxxx
```



如果要依赖其他模块，则在定义的时候，传入2个参数

```js
(function(window, $) {
    var data = 'xxxx'

    function JQ() {
        console.log($)
    }
    
    window.module1 = { JQ } 
})(window, jQuery)
```



###  CommonJS 时代

> CommonJS 是 NodeJS 带来的。在 Node 中，每一个文件就是一个模块，具有单独的作用域。
>
> 浅谈前端模块化
>
> https://juejin.im/post/5c1619b8e51d4530e8357c86



#### CommonJS 中几个重要规范

- 文件=模块。文件内代码都运行在独立的作用域，不会污染全局空间

- 模块可复用加载。首次加载被“缓存”，后面加载都读取缓存。

- 加载某个模块，就是引入该模块的 “module.exports” 属性

- - “module.exports” 属性输出的是一个拷贝后的值，输出后就算影响模块，也不会影响这个输出

- 模块加载顺序按照代码引入次序（同步）

- - 所以适用于服务端和桌面端

- 注意 “module.exports”  和 “exports” 是不一样的



#### 模拟实现 CommonJS

在浏览器中实现，就是实现 `module.exports` 和` require` 方法

```js
// 根据 require 的文件路径，加载文件内容并执行，同时将对外接口进行缓存。
let module = {}
module.exports = {}

// 借助立即执行函数，将 module 和 module.exports 对象进行赋值
(function(module, exports) {
    // ...  
}(module, module.exports))
```



#### 使用场景

CommonJS 规范模块的加载采用同步加载方式，适用于 Node.js 端。

因为服务端文件是在本地的，加载很快

浏览器环境，资源都是从服务器下载后才能使用。同步会阻塞 JS 运行。



### AMD 时代

因为 `NodeJS` 运行在服务器上，所有文件都是在本地硬盘了，所以是同步加载的。浏览器环境一般都是异步去加载其他服务器中的模块。同步就不合适了。

所以在浏览器的异步加载环境，使用 `AMD` 异步并行加载依赖模块，且可以有效管理文件依赖关系和加载顺序。



#### RequireJS 库

> https://github.com/requirejs/requirejs

AMD 规范，规定了如何定义模块、如何对外输出、如何引入依赖。所以 `require.js`  库就是实现这些规范的典型库。通过 `define` 方法定义模块，通过 `require` 方法实现模块加载。



#### 全局注入 require.js 的 2 个方法

这2个方法也是 `require.js` 在全局注入的函数。

下面是源码部分，理解思路，不用学实现。

利用 IIFE 将全局对象 `this` 和 `setTimeout` 传入函数体内

```js
var require, define; //  1 全局定义方法
// 2 将全局对象（this）和 setTimeout 传入函数体内
(function (global, setTimeout) {
    // ...
}(this, (typeof setTimeout === 'undefined' ? undefined : setTimeout)));
```



#### define 方法

`define` 方法，主要是将依赖加入依赖队列

```js
define = function (name, deps, callback) {
  // ...
  if (context) {
    context.defQueue.push([name, deps, callback]);
    context.defQueueMap[name] = true;
  } else {
    globalDefQueue.push([name, deps, callback]);
  }
}
```



#### require 方法

`require` 方法是完成 `script` 标签的创建，再去请求相应的模块，对模块进行加载和执行

```js
req.load = function (context, moduleName, url) {
  var config = (context && context.config) || {},
      node;
  if (isBrowser) {
    //create a async script element
    node = req.createNode(config, moduleName, url);

    //add Events [onreadystatechange,load,error]
    .....

    //set url for loading
    node.src = url;

    //insert script element to head and start load
    currentlyAddingScript = node;
    if (baseElement) {
      head.insertBefore(node, baseElement);
    } else {
      head.appendChild(node);
    }
      currentlyAddingScript = null;

      return node;
    } else if (isWebWorker) {
      //.........
    }
  };

  req.createNode = function (config, moduleName, url) {
    var node = config.xhtml ?
        document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
    document.createElement('script');
    node.type = config.scriptType || 'text/javascript';
    node.charset = 'utf-8';
    node.async = true;
    return node;
  };
```



#### remove 方法

最后创建的 script 标签，在模块加入内容后，就没有用了。删除

```js
function removeScript(name) {
  if (isBrowser) {
    each(scripts(), function (scriptNode) {
      if (scriptNode.getAttribute('data-requiremodule') === name &&
          scriptNode.getAttribute('data-requirecontext') === context.contextName) {
        scriptNode.parentNode.removeChild(scriptNode);
        return true;
      }
    });
  }
}
```



#### 入口配置文件 require.config

依赖数组中指出依赖的模块。指定的模块名称，可以去配置文件中去定义路径

`require.config` 用于配置这些模块信息。

```js
// ./main.js 入口文件
require.config({
  baseUrl: '/',
  paths: {
    setBodyColor: './setBodyColor',
    jquery: './jquery-3.4.0'
  }
})

// 使用在 main.js 中配置的模块名，而不用写路径
require(['calc','setBodyColor'], function (calc, setBodyColor) {
  const r = 10;
  const c = '#000';
  console.log(calc.area(r));
  console.log(calc.circumference(r));
  setBodyColor(c);
});
```



### CMD 时代

结合了 `CommonJS` 和 `AMD` 规范的特点。类似 `requireJS` ，`CMD` 规范的实现为 `sea.js`。

两者基本是一样的。

#### CMD 和 AMD 的区别

- AMD 要异步加载模块。CMD 在 require 依赖时用同步的形式（require），也可以用异步方法（require.async）
- AMD 遵循前置原则（依赖提前在依赖数组中声明），CMD 遵循依赖就近原则（用依赖前 require 进来就好了）。



#### CMD 模块定义

##### 无依赖模块

传入一个回调，用于定义模块的代码逻辑

用 `module.exports` 或 `exports` 对象将接口对外暴露出去

```js
// ./calc.js
define(function (require, exports, module) {
  const { PI } = Math;
  const area = (r) => PI * r ** 2;
  const circumference = (r) => 2 * PI * r;
  module.exports = {area, circumference}
})
```



##### 定义有依赖的模块

使用 `require()` 方法来加载其他的依赖模块。

`CMD` 是就近依赖，延迟执行。用到的时候才用 `require` 方法，且在实际调用时被执行。

```js
// ./setBodyColor.js
define(function (require, exports, module) {
  const $ = require('./jquery');
  const setBodyColor = color => {
    $('body').css('background-color', color)
  }
  module.exports = setBodyColor
})
```



#### 模块的使用

```js
<script type="text/javascript" src="./sea.js"></script>
<script type="text/javascript">
  // 加载入口模块
  seajs.use('./main')
</script>

// ./main.js
define(function (require) {
  const setBodyColor = require('setBodyColor');
  const c = '#000';
  setBodyColor(c)
})
```



### UMD 时代

> umd 统一模块，支持所有模块

相当于一个集合，允许在环境中同时使用 `AMD` 和`CommonJS` 规范。

核心设计：利用` IIFE` 根据环境来判断需要的参数类别

```js
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD 规范
        define(['b'], factory);
    } else if (typeof module === 'object' && module.exports) {
        // 类 Node 环境，并不支持完全严格的 CommonJS 规范
        // 但是属于 CommonJS-like 环境，支持 module.exports 用法
        module.exports = factory(require('b'));
    } else {
        // 浏览器环境
        root.returnExports = factory(root.b);
    }
}(this, function (b) {
    // 返回值作为 export 内容
    return {};
}));
```



## ES6 原生模块化（ESM）

### 基础知识

`ES6 module` 自动采用严格模式，无论是否在文件顶部增加 `use strict`。严格模式带来一系列的代码限制

- 变量必须声明后再使用
- 不能删除变量，只能删除属性如 `delete obj[prop]`
- `arguments` 不会自动反映函数参数的变化
- 禁止 `this` 指向全局对象。顶层 `this` 是 `Undefined`,所以不要在全局环境使用 `this`
- 增加 `protected`, `static`, `interface` 等保留字



### ES Next 的版本

- stage - 0 计划（功能最多）
- stage - 1 减少
- stage - 2 最少 （babel/preset-env 来整合这些草案）
- stage - 3 定版



#### ESM 与 CommonJS 的区别

##### ESM 的设计思想（静态化）

ESM 的设计思想就是尽量保证静态化，这样能够在“编译时”有几个好处

- 确定模块之间的依赖关系
- 每个模块的输入输出都是确定的



##### 其他规范的设计区别

CommonJS 和 AMD 模块无法在前置时确定模块之间的关系，也无法保证 IO 关系，而只能在“运行时”去确定。实际上，CMJ 导出的就是对象。

- 且 CommonJS 输出的是一个值的——拷贝，而 ES 模块输出的是值的——引用

```js
// data.js 用 ESM 规范导出1个变量和方法
export let data = 'data'
export function modifyData() {
    data = 'modified data'
}

// index.js 调用方法，可以看到 data.js 中的值发生改变，说明是导出的是引用
import { data, modifyData } from './data'
console.log(data) // data
modifyData() // 调用模块方法，改变 data 值
console.log(data) // modified data
```



一样的操作，看 CMJ 规范的结果

```js
// data.js 
var data = 'data'
function modifyData() {
    data = 'modified data'
}
// 用 CMJ 规范导出1个变量和方法
module.exports = {
    data: data,
    modifyData: modifyData
}

// index.js 引入两个导出值
var data = require('./data').data
var modifyData = require('./data').modifyData
console.log(data) // data
modifyData() // 调用方法后，发现，原模块中的变量值没发生改变。说明是值的新拷贝
console.log(data) // data
```



#### ESM 设计成静态化的原因

提高运行性能，减少代码体积。通过分析导入的依赖是否被使用以决定是否加载该模块。



但是，ESM的静态化同样也有限制

- 只能在文件顶部使用 import 来导入依赖（编译时加载/静态加载）
- 且模块名只能是字符串常量，而不能是动态的变量替代
- export 导出的变量类型严格限制

这样限制的目的，也是为了通过作用域分析，可以确定代码里变量所属的作用域以及他们之间的引用关系。



#### 原生 ES 模块应用场景

由于该标准是语言层面的，所以在使用工程化 webpack， 或者开发前端库，都建议使用原生的 ES 模块。

NodeJS 的 CommonJS 也逐步向原生 ES 模块转移，目前需要使用 CommonJS 的地方仅仅是在 Node 中。



#### Tree Shaking

##### 基础知识

基于 ESM， 在模块没有明显引用时，就可以进行去冗余。这就是 tree shaking。

主要目的就是减少应用中写了，但是没有被用到的 JS 代码，这样文件的体积更小，打包后的 bundle 体积也小，对用户体验有积极作用



tree shaking 处理的时机在打包之前。就像是做蛋糕，把蛋壳剥离，然后留下蛋清和蛋黄。

> （DCE，dead code elimination 处理方式相反，做出蛋糕后再去找蛋壳）



到最后，该技术也只是辅助手段。良好的模块拆分和设计才是减少代码体积的关键。



##### 局限性

也有 tree shaking 无法清除的无用代码。但是不建议马上用 webpack 去构建它的解决方案，基本使用和操作方法可以参照文档，或者看其他企业的实施。

- https://mp.weixin.qq.com/s/Y4v7tAWUeDNs_FWpUnKmAw
- https://juejin.im/post/5b8ce49df265da438151b468
- https://juejin.im/post/5a4dc842518825698e7279a9



### 导出和导入操作

#### export 和 export default 导出方式

可以用于导出 常量、函数、文件和模块等。

一个文件和模块中，`export` 可以多次使用， `import` 也是。



但是 `export default` 只有一个

- export 导出的是变量/接口，而不是值。所以模块内修改了变量值，外部引入得到的值会受到影响
  - 导入的时候需要 {var, fn}
- export default 导出的是一个具体的值。若模块内修改了这个导出的变量值，外部引入的值也不会影响
  - export default 不能直接导出变量表达式，不建议使用
  - 同时导出的结果可以随意命名变量，不利于团队管理
  - 因为直接导出了整体对象不利于 tree shaking 分析模块

```js
// a.js
export let a = 1 // 1 单个导出 a（注意不是导出 1）
export let b = 2
export let c = 3

// 2 导出变量，注意不能写成 a:1 这样的形式
// 这里导出的不是对象，而是一个变量列表，注意这是固定写法
export {
	a, b, c
}

// 3 默认导出，直接导出某个变量，外层引入时可以直接获取到
export default {d:1, e:2}

// 4 还可以把某个对象取别名为 default
// 等价于 export default obj
let obj = {}
export {
	obj as default
}
```



#### 导出操作

- 注意导出的接口映射， 即用 {} 包裹变量

- export 可以在顶层作用域的任何位置出现，但是不能在块级作用域中（违背模块化思想）

- export.default 导出的是整个模块， export 导出的是可选择的变量对象

- - 实际是导出了 default 的变量或方法，所以可以导入时可以任意改名

```js
// 1 module.js export 
export const a = 100 // 导出变量
export const dogSay = function(){]} // 导出方法
// 一起导出
export {
    a, 
    dogSay as newName // 可以更改导出名字,原名仍然可以使用
}

// 2 export.default
let m = 100
export m;// 会报错。因为导出的是100，而非接口。要像上面一样 {m} 建立关系
export.default = m; // 或这样这样写也是可以的，但是导出的就只有一个 m 引用了
export {m as default }; // 与上一句等效。因为本质就是导出了 default 引用
```



#### 导入操作

注意这里的 {dogSay}不是解构语法，而是具名导入。名字必须和模块中导出的一样

- 引入的模块变量是模块内部对应变量的引用，修改会直接改变原模块中的值
- 不可以更改导入的接口值（如原模块中的m=1这种），但是可以更改引用对象的属性值
- from 的文件路径，绝对和相对都可以。
- - 可以省略 .js 后缀
  - 若只有模块名，而非路径。则必须有配置文件，来配置该模块的位置
- import 会变量提升，会把声明放文件顶部，提升到整个模块头部，首先执行
- import 静态执行，所以不能用动态的表达式和变量
- import 是静态语法，所以只能在 JS 文件的顶部环境，不能放到作用域下

```js
// user.js 引入的问题
import {dogSay} from '../module.js' // 导入的是 export 
import m from '../module.js' // 导入的是 export.default，导入的名字可任意
import {'f'+'2'} from '../module.js' // 报错，不能写动态表达式
import 'lodash'; // 直接加载模块，且只执行一次
import * as circle from './circle'; // 加载全部 export 导出的，且改名
export {circle}; // 相当于转发操作，在本模块中将引入的模块直接抛了

// 全部导入，还要解构 default 对象
// default 是关键词所以不能直接解构，所以要取别名
// obj1 和 obj2 的两种方式拿到的都是 default
import obj1, {a, b, c, default as obj2} from './a.js'

// 使用上的问题
m = {} // 1 无法修改，是只读的
dogSay.fn() = function(){} // 2 引用类型可以修改
```



#### 常量的跨模块应用

若有很多常量，则需要新建一个目录专门存放，然后分文件导出。

```js
// constants/db.js
export const db = {
  url: 'http://my.couchdbserver.local:5984',
  admin_username: 'admin',
  admin_password: 'admin password'
};

// constants/user.js
export const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator'];
```



最后由一个 index.js 来统一整合再导出,

> 把其他模块导入，然后统一导出，这样外部就可以只引入这个代理模块就行

- export from 导入立即导出

```js
// constants/index.js
export {db} from './db';
export {users} from './users';
export * from './x' // 把 x 模块中的所有内容统一导出
```



使用的时候，只需要导入一个模块就行

```js
// script.js
import {db, users} from './constants/index';
```



#### 动态导入模块新 API —— import()

可以像调用函数一样动态导入模块，返回一个 promise。

- import() 动态导入，返回 promise

##### 基本使用

> 动态导入，还是一个草案
> 要安装一个 babel 插件

```js
const main = document.querySelector('main');

// 可以动态导入
import(`./section-modules/${someVariable}.js`)
  .then(module => {
  module.loadPageInto(main);
})
  .catch(err => {
  main.textContent = err.message;
});
```



##### 应用场景

- 按需加载。需要的时候再去执行

```js
button.addEventListener('click', event => {
  import('./dialogBox.js')
    .then({exp1, exp2}=> { // 加载后作为对象，成为 then 的参数。所以可解构可具名
    dialogBox.open();
  })
    .catch(error => {
    /* Error handling */
  })
});
```

- 条件加载。根据场景分支加载不同的模块

```js
if (condition) {
  import('moduleA').then(...);
} else {
  import('moduleB').then(...);
}
```

- 动态的模块路径

```js
import(fn()) // 根据 fn() 返回值来加载
.then(...);
```

- 并发加载多模块

```js
Promise.all([
  import('./module1.js'),
  import('./module2.js'),
  import('./module3.js'),
])
.then(([module1, module2, module3]) => {
   ···
});
```

- 配合 async/await

```js
async function main() {
  const myModule = await import('./myModule.js');
  const {export1, export2} = await import('./myModule.js');
  const [module1, module2, module3] =
    await Promise.all([
      import('./module1.js'),
      import('./module2.js'),
      import('./module3.js'),
    ]);
}
main();
```



### 在浏览器中使用 ES 模块化

#### 浏览器加载 script 标签

##### 传统模式

默认的 script 标签 type=application/javascript，也就是加载 JS 脚本。因为是默认是的，所以可以忽略不写

```js
<script type="application/javascript" src="path/to/myModule.js">
```

这样加载的 JS 脚本有一个阻塞浏览器渲染的因素，所以浏览器提供了异步的加载方式（注意代码不要和DOM有强关联）

- defer。渲染完毕后再执行，且多个 defer 脚本会按页面顺序加载
- async。一旦下载完毕，渲染引擎就终端渲染，来执行该脚本

```js
<script src="path/to/myModule.js" defer></script>
<script src="path/to/myModule.js" async></script>
```



##### 模块加载规则

1 在 `script` 标签中增加 `type="module"` ，浏览器会知道这个文件是模块化的方式来运行的。

2 都是异步的，不会造成浏览器阻塞，模式默认是 `defer`。当然也可以开启 `async` 模式

3 若有多个 `module`，会按照页面顺序执行加载

4 模块内部顶层作用域中的 `this` 是 `undefined`，所以直接在顶部使用 `this` 是无意义的

- 利用这个特性，可以检测当前代码是否在 ES6 模块中

```js
const isNotModuleScript = this !== undefined;
```

- 对于这个 `module` 还可以应用于当前浏览器的兼容性，因为支持 `ES` 模块，那肯定支持其他 `ES NEXT` 特性

```js
<script type="module">
    import module1 from './module1'
</script>
```

- 在不支持的浏览器，`script` 标签要用 `nomodule` 属性来指定某脚本为 `fallback` 方案

> 这是一种优雅降级

```html
<script type="module">
    import module1 from './module1'
</script>
<script nomodule>
     alert('你的浏览器不支持 ES 模块，请先升级！')
</script>
```



## Node 中的模块

NodeJS 的模块遵循 CommonJS 规范。简单说就是：

- module：模块标识

- exports：模块定义

- require：模块引用

在 node9 开始，也开始支持 ESM 规范。但是在执行脚本时需要加上 `--experimental-modules`。或者使用 `babel-cli/babel-preset-env` 来处理。



### export 和 module 对象

当Node执行一个文件时，该文件内会自动生成2个对象

- module 对象

- 该对象中还有一个 exports属性，就是我们认识的 module.exports

- exports 对象

理解他们2个的区别，就需要从内存着手。

> 被Node执行的文件，存在一个内存。
>
> 首先，module.exports 指向了该内存。
>
> 然后，exports 也跟着指向该内存。
>
> 最后暴露给外面的，仅仅是 module.exports， 而 exports 暴露的无关紧要（只是用来干活的）。
>
> 我们导入的都是 module.exports 指向的内存的东西

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119143259.png)



### 导入和导出

当然我们可以改变 exports 的指向，但是我们导入的时候能找到的只有 module.exports 内存中的数据

```js
// module.js
let a = 123
exports.a = 200 
// 相当于下面的操纵
module.exports = {
    a:200
}

exports = function(){} // 改变了 exports 自己的引用指向

// user.js
let data = require('../module.js')
console.log(data) // {a:200}
```



如果返回的是一个类或者构造函数

```js
// module.js
class XXX = {
    
}

module.exports = XXX

// user.js
const XXX = require('../module.js')
let xxxx = new XXX()
```



## Script 模块

### script 标签引入的方式

针对 `<script>` 脚本的异步加载，使用 “defer 或 async”。来提高页面的性能

```js
<script type="text/javascript" src="/script1.js"></script>
<script defer type="text/javascript" src="/script2.js"></script>
<script async type="text/javascript" src="/script3.js"></script>
```



### 画几张图简要说明

> 网上有了不少这种类似的图，但是基本都是拿一个script就举例的
>
> 未免太过寒酸，so咱们来一个豪华版，来画一下多个脚本加载时的甘特图
>
> 就像近年来各大手机厂商，出新机都喜欢来一个X+X plus



拿四个不同的颜色来标明各自代表的含义，

> 更正：文档渲染 应该为 文档解析

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119143448.png)

#### 普通 script

文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到script脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载script所对应的资源，这样能够节省一部分下载的时间）。



资源的下载是在解析过程中进行的，虽说script1脚本会很快的加载完毕，但是他前边的script2并没有加载&执行，所以他只能处于一个挂起的状态，等待script2执行完毕后再执行。

当这两个脚本都执行完毕后，才会继续解析页面。

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119143516.png)



#### defer

文档解析时，遇到设置了`defer` 的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&渲染完毕后。

会等到所有的 `defer` 脚本加载完毕并按照顺序执行，执行完毕后会触发 `DOMContentLoaded` 事件。

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119143538.png)

#### async

async 脚本会在加载完毕后执行。

async 脚本的加载不计入 `DOMContentLoaded` 事件统计，也就是说下图两种情况都是有可能发生的

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119143609.png)



### 推荐的应用场景

#### defer

如果你的脚本代码依赖于页面中的DOM元素（文档是否解析完毕），或者被其他脚本文件依赖。

```hs
评论框
代码语法高亮
polyfill.js
```



#### async

如果你的脚本并不关心页面中的DOM元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。

```js
// 百度统计

如果不太能确定的话，用defer总是会比async稳定。。。
```


