# 作用域和执行上下文

## V8 底层：GO/VO/AO/EC 以及作用域和执行上下文

### 基本概念

- GO：全局对象 Global Object
  - 会在页面打开时就挂载一些属性如 `string, document, window=this ...`
- ECStack：执行环境栈， Execution Context Stack
- EC：执行环境（执行上下文）Execution Context
  - VO：变量对象 Varibale Object
  - AO：活动对象（函数要存的那些变量对象， 是 VO 的一个子集）Activation Object
- Scope：作用域，创建函数时赋予
- Scope Chain：作用域链



### 底层执行步骤

假设代码如下

```javascript
let x = 1
function A(y) {
  let x = 2
  function B(z) {
    console.log(x + y + z)
  }
  return B
}
let C = A(2)
C(3)
```

过程:

```javascript
// 0 执行环境栈
ECStack = [
  // 3 B 的执行上下文
  EC(B) = {
  	[scope]:AO(A)
    scopeChian:<AO(B), AO(A), A[[scope]]>
    //  创建函数 B 的活动对象
    AO(B):{
      arguments:[0:3] // 这也普通函数执行时，最先操作的事情
      z:3
      this:window
    }
  }
  
  // 2 执行函数 A(2), 每次执行函数就要新压一个栈，因为每个函数都有自己的执行上下文
  EC(A) = {
    // 2.1 上下文链表初始化：
    [scope]:VO(G)
    // A 的 scope 就是 VO(G)
    scopeChain:<AO(A), A[[scope]]>
		// 2.2 创建函数 A 的活动对象
    AO(A): {
      arguments:[0: 2] // 只有一个入参，所以在 0 位置上初始化
      y:2
      x:2
      B:function(z){...}
      B[[scope]] = AO(A)
      this:window
    }
  }
  
  // 1 全局执行上下文
  EC(G) = {
    // 1.2 全局变量对象
    VO(G): {
    	..., // 全局对象中其他原有的属性
    	X = 1,
    	A = function(y){...},
      // 声明函数的同时，就指定了作用域，这里指向了全局变量对象
      A[[scope]] = VO(G)
  	}
  }
]
```



## 面试题解析

### 简单题

```javascript
let a = 12, b = 12
function fn(){
  let a = b = 13
  console.log(a, b) // 13, 13
}
fn()
console.log(a, b) // 12, 12
```

### 闭包作用域

```js
let i = 1
let fn = (i) => (n) => console.log(n + (++i))
let f = fn(1) // 闭包 i = 1, 此时与全局 i 已经没有关系
f(2) // 4， 此时 n = 2, i = 1， 所以为 2 + (i++) = 4
fn(3)(4) // 8，此时 i = 3, n = 4， 所以是 4 + (i++) = 8。此时的 fn(3)(4) 是新的执行栈
f(5) // 8, 此时 n = 5, i = 2（依赖第一次的 fn(1) 执行后的结果， 所以是 5 + (++i) = 8
console.log(i) // 1， 全局的没有变过
```

