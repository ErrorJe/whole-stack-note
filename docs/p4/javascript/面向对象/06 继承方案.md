# 继承方案

JS 的继承方式是基于原型对象的。



## 原型链和 Object.prototype

### 原型链

原型对象的属性和方法，可以被对象实例给访问，这就是继承的体现。

原型对象也是对象，也有属于自己的上级原型对象，以此类推形成`原型对象链`。



### Object.prototype

所有以字面量形式创建的对象 `let obj = {}`，其原型对象都是 `Object.prototype`，也即是该对象的`[[Prototype]]`值。

```js
let obj = {}
Object.getPrototypeOf(obj) == Object.prototype // true
```



### Object 原型对象常用的方法

> 尽量不要去修改 `Object.prototype` 上的属性或方法。如果增加了，则默认是可枚举。
>
> 那么在 for-in 语句中最好搭配判断 `Object.hasOwnProperty`



#### valueOf

在对象上使用`操作符`时，就会默认调用 `valueOf`方法，且默认返回对象实例本身。对不同类型的数据做出不同的反应

- String 类型，返回字符串
- Boolean 类型，返回布尔
- Number 类型，返回数字
- Date 类型，返回 epoch 时间，单位是毫秒

```js
new Data > new Date(2010) // true
```

其实可以自定义 valueOf 方法，也就是去重写他。



#### toString

当 `valueOf` 返回的是一个引用而不是原始值的时候，就会回退调用 `toString`方法。

```js
let obj = {}
let msg = 'this is' + obj  // 'this is [object object]' 自动调用 toString
```

当然也可以重写该方法

```JS
let obj = {
  toString:function(){
   return 'toString'
  }
}
let msg = 'this is' + obj  // 'this is toString'
```



## 对象继承

就是指定新对象的 `[[Prototype]]`是哪个父对象。

- Object.prototype 是对象字面量形式默认的
- Object.create 可以显式指定



### Object.create 继承创建对象

```js
// 参数1：指定新对象的 [[Prototype]] 属性
// 参数2：就是对象特征的描述

// 1 字面量形式创建。自动继承于 Object.prototype
let obj = {
  msg:'wjy'
}

// 2 使用 create 方法创建 obj
let obj = Object.create(Object.prototype, {
  msg:{
    value:'wjy',
    writable:true,
    configurable:true,
    enumerable:true,
  }
})
```

创造出一个没有原型对象的对象

`let obj = Object.create(null)` 意味着如 toString 之类的方法都不存在了，只是一个哈希容器。也没有别的用处



### 构造函数继承

#### 构造函数的 JS 机制

- 默认继承于 Object.prototype
- 重置 constructor 属性为自己

```js
// 1 自己创建的构造函数
function myConstructor(){}
// 2 JS 引擎底部做的事。
// 默认继承于 Object.prototype,
myConstructor.prototype = Object.create(Object.prototype, {
  // 重置 constructor 属性为自己
  constructor: {
    value:myConstructor,
    configurable:true,
    enumerable:true,
    writable:true
  }
})
```



#### 改写 prototype 实现继承

```js
// 1 创建 2 个构造函数
function Father(){}
obj1.prototype.fn = function(){}

function Son(){}

// 2 实现继承
// constructor 是 xxx.prototype 原型对象的属性
Son.prototype = new Father() // 此时 constructor 为 Father
Son.prototype.constructor = Son // 将 constructor 重置回自己
```

事实上， Son 对于继承唯一需要关心的是原型对象要指向 `Father`。

- 这里需要注意，如果在 Son 的原型对象上要新增方法，必须在完成继承之后。不然之前的都会被丢失

那么就可以用 `Object.create`来简化。

对比上面的实现，会出现调用 `new  Father ` 时若有初始参数的传入要求，但是没有传会出现报错。现在这种方法就可以避免（没有调用父类构造函数来初始化）

```js
// 1 创建 2 个构造函数
function Father(){}
obj1.prototype.fn = function(){}

function Son(){}

// 2 用 Object.create 简化代码
Son.prototype = Object.create(Father.prototype, {
  constructor: {
    value:Son,
    configurable:true,
    enumerable:true,
    writable:true
  }
})
```



### 构造函数的窃取（伪类继承）

JS 的继承是通过原型链实现的，所以不用调用对象的父类构造函数。

若确实有这个需要，就要利用 JS 函数工作的特性。如 `call, apply`方法。模仿那些基于类的语言的类继承。

```js
// 1 创建 2 个构造函数
function Father(length,width) {
  this.length = length
  this.width = width
}

// 2 在子类中调用父类构造方法
function Son(size) {
  Father.call(this, size, size)
}

// 3 实现继承
Son.prototype = Object.create(Father.prototype, {
  constructor: {
    value:Son,
    configurable:true,
    enumerable:true,
    writable:true
  }
})

// 4 创建实例
let son = new Son(6) // son.length = 6; son.width = 6
```



### 访问父类方法

ES6 之前没有 `super` 关键词，还是依靠 call, apply 等方法在调用父类原型对象中的方法时使用

```js
Son.prototype.toString = function(){
  let text = Father.prototype.toString.call(this) // 拿到父类 toString 方法
  return text.replace('Father', 'Son')
}
```



## 类的继承方案

### 原型链继承

#### 实现关键

实现原型链实现继承关键要点是

这样的实现，不同的 `Child 实例`的 `__proto__` 会引用同一 `Parent` 的实例。 

```js
Child.prototype = new Parent()
```



#### 方式一：proto 属性

> 直接修改了 `__proto__`

```js
function Animal(name) {
  this.name = name
}

function Cat() {
  // 子类借用父类的构造方法，实现继承实例属性
  Animal.apply(this, arguments)
}

// 修复原型对象（Cat 拥有自己的原型对象）
Cat.prototype.__proto__ = Animal.prototype
```



#### 方式二：setPrototypeOf 优化

跟方式一是一样的，只是我们用新的 API 取代之前对 `__proto__` 属性的直接改写

```js
Object.setPrototypeOf(Cat.prototype, Animal.prototype)
```



#### 方式三：Object.create

> 创建一个新的对象，作为子类的原型对象

```js
function create(parentPrototype) {
  function Fn(){}
  Fn.prototype = parentPrototype // 借用父类原型对象
  let obj = new Fn()
  obj.constructor = Cat // 实例上增加 constructor ，就不会继续向上找
  return obj
}
Cat.prototype = create(Animal.prototype)
```



### 构造函数继承

#### 实现关键

这样的实现问题也比较大，其实只是实现了实例属性继承，Parent 原型的方法在 Child 实例中并不可用 

```js
function Child (args) {
  // ...
  Parent.call(this, args)
}
```



#### 实现方案

核心代码：`Parent.call(this, args)`

不管是使用 call 还是 apply 方法，通过调用 student 的构造函数，其实并没有产生继承关系

```js
// 构造函数
function Student(props) {
  this.name = props.name || 'Unnamed'
}
Student.prototype.height = 1 // 在原型对象上增加属性 height 

// 继承实现方法
function PrimaryStudent(props) {
  Student.call(this, props) // 调用Student构造函数，绑定This变量( PrimaryStudent 实例)
  this.grade = props.grade || 1
}
var p = new PrimaryStudent(1) // 新建 PrimaryStudent 实例

p.height // undefined，所以是不能调用Student.prototype定义的方法
```



Student 并没有被继承，而是被扩展成了 PrimaryStudent 。

因为改写的是“this”，最后所谓继承到的东西是 student 实例中可以拥有的东西（就是直接写在构造函数内的，而不是通过原型对象 prototype 定义的部分）。

所以，在 student.prototype 上定义的 height 属性，在 PrimaryStudent 中是拿不到的。

- PrimaryStudent 真实的原型链

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200120153923.png)

- 我们想要的继承关系：原型链对了，继承关系就对了

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200120153941.png)



### 组合继承

组合就是一种原型链+ 构造函数的方式

#### 实现关键

> 这是基本可以用的方式

它的问题在于 Child 实例会存在 Parent 的实例属性。因为我们在 Child 构造函数中执行了 Parent 构造函数。

同时，`Child.__proto__` 也会存在同样的 Parent 的实例属性，且所有 Child 实例的 `__proto__` 指向同一内存地址 

```js
function Child (args1, args2) {
  // ...
  this.args2 = args2
  Parent.call(this, args1)
}
Child.prototype = new Parent()
Child.prototype.constrcutor = Child
```



#### 实现方案

这种静态属性继承存在一个问题：在陈旧浏览器中，属性和方法的继承我们是静态拷贝的，继承完后续父类的改动不会自动同步到子类。

这是不同于正常面向对象思想的。但是这种组合式继承，已经相对完美、优雅 

```js
function inherit(Child, Parent) {
  // 继承原型上的属性 
  Child.prototype = Object.create(Parent.prototype)

  // 修复 constructor
  Child.prototype.constructor = Child

  // 存储超类
  Child.super = Parent

  // 静态属性继承
  if (Object.setPrototypeOf) {
    // setPrototypeOf es6
    Object.setPrototypeOf(Child, Parent)
  } else if (Child.__proto__) {
    // __proto__ es6 引入，但是部分浏览器早已支持
    Child.__proto__ = Parent
  } else {
    // 兼容 IE10 等陈旧浏览器
    // 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法
    for (var k in Parent) {
      if (Parent.hasOwnProperty(k) && !(k in Child)) {
        Child[k] = Parent[k]
      }
    }
  }

}
```





### 继承 Date

JS 的日期对象只能同 Date 作为构造函数来实例化得到， 所以无法用上述的方法直接实现继承



#### 寄生组合式继承测试 Date 对象

在调用 Date 中的方法时，若浏览器发现调用该方法的对象不是 Date 构造函数构造出来的实例，则抛出错误

```js
function Son() { // 子类
  Date.apply(this.arguments)
  this.foo = 'bar'
}

inherit(Son, Date) // 实现继承

Son.prototype.getMyTime = function() { // 子类静态方法
  return this.getTime()
};

let date = new Son()

// Uncaught TypeError: this is not a Date object.
console.log(date.getMyTime()) 
```



#### 实现 Date 对象继承

```js
function DateConstructor() {
  // 返回一个真正的 Date 对象
  var dateObj = new(
    Function.prototype.bind.apply(
      Date, [Date].concat(Array.prototype.slice.call(arguments))
    )
  )()

  Object.setPrototypeOf(dateObj, DateConstructor.prototype)

  dateObj.foo = 'bar'

  return dateObj // dateObj.__proto__ === DateConstructor.prototype
}

// 实现 DateConstructor.prototype.__proto__ === Date.prototype
// 最终就是 date.__proto__.__proto__ === Date.prototype
Object.setPrototypeOf(DateConstructor.prototype, Date.prototype)

DateConstructor.prototype.getMyTime = function getTime() {
  return this.getTime()
}

let date = new DateConstructor()

console.log(date.getMyTime())
```



### ES6 继承方案

延续上面的 Date 继承，使用 ES6 的继承方式



#### ES6 方式实现 Date 继承

```js
class DateConstructor extends Date {
  constructor() {
    super()
    this.foo ='bar'
  }
  getMyTime() {
    return this.getTime()
  }
}

let date = new DateConstructor()
date.getMyTime() // 完美执行
```



#### 验证继承关系

```js
class Person (){
  constructor() {
    this.type = 'person'
  }
}
class Student extends Person() {
  constructor() {
    super()
  }
}

var student1 = new Student()

student1.type // "person"
student1 instanceof Student // true, 在其原型链上
student1 instanceof Person // true
student1.hasOwnProperty('type') // true
```

