# 七、对象模式 

## （一）私有和特权成员

JS 对象中的熟悉都是公有的，且没有显式的方法指定某个属性不能被外界某个对象访问。

但是有时候不希望数据公有。应用场景

- 用值类控制对象的状态，若在对象不知情下改变值，就会让状态混乱



### 1 模块模式（特权方法）

创建拥有私有数据的对象模式。基于思路是使用 `IIFE` 返回一个对象。

> IIFE（立即调用函数表达式），是被定义后立即调用并产生结果的函数表达。该函数可以包括任意数量的本地变量，且在函数外不可见。
>
> 因返回的对象在函数内部，所以可以声明一些对象方法去访问(特权方法)

#### 1）IIFE 模块方式

```js
let myObj = (function(){
  // 一些私有变量
  return {
    // 暴露给 myObj 的方法和属性
  }
}())
```

IIFE 函数仅存在于被调用的瞬间，一旦执行后就被销毁。但是利用到的本地变量会单独存在内存中，所以可以通过 IIFE 暴露的方法去继续访问

#### 2）闭包函数

上面说到的`特权方法`，一般来说就是`闭包函数`

```js
let myObj = (function(){
  let age = 25
  return {
    // 闭包函数。访问的变量是从自己函数作用域外的父级作用域中拿的
    getAge:function(){
      return age
    }
  }
}())
```

#### 3）暴露模块模式

就是一种写法上的改变，将方法都写在  IIFE 顶部

```js
let myObj = (function(){
  let age = 25
  function getAge(){
      return age
    }
  return {
    getAge:getAge
  }
}())
```



### 2 私有成员

IIFE 模式就是针对于单个具体的对象。对于一样需要私有属性的自定义类型对象

- 在构造函数中使用类似的模式创建每个实例的私有数据

#### 1）对象实例的私有数据

```js
function myObj(name){
  let age = 12 // 定义本地变量。打算用方法去访问这个变量
  this.name = name // 这是实例属性，可以直接访问
  this.getAge = function(){
    return age
  }
}

// 使用
let obj = new myObj('wjy')
obj.name // wjy
obj.getAge // 12
```

#### 2）实例共享的私有数据

- 模块模式 + 构造函数。就像被定义在原型对象上一样

```js
// 就是在 IIFE 中去定义构造函数
let myObj = (function(){
  // 1 本地变量
  let age = 25
  // 2 构造函数
  function InnerObj(name){
    this.name = name
  }
  // 3 在构造函数的原型对象上定义方法
  InnerObj.prototype.getAge = function(){
    return age
  }
  // 改变 age 的方法
  InnerObj.prototype.addAge = function(){
    age++
  }
  
  // 4 返回构造函数
  return InnerObj
}())

// 创建2个实例，他们修改 age 都会受到影响
let obj1 = new myObj('wjy1')
let obj2 = new myObj('wjy2')
obj1.addAge()

obj1.getAge() // 26
obj2.getAge() // 26
```



## （二）混入继承

> 一个对象在不改变原型链的情况下得到另一个对象的属性，叫混入
>
> 也就是把 A 对象的属性拷贝到了 B 对象，这是浅拷贝，注意引用数据类型。

### 1 混入的基本实现

不考虑 ES3 的实现版本，且未考虑那些访问器属性（访问器属性赋值过来后就是数据属性，也就是访问器并未生效）

``` js
// 接收者对象，提供者对象
function mixin(reveiver, supplier) {
  // 遍历提供者对象的属性
  for (let property in supplier) {
    // 拷贝提供者属性的自有属性，而不是把所有可枚举的内建属性也拿过来
    if (supplier.hasOwnProperty(property)) {
      reveiver[property] = supplier[property]
    }
  }
  
  return receiver
}
```



### 2 发布订阅事件对象的多种继承实现

#### 1）发布订阅构造函数（类）

```js
function EventTarget(){} // 1 支持事件的自定义类型
// 2 实现其原型方法
EventTarget.prototype = {
  // 3 锁死自己的 构造函数 指向
  constructor:EventTarget,
  // 4 监听事件
  addListener: function(type, listener) {
    // 4.1 创建一个事件数组。先判断其是否存在
    if (!this.hasOwnProperty('_listeners')) {
      this._listeners = []
    }
    // 4.2 事件类型判空
		if(typeof this._listeners[type] == 'undefined') {
      this._listeners[type] = []
    }
    // 4.3 增加该事件类型的监听者
    this._listeners[type].push(listener)
  }
  
  // 5 触发事件 也有取名 tigger 的
  fire:function(event) {
    // 5.1 检查父委托
    if(!event.target) {
      event.target = this
    }
    
    // 5.2 检查是否有该类型的事件监听
    if(!event.type) {
      throw new Error('Event object missing "type" property.')
    }
		
    // 5.3 派发事件
    // 类型检查
    if (this._listeners && this._listeners[evnet.type] instanceof Array) {
      let listeners = this._listeners[event.type]
      for (let i=0, len=listeners.length; i<len; i++) {
        listeners[i].call(this.event)
      }
    }
  }

	// 6 删除监听者
	removeListener:function(type, listener) {
    if (this._listeners && this._listeners[type] instanceof Array) {
      let listeners = this._listeners[type]
      for (let i=0, len=listeners.length; i<len; i++) {
        if(listeners[i] = listener) {
          listeners.splice(i, 1)
          break
        }
      }
    }
  }
}

// 7 基本使用方式
let t = new EventTarget()
t.addListener('msg', function(event) {
  console.log(event.data)
})
t.fire({type:'msg', data:'wjy'})
```

#### 2）伪类继承方式

```js
function Myobj(name) {
  this.name = name
}
// 继承 EventTarget 类
Myobj.prototype = Object.create(EventTarget.prototype)
Myobj.prototype.constructor = Myobj

// 定义一个原型对象方法
Myobj.prototype.sayName = function(){
  this.fire({type:'name', name:name})
}

let obj = new Myobj('wjy')
```

这样继承的方式，有一个奇怪的地方。就是`obj instanceof EventTarget === true`

#### 3）混入继承

这种方式，并没有继承。Myobj 也不是 EventTargert 的实例

```js
function Myobj(name) {
  this.name = name
}

// 混入 EventTarget 实例来获取事件行为
mixin(Myobj.prototype, new EventTarget())
// 混入 constructor 和 方法来完成原型对象的组装
mixin(Myobj.prototype, {
  constructor: Myobj,
  sayName:function(){
    this.fire({type:'name', name:name})
  }
})

let obj = new Myobj('wjy')
```

下面是对 EventTarget 实例又混入了一些新的属性和方法

- 这里有一个 get  访问器属性。在这种混入方式下，会变成数据属性。也就是一个原始的数据值而已，可以读写

```js
let obj = mixin(new EventTarget(), {
  name:'wjy',
  get name(){
    return 'wjy2'
  },
  sayName:function(){
    this.fire({type:'name', name:name})
  }
})
```



### 3 实现访问器属性的混入

以上做法，无法混入有访问器属性的情况。所以要改良一下。

另外需要对 ES3 和 ES5 做出兼容（ES6 已经无需关心，但是这体现的是兼容思想）

```js
function mixin(reveiver, supplier) {
  // 判断 ES3 或 ES5 环境
  if(Object.getOwnPropertyDescriptor) {
    // 遍历所有可枚举的对象自有属性
    Object.keys(supplier).forEach(function(property){
      let des = Object.getOwnPropertyDescriptor(supplier, property)
      Object.defineProperty(receiver, property, des)
    })
  } else {
    for (let property in supplier) {
      if (supplier.hasOwnProperty(property)) {
        reveiver[property] = supplier[property]
      }
    }
  }

  return receiver
}
```



## （三）作用域安全的构造函数

这里的场景就是，我们去实例化 Array 等原生对象时，有时候不用加 `new`

```js
function obj(name) {
  if(this instanceof obj) {
    this.name = name
  } else {
    return new obj(name)
  }
}
```



