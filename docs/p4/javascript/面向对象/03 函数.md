# 三、函数

## （一）函数的机制

JS 的对象内定义了很多内部属性，就是用 `[[xxx]]`双括号包裹的属性。他们不可以用代码来访问，是用于定义行为的。

> 函数就内置了 `[[Call]]`，表示可以被执行。
>
> ECMAScript 定义 `typeof` 对所有 `[[Call]]`对象返回 `function`

```js
function fn (){}
typeif fn // 'function'
```



## （二）函数创建和提升

创建函数有2种方式

- 声明
- 表达式

### 1 函数声明

以 `function` 关键字开头

```js
function fn() {
	return 1
}
```



### 2 函数表达式

匿名函数，用变量或属性去引用函数表达式

```js
let fn = function(){
	return 1
}
```



### 3 函数变量提升

函数声明和表达式的区别，就在于变量提升。

`函数声明`的方式会被提升至上下文的顶部，这意味着可以先用函数后声明他们。

```js
let res = add(5)
function add(num) {
	return num
}
```

它的实际执行过程

```js
// 提升到顶部
function add(num) {
	return num
}
let res = add(5)
```





## （三）函数是一等公民

### 1 函数是值

函数可以被当做值的引用

```js
let fu = function(){}
let fn2 = fn // 指向同一个函数
```



### 2 函数的参数 arguments

> `argument`对象自动存在于函数中，是个类数组对象，所以不能用 `Array.isArray`来判断类型。

```js
function(n, y){
  return argument[1] // 返回了参数 y
}
```



## （四）函数重载

> 其他语言的函数可能存在重载情况，依据就是参数签名。

JS 函数并没有参数签名，可以接受任意数量的参数且没有类型限制。所以 JS 函数根本没有参数签名，也没有重载的概念。

```js
function fn(){return 1}
function fn(num){return num}

// 同名函数只有最后定义的有效，前面的全部丢失
fn(2) // 2
```



唯一可以实现类似重载功能的方式

- 根据 arguments 个数判断，来决定函数形态
- 利用 typeof, instanceof 鉴别参数类型，来决定函数形态



## （五）对象方法

函数作为对象某个属性对应的值，那这就是方法。

```js
const obj = {
  fn:function(){}
}
obj.fn() // 像属性一样调用执行
```



### 1 this 对象

若函数被作为对象的方法，那么函数和对象之间就是紧耦合。难以复用这个函数。

> 每个函数作用域内都有一个 `this`代表调用该函数的对象。

- 全局作用域，this 是全局对象（浏览器中window， NodeJS环境中 global）
- 函数作为对象的方法被调用，this 默认为该对象

```js
let obj = {
  name:'wjy',
  fn:function(){
    console.log(this.name) // this.指 obj
  }
}
```

经过这样的改动，那么这 `fn` 函数是具有复用性的

```js
function fn(){
  console.log(this.name)
}

let obj1 = {
  name:'obj1',
  fn:fn
}

let obj2 = {
  name:'obj2',
  fn:fn
}

obj1.fn() // 'obj1'
obj2.fn() // 'obj2'
```



### 2 改变 this 指向

操作 this 的能力是良好 OOP 的关键。函数会在各种不同上下文中被使用，他们必须要求正常工作。

有三个方法可以改变默认的 this 指向。

#### 1）call 方法

> 参数1：this 指代的对象；参数2：传入函数的任意个参数

```js
function fn(text){
  return this.name + text
}

let name = 'global'
let obj1 = {name:'obj1'}
let obj2 = {name:'obj2'}

fn.call(obj1, 'x') // obj1x
fn.call(obj2, 'y') // obj2y
fn.call(this, 'z') // globalz
```



#### 2）apply 方法

作用和 `call` 完全一样，只是第二个参数是以数组的形式传入

```js
fn.apply(this, ['z', 'y'])
```



#### 3）bind 方法

是创建一个新方法。需要手动执行。参数和上面2个也是一样的，第二个参数和call一样，可以传入任意个参数

```js
function fn(text) {
  return this.name + text
}
let obj = {
  name:'wjy'
}

let fn2 = fn.bind(obj, 'hhh') // 创建新方法
fn2() // wjyhhh
```

