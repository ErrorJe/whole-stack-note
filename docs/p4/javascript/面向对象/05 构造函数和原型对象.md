# 五、构造函数和原型对象

JS 缺少类（至少 ES6 之前是这样），利用`构造函数`和`原型对象`给对象带来与类相似的功能，但不完全一致。

### 1 构造函数

> 就是用 new 创建对象时调用的函数。
>
> 用一个构造函数创建的实例都拥有同样的属性和方法。这也是使用它的原因。
>
> 行业约定构造函数首字母大写，就跟私有变量约定首字符为 `_`一样

#### 1）new 操作符

`new` 操作符自动创建给定类型的对象并返回。

这些实例都独立拥有构造函数的变量和方法。

```js
function Fn(name){
	// 可以声明一些变量和方法
  this.name = name || 'wjy'
  this.sayName = function(){}
  
  // 若这里显式 return 了一个对象，则会返回该对象。return 原始类型是无效的
}

// 创建对象
// 没有参数传入时，可以省略括号
let obj1 = new Fn; 
// 被创建的实例拥有原来在构造函数中的变量和方法
obj1.name // 'wjy'
obj1.sayName()

obj1 instanceof Fn // true
```

若不用 `new` 调用构造函数，那么原本构造函数中的 this 都是指向全局的，容易出现错误。

#### 2）构造函数属性 constructor

对象实例拥有的原生属性，指向创建它的构造函数

```js
obj1.constructor === Fn // true
```

但是任然建议使用 `instanceof`来判断实例是否属于某个构造函数。因为 `constructor`会被覆盖，不是很准确。



### 2 原型对象

通过`new`调用构造函数创建的 100 个对象实例，独立拥有 100 套变量和方法。这在一些场景显然内存开销过大。我们就要通过原型对象去创建一些共享的变量和方法。

#### 1）鉴别原型属性

```js
function hasPrototypeProperty(obj, name) {
  // in 操作符判断是自有属性和原型属性
  // 同时满足该属性不是自有属性
  // 那么就相当于是判断该属性是否是原型属性
  return name in object && !object.hasOwnProperty(name)
}
```

#### 2）[[Prototype]] 属性

用内部属性 `[[Prototype]]`跟踪对象实例的原型对象。

当用new创建一个对象，构造函数的原型对象就会赋值给该对象的 `[[Prototype]]`属性

- 用 `Object.getPrototypeOf`读取 [[Prototype]]属性的值

```js
let obj = {}
let prototype = Object.getPrototypeOf(obj)

// obj 是泛用对象，所以都是指向 Object
prototype === Object.prototype
```

- 大多数浏览器 JS 引擎给所有对象上增加了 `_proto_`的属性，可以直接读写 `[[Prototype]]`的值。但是这个有性能上的问题，所以 ES 标准建议使用2个替代的方法
  - **Object.setPrototypeOf** 改写[[prototype]]属性
  - **Object.getPrototypeOf **读取[[prototype]]属性

#### 3）在构造函数中使用原型对象

> 原型对象的机制让他们成为一次性为所有对象定义方法的理想手段

- 通过原型对象增加变量或方法

```js
// 给 Fn 构造函数的原型对象增加 getName 方法
// 这样所有通过 Fn 创建的实例对象都可以该方法
Fn.prototype.getName(){
  return this.name
}
```

- 要特别注意原型对象上的引用类型。因为内存也是共享的

```js
Fn.protytype.arr = []

// 创建2个实例
let obj1 = new Fn()
let obj2 = new Fn()

// 操作原型对象上的数组变量 arr
obj1.arr.push(1)
obj2.arr.push(2)
obj2.arr // [1,2]，原型对象上的数组被修改2次，因为是引用类型
```

- 字面量形式替换原型对象

```js
Fn.prototype = {
  // 字面量形式改变了原型对象属性，因为现在指向 Object 而不是 Fn。所以要重置该属性
  // 且注意要放在第一行，避免在没有正确指向的时候调用了方法。
  constructor:Fn, 
  sayName:function(){},
  toString:function(){}
}
```

#### 4）改变原型对象

简单来说就是后来增删的原型对象上的变量或属性，都会立即反应到所有实例上。

因为这个原型对象就是一个指向它的指针引用

#### 5）内建对象的原型对象

就是可以修改一些内建对象的原型对象

```js
Array.prototype.sum = function(){
  // 可以自己重写以赋予更多能力
  // 实际开发不建议这样做，这会让新人无法确定该方法的作用
}
```

