

# ES6 类

在 ES6 之前都用 `构造函数` 来充当类

现在也很少使用类，包括 `vue`， `react` 都使用函数式，类还是有不少缺陷的。



### 类基础知识

#### 类的缺陷

> vue2 内部没有使用类

- 所有功能和方法都要放到类的内部
- 类只能通过 `new` 来调用



#### 构造函数

构造函数就是当作类

- 类中的 `this` 类型，指向都是产生的实例
  - 特殊情况就是返回一个引用类型（对象、函数、数组），则该返回值会作为实例
- 抽象类：可以被子类继承，但是自己不能被 `new`

```js
function Animal() { 
  // 判断是否经过 new
  if (!(this instanceof Animal)) {
    throw new Error('没有 New')
  }
  
  // 判断是谁 new 的，保证抽象类无法直接被 new
  if (new.target === Animal) {
    throw new Error('这是抽象类，不能被 new')
  }
}

new Animal // 不传参时，可以省略 ()
```



#### 类实例属性

#### 原型链和公共方法

- `__proto__`， 实例对象上有，IE 不能用
- `prototype`， 构造函数上有
  - `a.__proto__ === Animal.prototype `
- `constructor`， 通过实例对象找到类本身，是放在原型上的属性
  - `.__proto__.constructor === Animal`
- `instanceof` 判断实例
  - `a instanceof Animal`

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200115212456.png)

```js
function Animal(name) {
  this.name = name
}

// 实例的公共方法，定义在类的原型上
Animal.prototype.eat = function(){} // prototype 是个对象

// 每次new都会创建实例
let a = new Animal('a')
// 去实例对象的 __proto__ 上找 eat，没有顺着所属类的 prototype 找，没有再继续顺着上级类找
console.log(a.eat())  // 先找自己的
a.__proto__.eat() // 找所属类原型上的
a.__proto__.constructor.prototype.__proto__.eat() // 原型链继续找
```



### 类的继承

比较合理的就下面三种

#### 方式一：proto

> 直接修改了 `__proto__`

```js
function Animal(name) {
  this.name = name
}

function Cat() {
  // 子类借用父类的构造方法，实现继承实例属性
  Animal.apply(this, arguments)
}

// 修复原型对象（Cat 拥有自己的原型对象）
Cat.prototype.__proto__ = Animal._prototype
```



#### 方式二：setPrototypeOf

好处就是不用直接修改 `prototype`

跟方式一是一样的

```js
Object.setPrototypeOf(Cat.prototype, Animal.prototype)
```



#### 方式三：Object.create

> 创建一个新的对象，作为子类的原型对象

```js
function create(parentPrototype) {
  function Fn(){}
  Fn.prototype = parentPrototype // 借用父类原型对象
  let obj = new Fn()
  obj.constructor = Cat // 实例上增加 constructor ，就不会继续向上找
  return obj
}
Cat.prototype = create(Animal.prototype)
```



### 类的静态方法

```js
funcion Animal(name) {
  this.name = name
}

function Cat() {
  Animal.apply(this, arguments)
}
```



### ES6 的类

- super 的指向一：在 constructor 和 static 中指向父类
- 指向二：在子类原型方法中指向父类原型

```js
class Animal {
  constructor(name) {
    this.name = name
  }
  
  // 实例上的属性和方法
  age = 18 
  sleep(){
    return this.age
  }
  
  // 类的属性访问器 get，相当于是 Animal.prototype.eat
	// 本来是方法，加了 set 就是变成了属性
  get eat() {
    return true
  }
  set eat(value) {
  	console.log(value)
  }

	static get a() {
    return '静态属性的变相实现'
  }
  
  // 静态方法
  static say(){
    console.log('通过类名.方法使用, Animal.say()')
  }
}

// extends 相当于使用 call + Object.create
// 还增加了 子类.__proto__ = 父类，所以继承了静态方法
class Cat extends Animal {
  // 若没有 constructor 默认使用父类的
  constructor(name) {
    super(name) // 指向父类，默认里面的 this 就是子类
  }
  
  say() {
    super.say() // 等于 父类.prototype.say
  }
  
  statci fn() {
    super.a
  }
}

let c = new Cat

```




