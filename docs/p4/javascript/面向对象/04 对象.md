# 理解对象

> JS 中的对象是动态的，也就是在代码执行的任意时刻都可能发生改变。
>
> 其他基于类的语言，会根据类的定义去锁定对象。



## 对象创建

基本上有4种方式

### 字面量方式

```js
// 定义对象
const obj = {
    name:'wjy',
    age:24,
    fn:()=>{}
}

// 创建10000个对象，要 cv 10000遍， 并根据需要修改每个对象
```



### 工厂方式

用配置的方式来生成不一样的对象。

本质上来说并没有改变内存的开销，创建10000个对象，跟上面 CV 的内存开销没有区别

```js
// 定义创建对象的工厂方法
function createObj(name, age) {
  return {
    name,
    age,
    fn:()=>{}
  }
}

// 创建对象
const obj = createObj('wjy', 24)
```



### Object.create 方式

以某对象为原型，来创建新对象（空对象）的方式。

创建出来的新实例，通过 `__proto__`指针可以读写原型对象中的属性值和方法。

隐患也就是可以通过原型指针去修改源对象中的数据，有安全隐患

```js
// 1 定义一个对象，作为后面实例的原型对象
const obj = {
  name:'wjy',
  age:24,
  fn:()=>{}
}
// 2 使用 Object.create(obj) 是创建空对象，但是把原型指向了源对象 obj
// 这样的行为，让创建出来的新实例，可以用 obj 里的东西（作为共享池）
let A = Object.create(obj) // A={}
let B = Object.create(obj) // B={}

// 3 实例读写原型对象的属性值和方法
A.__proto__ // 指向的就是 obj 对象
Object.getPrototypeOf(A) // 新标准建议用这个 API 取代上面的原型指针

// 4 使用实例自己的属性值和方法
A.name = 'wjy'
```



### 构造函数方式

定义在原型上的变量或方法的意义（就是在 `object.prototype` 上）

是所有创建出来的实例都可以用这个方法，不用在每个实例内部创建，也不占内存。



这里又要强调 new 操作符底层的行为：

- 创建`空对象 {}`， 与使用 `Object.create()` 效果一致

- 将该空对象的原型(`newObj.__proto__`) 指向构造函数的原型对象（`fn.prototype`）

- 绑定 this 关键字到当前的空对象

- 执行构造函数内部代码，完毕后返回对象实例

```js
// 1 定义构造函数， this 指向实例
function Obj(name, age) {
  this.name = name
  this.age = age
}
// 2 在原型对象上增加一个方法
Obj.prototype.fn = () => console.log('原型对象的共享方法执行')

// 3 创建实例
let A = new Obj('wjy', 23)
A.fn() // 原型对象的共享方法执行
```



## 对象继承

父对象的定义和使用

```js
// 1 构造方法
function Obj1(name, age) {
  this.name = name
  this.age = age
}
// 2 增加原型方法
Obj1.prototype.fn = () => console.log('原型对象的共享方法执行')

// 3 创建实例
let A = new Obj1('wjy', 12)
```



子对象继承：现在想要扩展这个对象属性，增加一个属性，就要使用继承的方式

```js
// 1 定义构造函数
funtion Obj2(name, age, gender) {
  // 2 改变 Obj1 的 this 指向 Obj2
  // 这样等于是去调用父对象的构造方法，但是环境是在本对象中
  Obj1.call(this, name, age) 
  this.gender = gender // 3 Obj2 扩展的属性值
}

// 2 将子对象的原型指向父对象的原型对象（该 create API 返回的是空对象）
Obj2.prototype = Object.create(Obj1.prototype)

// 3 修正构造函数的指向为自己
// 因为上面原型指向了Obj1，此时构造函数指向的是Obj1的构造函数
// 所以要修正构造函数指向为 Obj2 自己
Obj2.prototype.constructor = Obj2

// 4 创建实例
let B = new Obj2('wjy', 23, 'man')
B.fn() // 可以调用父亲的方法
```





## 对象的自有属性 [[put]] 和 [[set]]

对象的创建有2种方式，那么属性的定义也有两种

```js
let obj1 = {
  name:'wjy'
}
let obj2 = new Object()
obj2.name = 'wjy2'
```

当一个属性第一次被设置到对象上时，会调用 `[[put]]方法`，表示该属性仅属于该对象实例（用于区别原型对象的属性）

当该属性被第二次修改时，会调用`[[set]]`方法



## 属性探测

### if 语句判断对象属性是否存在的边界

在判断对象是否有某个属性之前，要搞清楚 JS 的 if 对于不同的数据会做出怎样的判断

- 真。对象、非空字符、非零数字、true
- 假。null、Undefined、0、false、NaN、''

```js
if (express){
	// do
}
```



### in 操作符判断自有和原型属性

> 就是在哈希表汇总查找一个键是否存在，也就是在给定对象中找一个给定名称的属性

```js
let obj = {
  name:'123',
  fn:function(){}
}

'123' in obj // true
'fn' in obj // true 方法相当于一个对象的属性值
```



### hasOwnProperty 方法判断自有属性

in 操作符可以同时判断对象的自由属性和原型属性。有时候我们就像判断是否是自有属性，就要用 `hasOwnProperty`方法

```js
obj.hasOwnProperty('toString') // false
```



## 删除属性 delete 和 [[Delete]]

删除对象的属性不能仅仅是将值改为 `null`，这样只是调用了 `[[set]]`方法，改了一个新值而已。

要彻底删除对象的属性，要调用 `delete` 操作符，底层调用的是 `[[Delete]]`，移除对象的一个键值对。

```js
let obj = {name:'wjy'}
delete obj.name

obj.name // 访问一个不存在的属性，返回的是 undefined
```



## 属性枚举

- 所有添加的属性都是默认可枚举，也就是可以用`for-in`循环遍历他们。这些可枚举的属性内部，其`[[Enumerable]]`都被设置为了 `true`
- 很多对象的原生默认属性都是不可枚举的

```js
// 用 propertyIsEnumerable 检测属性是否可枚举
obj.propertyIsEnumerable('length')
```



### for...in... 遍历可枚举属性

```js
for(let property in obj){
  // obj[attr]
}
```



### Object.keys 获取可枚举属性名的数组

该方法与 `for-in`的区别是，后者还会遍历`原型属性`

```js
Object.keys(obj)
```



## 属性类型

JS 对象的属性也有两种类型

- 数据属性：就是一个普通的值
- 访问器属性：定义了数据被读取时调用的 `getter`或`setter`方法



用字面量形式定义访问器属性有特殊的语法：

```js
let obj = {
  // 业界的约定，作为私有属性。但是在语言层面还是公开的。
  _name:'wjy',
  // get 关键字
  get name(){
    return this._name
  }
  // set 关键字
  set name(value) {
    this._name = value
  }
}
```

getter 或 setter 访问器若只写其中一个也是可以的，这样的话该属性就是只读/只写



## 属性特征

### 通用特征

数据属性和访问器属性在声明时，都默认拥有 `[[Enumerable]]`和`[[Configurable]]`两个特征。

- `[[Configurable]]`

表示该属性是可配置的，也就是可以切换该属性是数据 / 访问器类型。

- `Object.defineProperty(obj, property, config)` 改变对象属性的特征

```js
Object.defineProperty(obj, 'name', {
  enumerable:false,
  configurable:false // 不可配置。一旦设置，后面就无法修改回 true 了
})
```



### 数据属性特征

数据属性比访问器属性多2个特征

- `[[Value]]`属性的值
- `[[Writable]]`布尔值，表示该属性是否可写。
  - 默认情况都是可写的

```js
let obj = {}

// 若是给一个新属性定义，则要把这4个特征写全了
Object.difineProperty(obj, 'name', {
  value:'wjy',
  enumerable:true,
  configurable:true,
  weitable:true
})
```



### 访问器属性特征

- `[[Get]]`和`[[Set]]`就是访问器属性特有的特征。内含 `getter`和`setter`方法
- 因为访问器属性不需要存储值，也就没有 value 和 writable 这2个特征

```js
let obj = {
  name:'wjy'
}

Object.defineProperty(obj, 'name', {
  get:function(){},
  set:function(){},
  enumerable:true,
  configurable:true
})
```



### 定义多重属性 Object.defineProperties

接受2个参数，一个是对象，另一个是哈希表（同时定义多个属性）

```js
Object.defineProperties(obj, {
  // 数据属性声明
  _name:{
    value:'wjy',
    enumerable:true,
    configurable:true,
    writable:true
  },
  // 访问器属性声明
  name: {
    get:function(){},
    set:function(){},
    enumerable:true,
    configurable:true
  }
})
```



### 获取属性特征 Object.getOwnPropertyDescriptor

> 该方法只能用于自有属性。
>
> 有2个参数，对象和属性名
>
> 若属性存在，返回该属性的4个特征描述

```js
Object.getOwnPropertyDescriptor(obj, 'name')
```



## 禁止修改对象 [[Extensible]]

对象本身也有一个 `[[Extensible]]`表示该对象是否可被修改。

- 创建的对象默认都是可扩展的，也就是可以随时增加属性
- 若 [[extensible]] 设置为 false，则能禁止新属性的增加



### 禁止扩展 Object.preventExtensions

该方法用于创建一个不可扩展的对象，就不能给该对象增加属性了

```js
Object.preventExtensions(obj) // obj 对象无法被扩展
```

- 用`Object.isExtensible`检查 `[[extensible]]`的值

```js
Object.isExtensible(obj)
```



### 封印对象 Object.seal

该方法调用后

- 对象`[[extensible]]`设置为 false，对象无法被扩展。即无法增删属性
- 所有属性`[[configurable]]`设置为 false，不能改变其类型（数据< - >访问器属性）
- 属性只能读写。也就是能改变数据属性的值，或者访问器属性的set、get

```js
Object.seal(obj) // 封印对象
Object.isSeal(obj) // 判断是否被封印
```



### 冻结对象 Object.freeze

无法增删属性，无法改变属性类型，也不能写入任何数据属性。—— 数据属性都为只读的被封印对象，且无法解冻。

```js
Object.freeze(obj) // 冻结对象
Object.isFreeze(obj) // 检查是否被冻结 true
Object.isSeal(obj) // 是否被封印，true
Object.isExtensible(obj) // 是否能扩展 false
```

