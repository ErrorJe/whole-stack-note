# 四、理解对象

> JS 中的对象是动态的，也就是在代码执行的任意时刻都可能发生改变。
>
> 其他基于类的语言，会根据类的定义去锁定对象。

### 1 对象的自有属性 [[put]] 和 [[set]]

对象的创建有2种方式，那么属性的定义也有两种

```js
let obj1 = {
  name:'wjy'
}
let obj2 = new Object()
obj2.name = 'wjy2'
```

当一个属性第一次被设置到对象上时，会调用 `[[put]]方法`，表示该属性仅属于该对象实例（用于区别原型对象的属性）

当该属性被第二次修改时，会调用`[[set]]`方法



### 2 属性探测

#### 1）if 语句判断对象属性是否存在的边界

在判断对象是否有某个属性之前，要搞清楚 JS 的 if 对于不同的数据会做出怎样的判断

- 真。对象、非空字符、非零数字、true
- 假。null、Undefined、0、false、NaN、''

```js
if (express){
	// do
}
```

#### 2）in 操作符判断自有和原型属性

> 就是在哈希表汇总查找一个键是否存在，也就是在给定对象中找一个给定名称的属性

```js
let obj = {
  name:'123',
  fn:function(){}
}

'123' in obj // true
'fn' in obj // true 方法相当于一个对象的属性值
```

#### 3）hasOwnProperty 方法判断自有属性

in 操作符可以同时判断对象的自由属性和原型属性。有时候我们就像判断是否是自有属性，就要用 `hasOwnProperty`方法

```js
obj.hasOwnProperty('toString') // false
```



### 3 删除属性 delete 和 [[Delete]]

删除对象的属性不能仅仅是将值改为 `null`，这样只是调用了 `[[set]]`方法，改了一个新值而已。

要彻底删除对象的属性，要调用 `delete` 操作符，底层调用的是 `[[Delete]]`，移除对象的一个键值对。

```js
let obj = {name:'wjy'}
delete obj.name

obj.name // 访问一个不存在的属性，返回的是 undefined
```



### 4 属性枚举

- 所有添加的属性都是默认可枚举，也就是可以用`for-in`循环遍历他们。这些可枚举的属性内部，其`[[Enumerable]]`都被设置为了 `true`
- 很多对象的原生默认属性都是不可枚举的

```js
// 用 propertyIsEnumerable 检测属性是否可枚举
obj.propertyIsEnumerable('length')
```

#### 1）for...in... 遍历可枚举属性

```js
for(let property in obj){
  // obj[attr]
}
```

#### 2）Object.keys 获取可枚举属性名的数组

该方法与 `for-in`的区别是，后者还会遍历`原型属性`

```js
Object.keys(obj)
```



### 5 属性类型

JS 对象的属性也有两种类型

- 数据属性：就是一个普通的值
- 访问器属性：定义了数据被读取时调用的 `getter`或`setter`方法



用字面量形式定义访问器属性有特殊的语法：

```js
let obj = {
  // 业界的约定，作为私有属性。但是在语言层面还是公开的。
  _name:'wjy',
  // get 关键字
  get name(){
    return this._name
  }
  // set 关键字
  set name(value) {
    this._name = value
  }
}
```

getter 或 setter 访问器若只写其中一个也是可以的，这样的话该属性就是只读/只写



### 6 属性特征

#### 1）通用特征

数据属性和访问器属性在声明时，都默认拥有 `[[Enumerable]]`和`[[Configurable]]`两个特征。

- `[[Configurable]]`

表示该属性是可配置的，也就是可以切换该属性是数据 / 访问器类型。

- `Object.defineProperty(obj, property, config)` 改变对象属性的特征

```js
Object.defineProperty(obj, 'name', {
  enumerable:false,
  configurable:false // 不可配置。一旦设置，后面就无法修改回 true 了
})
```

#### 2）数据属性特征

数据属性比访问器属性多2个特征

- `[[Value]]`属性的值
- `[[Writable]]`布尔值，表示该属性是否可写。
  - 默认情况都是可写的

```js
let obj = {}

// 若是给一个新属性定义，则要把这4个特征写全了
Object.difineProperty(obj, 'name', {
  value:'wjy',
  enumerable:true,
  configurable:true,
  weitable:true
})
```

#### 3）访问器属性特征

- `[[Get]]`和`[[Set]]`就是访问器属性特有的特征。内含 `getter`和`setter`方法
- 因为访问器属性不需要存储值，也就没有 value 和 writable 这2个特征

```js
let obj = {
  name:'wjy'
}

Object.defineProperty(obj, 'name', {
  get:function(){},
  set:function(){},
  enumerable:true,
  configurable:true
})
```

#### 4）定义多重属性 Object.defineProperties

接受2个参数，一个是对象，另一个是哈希表（同时定义多个属性）

```js
Object.defineProperties(obj, {
  // 数据属性声明
  _name:{
    value:'wjy',
    enumerable:true,
    configurable:true,
    writable:true
  },
  // 访问器属性声明
  name: {
    get:function(){},
    set:function(){},
    enumerable:true,
    configurable:true
  }
})
```

#### 5）获取属性特征 Object.getOwnPropertyDescriptor

> 该方法只能用于自有属性。
>
> 有2个参数，对象和属性名
>
> 若属性存在，返回该属性的4个特征描述

```js
Object.getOwnPropertyDescriptor(obj, 'name')
```



### 7 禁止修改对象 [[Extensible]]

对象本身也有一个 `[[Extensible]]`表示该对象是否可被修改。

- 创建的对象默认都是可扩展的，也就是可以随时增加属性
- 若 [[extensible]] 设置为 false，则能禁止新属性的增加

#### 1）禁止扩展 Object.preventExtensions

该方法用于创建一个不可扩展的对象，就不能给该对象增加属性了

```js
Object.preventExtensions(obj) // obj 对象无法被扩展
```

- 用`Object.isExtensible`检查 `[[extensible]]`的值

```js
Object.isExtensible(obj)
```

#### 2）封印对象 Object.seal

该方法调用后

- 对象`[[extensible]]`设置为 false，对象无法被扩展。即无法增删属性
- 所有属性`[[configurable]]`设置为 false，不能改变其类型（数据< - >访问器属性）
- 属性只能读写。也就是能改变数据属性的值，或者访问器属性的set、get

```js
Object.seal(obj) // 封印对象
Object.isSeal(obj) // 判断是否被封印
```

#### 3）冻结对象 Object.freeze

无法增删属性，无法改变属性类型，也不能写入任何数据属性。—— 数据属性都为只读的被封印对象，且无法解冻。

```js
Object.freeze(obj) // 冻结对象
Object.isFreeze(obj) // 检查是否被冻结 true
Object.isSeal(obj) // 是否被封印，true
Object.isExtensible(obj) // 是否能扩展 false
```

