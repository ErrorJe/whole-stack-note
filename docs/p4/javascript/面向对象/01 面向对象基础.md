# 面向对象基础

> 内容基于《Javacript 面向对象精要》

## 面向对象语言

如 JAVA 等都是面向对象的语言，而 JS 在严格意义上来说并不算是。但是 JS 可以去实现面向对象。

只是传统面向对象的语言是基于类的，JS 不使用类，而是用原型。



### 面向对象的特性

- 封装：数据和操作数据的功能组织在一起

- 继承：新创建的对象和另一个对象拥有同样的特性，而无需显式地复制功能

- 多态：一个接口可被多个对象实现

- 聚合：一个对象能够引用另一个对象，父类的通用行为可以被子类用更特殊的行为重
  写  



### 基于类的面向对象（java）

一些人误认为的模拟面向对象，实际上 JS 就是面向对象语言

基于类的编程语言，关注“分类”和“类之间的关系”开发模型。

- 抽象出一个类，然后去实例化一个对象。
- 类之间可能有继承和组合等关系

```js
class Student // 学生类（抽象学生特性的类）
Object student = new Student('wjy') // 学生类的实例对象（指代具体的某个学生）
```



#### 类和实例

类（抽象）。不能直接使用实例上的方法 `arr.push()`。但是类上有静态方法，可以直接使用如 `Array.isArray()`

```js
Array.push() // .push 是实例方法，不能直接用
Array.isArray() // 这是类的静态方法，可以直接用
```

实例对象（具体）。不能作为抽象模板去创建别的对象

```js
new arr() //  是没有意义的
```





### 基于原型的面向对象（js）

与其他编程语言不同，Js 没有类、实例的概念。JS通过 `原型(prototype)` 来实现面向对象编程。所有对象都是实例，其继承关系就是一个对象的原型指向另一个对象。



基于原型的编程语言（JS）， 关注一系列“实例对象的行为”

- 照猫画虎。不是去分类，而是将对象指向行为相似的原型对象上
- 通过“复制”的方式来创建新对象，复制一般有两种操作
  - 让新对象持有一个原型的引用（JS选择的是这种）
  - 复制对象，两个对象再无关联



#### 类是设计模式

类只是面向对象编程设计模式中的一种实现，并不是必须的，起码在 JS 中是这样。

但是在一些语言如 JAVA，必须基于类，不给你选择空间。



#### 行为委托

> JS 其实也是一种面向对象的语言，只是他有两种方式去实现类的概念。
>
> JS 的弱类型可以用更少的代码实现功能。

在 JS 中，解决委托 `[[prototype]]` 实现对象关联

抛弃了类的概念和基于类的继承，转向基于原型的继承和功能类似的构造函数。

##### 面向对象风格

```js
// 1 父类
function Foo(who) {
  this.me = who;
}
Foo.prototype.identify = function () {
  return "I am " + this.me;
};

// 2 子类
function Bar(who) {
  Foo.call(this, who);
}

// 将子类委托于父类
Bar.prototype = Object.create(Foo.prototype);
Bar.prototype.speak = function () {
  alert("Hello, " + this.identify() + ".");
};
var b1 = new Bar("b1");
var b2 = new Bar("b2");
b1.speak();
b2.speak();
```



##### 对象关联风格

几乎所有 JS 数据类型要么是一个对象，要么是从对象中获取的，连函数（一等公民）都是一个对象。

```js
// 功能与上面的完全一样
// 但更加清晰

// 1 定义对象
Foo = {
  init: function (who) {
    this.me = who;
  },
  identify: function () {
    return "I am " + this.me;
  }
};

// 2 委托于 Foo 对象
Bar = Object.create(Foo);
Bar.speak = function () {
  alert("Hello, " + this.identify() + ".");
};

// 3 b1 委托于 Bar
var b1 = Object.create(Bar);
b1.init("b1");
// 4 b2 委托于 Bar
var b2 = Object.create(Bar);
b2.init("b2");
b1.speak();
b2.speak();
```



#### 类和原型继承的区别

- 类继承，所有的东西都来自于父类或者更高的基类，然后自己做扩展。

- 原型继承，只是从别人的身上去模仿了它的特性。



## 解决高耦合

> OOP 就是最简单来说就是单一职责。写代码时的低耦合高内聚
>
> 耦合就是多个模块，文件都会用到同一个东西。

### 避免全局耦合

一个参数，被定义成全局变量，需要在多个文件中去使用。这样带来的问题

- 全局变量污染
- 难以维护
- 容易被修改

#### 层次1：Head 中定义全局变量

这里定义的全局变量，可以在其后引入的文件中直接使用。

这样都 HTML 和 JS 文件中都使用了这个变量。

```html
<head>
  <script>
    var PAGE = 20
  </script>
  <script src="main.js"></script>
</head>
```

还有一种方式，是把值存在 form 表单中，然后 type 用的是 hidden，同时若数据中有特殊字符可以用 textarea（使用序列化的方法拿到数据）

```html
<form>
    <input type="hidden" name="PAGE" value="2">
    <textarea name="LIST" style="display:none">[{"username":"yin"}, {}]</textarea>
</form>
```



#### 层次2：模块化

> 以下示例是采用 CommonJS 模块化规范。
>
> 四个模块各司其职，但还是全局耦合了，因为4个文件用的 data 都是同一个对象，也不知道是谁会去修改它。

```js
// 1 data.js 专门放参数的文件
module.exports = {
  houseList: null
}

// 2 search.js 获取 houseList 的数据， 并修改其值
// 这里能改变 data 的值，也是不安全的
var data = require("data")
data.houseList = ajax()
require("format-data").format()

// 3 format-data.js 对 houseList 做数据格式化
function format() {
  var data = require("data")
  process(data)
  require("show-result").show()
}

// 4 show-result.js 显示数据，即使用数据
function show() {
  showData(require("data").houseList)
}
```



#### 层次3：降低耦合度，参数请求的方式或者使用常量

> 就是屏蔽直接操作原数据，把数据参数放在后端

```js
// 1 data.js 不在需要

// 2 search.js 获取 houseList 的数据， 并修改其值
// 这里能改变 data 的值，也是不安全的
var houseList = ajax() // 获取数据
require("format-data").format(houseList) //  传给下一个模块

// 3 format-data.js 对 houseList 做数据格式化
function format(houseList) {
  process(houseList)
  require("show-result").show(houseList)
}

// 4 show-result.js 使用数据
function show(houseList) {
  showData(houseList)
}
```

当然也可以使用 const 去定义参数，这样就不能被修改了

```js
// 1 data.js 专门放参数的文件
const PAGE = 1
module.exports = { PAGE }
```



### HTML/CSS/JS 的耦合

> 除了动态渲染的部分(如监听 scroll 和 mousemove 事件），不要在 JS 中直接操作样式，采用的手段应该是“增删”元素的样式类

```js
// jq 来切换样式类
$(".bar").addClass("fixed") // 增加 fixed 样式类
$(".bar").removeClass("fixed") // 取消 fixed 样式类
```



## 实现低内聚

> 高内聚，就是一个功能模块不可分割，职责十分紧密。
>
> 从层次来说，封装的层次为：重复代码 -> 封装成函数 -> 封装成模块 -> 封装成插件



### 高内聚第一步：减少重复代码



#### 完全不处理的代码

```js
// 完全哪里用到随即写的代码
$("#id").on("click", () => {
  var params = getData() // 1 获取参数
  $.ajax({ // 2 请求数据获取数据
    // options
    success:(data) => {
      doSomething(data) // 2 使用数据
    }
  })
})

// 当出现类似的事件方法，完全重写代码
$("input").on("change", () => {
  changeShow() // 1 改变页面显示
  var params = getData() // 2 获取参数
  $.ajax({ // 3 请求数据获取数据
    // options
    success:(data) => {
      doSomething(data) // 4 使用数据
    }
  })
})
```



#### 抽离重复代码为独立方法

```js
// 重复代码抽离为方法
function getAndShowData() {
  var param = getData() // 1 获取参数
  $.ajax() // 2 请求并使用数据
}


// 改变原有代码方式
$("#id").on("click", getAndShowData()))
$("input").on("change", () => {
  changeShow() // 3 改变页面显示
  getAndShowData()
})
```



#### 继续抽离为模块

```js
// es5 的封装方式
function C($container) {
  this.$container = $container // 外部容器
  this.$date = null // 基本数据存放
  this.show() // 实例化后得到的方法
}

// 原型方法, 加上传入的2个参数，和$date 相当于用到了3个参数
C.prototype.setDate = function(p1, p2) {
  p2 = typeof time === "undefined" ? 100 : time
  this.$date = p1/p2
}

// ES6 直接使用 Class 关键字封装类，比较方便，但是本质是一样的
```



### 编程语言的面向对象

面向对象开发 -> 类的继承、封装和多态。

- 封装：将复用性高的代码放在一起
- 继承：子类继承父类中的属性和方法
- 多态：当前方法的多种形态。后台语言中，多态包含（重载和重写）
  - 重载：方法名相同，参数不一样。包括数量和数据类型
  - 重写：子类重写父类的方法（覆盖原有方法）

```java
// JAVA 多态
public void sum(int num1, int num2){}
public void sum(string str1, int num2){}
sum(1); // 第一个
sum('1'); // 第二个
```

JS中不存在重载，但是可以说存在多态（有重写），方法名一样，后面的覆盖前面的

```js
// JS 代码。在预处理阶段，就覆盖了重名方法
function sum(num1, num2){}
function sum(num1) {} // 覆盖了上面的重名方法
sum(1,2) // 只有第一个参数被读到
```

JS中可以根据参数不一样，实现不同的功能，来模仿重载（并不是重载）。

```js
// JS 参数传与不传的不同处理
function sum(num){
  if(typeof num==='undefined'){return 0}
  return num
}
sum(100)
sum()
```



## ES3 及以前

在早些版本，类的定义是一个`私有属性[[class]]`

类的概念是很弱的，仅仅是运行时的一个 `字符串属性`

只能通过 `Object.prototype.toString()` 来访问这个私有属性

```js
var o = new Object;
var n = new Number;
var s = new String;
var b = new Boolean;
var d = new Date;
var arg = function(){ return arguments }();
var r = new RegExp;
var f = new Function;
var arr = new Array;
var e = new Error;
console.log([o, n, s, b, d, arg, r, f, arr, e].map(v => Object.prototype.toString.call(v))); 
// 直接使用 v.toString 就是打印这些默认值的字符化结果
console.log([o, n, s, b, d, arg, r, f, arr, e].map(v => v.toString()));  
```



输出结果

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200120134531.png)





## ES5 的类

在 ES6 之前都用 `构造函数` 来充当类

现在也很少使用类，包括 `vue`， `react` 都使用函数式，类还是有不少缺陷的。



### Symbol.toStringTag 属性

从ES5开始，`[[class]]` 私有属性被 `Symbol.toStringTag` 代替。

且可以修改 `Object.prototype.toString()` 的行为

```js
// 新对象，只有一个属性，会对下面触发的方法产生影响。将对象类型从Object改为了MyObject
var o = { [Symbol.toStringTag]: "MyObject" }
// 字符串 + 运算，触发对Object.prototype.toString()的调用
console.log(o + ""); // [object MyObject]
```



### 类的缺陷

> vue2 内部没有使用类

- 所有功能和方法都要放到类的内部
- 类只能通过 `new` 来调用



### new 操作符

#### new 作用

new 运算接受一个构造器和一组调用参数，实际上做了这么几件事：

- 以构造器的 `prototype` 属性为原型，创建新对象（空对象 `obj={}`）

- - `obj._proto = Object.create(fn.constructor.prototype)`
  - 区别于 `[[prototype]]` 私有属性

- 将 this 和调用参数传给构造器，执行

- 若构造器返回的是对象，则返回。否则返回第一步创建的对象



#### new 添加属性

提供了两种方法

- 在构造器中添加属性
- 在构造器的 `prototype` 属性上添加属性

```js
// 方法1：直接在构造器中修改 this，给this加属性
function c1(){
  this.p1 = 1;
  this.p2 = function(){
    console.log(this.p1);
  }
} 
var o1 = new c1;
o1.p2();

// 方法2：修改prototype属性指向的对象，它是从这个构造器构造出来的所有对象的原型
function c2(){
}
c2.prototype.p1 = 1;
c2.prototype.p2 = function(){
  console.log(this.p1);
}

var o2 = new c2;
o2.p2();
```



在没有 `Object.create` 和 `Object.setPrototypeOf`  的早期版本中

`new` 运算是唯一可以指定 `[[prototype]] `的方法（当时也可以用私有属性 `__proto__`，但多数环境并不支持）



### 构造函数

构造函数就是当作类

- 类中的 `this` 类型，指向都是产生的实例
  - 特殊情况就是返回一个引用类型（对象、函数、数组），则该返回值会作为实例
- 抽象类：可以被子类继承，但是自己不能被 `new`

```js
function Animal() { 
  // 判断是否经过 new
  if (!(this instanceof Animal)) {
    throw new Error('没有 New')
  }

  // 判断是谁 new 的，保证抽象类无法直接被 new
  if (new.target === Animal) {
    throw new Error('这是抽象类，不能被 new')
  }
}

new Animal // 不传参时，可以省略 ()
```



### 原型链和公共方法

- `__proto__`， 实例对象上有，IE 不能用
- `prototype`， 构造函数上有
  - `a.__proto__ === Animal.prototype `
- `constructor`， 通过实例对象找到类本身，是放在原型上的属性
  - `.__proto__.constructor === Animal`
- `instanceof` 判断实例
  - `a instanceof Animal`

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200115212456.png)

```js
function Animal(name) {
  this.name = name
}

// 实例的公共方法，定义在类的原型上
Animal.prototype.eat = function(){} // prototype 是个对象

// 每次new都会创建实例
let a = new Animal('a')
// 去实例对象的 __proto__ 上找 eat，没有顺着所属类的 prototype 找，没有再继续顺着上级类找
console.log(a.eat())  // 先找自己的
a.__proto__.eat() // 找所属类原型上的
a.__proto__.constructor.prototype.__proto__.eat() // 原型链继续找
```



### 类的静态方法

- 静态方法是 `类.方法`
- 原型方法是 `实例.方法`

```js
funcion Animal(name) {
  this.name = name
}

function Cat() {
  Animal.apply(this, arguments)
}

// 实际上就是在 Animal 函数上写了一个方法
Animal.Cat = function(){}
```



## ES6 的类

- super 的指向一：在 constructor 和 static 中指向父类
- 指向二：在子类原型方法中指向父类原型

```js
class Animal {
  constructor(name) {
    this.name = name
  }
  
  // 1 实例上的属性和方法
  age = 18 
  sleep(){
    return this.age
  }
  
  // 2 类的属性访问器 get，相当于是 Animal.prototype.eat
	// 本来是方法，加了 set 就是变成了属性
  get eat() {
    return true
  }
  set eat(value) {
  	console.log(value)
  }

	static get a() {
    // 3
    return '静态属性的变相实现'
  }
  
  // 4 静态方法
  static say(){
    console.log('通过类名.方法使用, Animal.say()')
  }
}

// 5 extends 相当于使用 call + Object.create
// 还增加了 子类.__proto__ = 父类，所以继承了静态方法
class Cat extends Animal {
  // 6 若没有 constructor 默认使用父类的
  constructor(name) {
    super(name) // 7 指向父类，默认里面的 this 就是子类
  }
  
  say() {
    super.say() // 8 等于 父类.prototype.say
  }
  
  statci fn() {
    super.a
  }
}

let c = new Cat

```







