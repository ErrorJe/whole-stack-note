# 面向对象基础

> 内容基于《Javacript 面向对象精要》

## 面向对象语言

如 JAVA 等都是面向对象的语言，而 JS 在严格意义上来说并不算是。但是 JS 可以去实现面向对象。

只是传统面向对象的语言是基于类的，JS 不使用类，而是用原型。



### 面向对象的特性

- 封装：数据和操作数据的功能组织在一起

- 继承：新创建的对象和另一个对象拥有同样的特性，而无需显式地复制功能

- 多态：一个接口可被多个对象实现

- 聚合：一个对象能够引用另一个对象，父类的通用行为可以被子类用更特殊的行为重
  写  



### 2 JS 的面向对象

JS 的弱类型可以用更少的代码实现功能。

抛弃了类的概念和基于类的继承，转向基于原型的继承和功能类似的构造函数。

几乎所有 JS 数据类型要么是一个对象，要么是从对象中获取的，连函数（一等公民）都是一个对象。

#### 1）类是设计模式

类只是面向对象编程设计模式中的一种实现，并不是必须的，起码在 JS 中是这样。

但是在一些语言如 JAVA，必须基于类，不给你选择空间。

#### 2）行为委托

在 JS 中，解决委托 [[prototype]] 实现对象关联

- 面向对象风格

```js
// 1 父类
function Foo(who) {
  this.me = who;
}
Foo.prototype.identify = function () {
  return "I am " + this.me;
};

// 2 子类
function Bar(who) {
  Foo.call(this, who);
}

// 将子类委托于父类
Bar.prototype = Object.create(Foo.prototype);
Bar.prototype.speak = function () {
  alert("Hello, " + this.identify() + ".");
};
var b1 = new Bar("b1");
var b2 = new Bar("b2");
b1.speak();
b2.speak();
```

- 对象关联风格

```js
// 功能与上面的完全一样
// 但更加清晰

// 1 定义对象
Foo = {
  init: function (who) {
      this.me = who;
    },
    identify: function () {
      return "I am " + this.me;
    }
};

// 2 委托于 Foo 对象
Bar = Object.create(Foo);
Bar.speak = function () {
  alert("Hello, " + this.identify() + ".");
};

// 3 b1 委托于 Bar
var b1 = Object.create(Bar);
b1.init("b1");
// 4 b2 委托于 Bar
var b2 = Object.create(Bar);
b2.init("b2");
b1.speak();
b2.speak();
```



## （二）解决高耦合

> OOP 就是最简单来说就是单一职责。写代码时的低耦合高内聚
>
> 耦合就是多个模块，文件都会用到同一个东西。

### 1 避免全局耦合

一个参数，被定义成全局变量，需要在多个文件中去使用。这样带来的问题

- 全局变量污染
- 难以维护
- 容易被修改

#### 1）层次1：Head 中定义全局变量

这里定义的全局变量，可以在其后引入的文件中直接使用。

这样都 HTML 和 JS 文件中都使用了这个变量。

```html
<head>
    <script>
        var PAGE = 20
    </script>
    <script src="main.js"></script>
</head>
```

还有一种方式，是把值存在 form 表单中，然后 type 用的是 hidden，同时若数据中有特殊字符可以用 textarea（使用序列化的方法拿到数据）

```html
<form>
    <input type="hidden" name="PAGE" value="2">
    <textarea name="LIST" style="display:none">[{"username":"yin"}, {}]</textarea>
</form>
```

#### 2）层次2：模块化

> 以下示例是采用 CommonJS 模块化规范。
>
> 四个模块各司其职，但还是全局耦合了，因为4个文件用的 data 都是同一个对象，也不知道是谁会去修改它。

```js
// 1 data.js 专门放参数的文件
module.exports = {
    houseList: null
}

// 2 search.js 获取 houseList 的数据， 并修改其值
// 这里能改变 data 的值，也是不安全的
var data = require("data")
data.houseList = ajax()
require("format-data").format()

// 3 format-data.js 对 houseList 做数据格式化
function format() {
    var data = require("data")
    process(data)
    require("show-result").show()
}

// 4 show-result.js 显示数据，即使用数据
function show() {
    showData(require("data").houseList)
}
```

#### 3）层次3：降低耦合度，参数请求的方式或者使用常量

> 就是屏蔽直接操作原数据，把数据参数放在后端

```js
// 1 data.js 不在需要

// 2 search.js 获取 houseList 的数据， 并修改其值
// 这里能改变 data 的值，也是不安全的
var houseList = ajax() // 获取数据
require("format-data").format(houseList) //  传给下一个模块

// 3 format-data.js 对 houseList 做数据格式化
function format(houseList) {
    process(houseList)
    require("show-result").show(houseList)
}

// 4 show-result.js 使用数据
function show(houseList) {
    showData(houseList)
}
```

当然也可以使用 const 去定义参数，这样就不能被修改了

```js
// 1 data.js 专门放参数的文件
const PAGE = 1
module.exports = { PAGE }
```



### 2 HTML/CSS/JS 的耦合

> 除了动态渲染的部分(如监听 scroll 和 mousemove 事件），不要在 JS 中直接操作样式，采用的手段应该是“增删”元素的样式类

```js
// jq 来切换样式类
$(".bar").addClass("fixed") // 增加 fixed 样式类
$(".bar").removeClass("fixed") // 取消 fixed 样式类
```



## （三）实现低内聚

> 高内聚，就是一个功能模块不可分割，职责十分紧密。
>
> 从层次来说，封装的层次为：重复代码 -> 封装成函数 -> 封装成模块 -> 封装成插件

### 1 高内聚第一步：减少重复代码

#### 1）完全不处理的代码

```js
// 完全哪里用到随即写的代码
$("#id").on("click", () => {
    var params = getData() // 1 获取参数
    $.ajax({ // 2 请求数据获取数据
        // options
        success:(data) => {
            doSomething(data) // 2 使用数据
        }
    })
})

// 当出现类似的事件方法，完全重写代码
$("input").on("change", () => {
    changeShow() // 1 改变页面显示
    var params = getData() // 2 获取参数
    $.ajax({ // 3 请求数据获取数据
        // options
        success:(data) => {
            doSomething(data) // 4 使用数据
        }
    })
})
```

#### 2）抽离重复代码为独立方法

```js
// 重复代码抽离为方法
function getAndShowData() {
    var param = getData() // 1 获取参数
    $.ajax() // 2 请求并使用数据
}


// 改变原有代码方式
$("#id").on("click", getAndShowData()))
$("input").on("change", () => {
    changeShow() // 3 改变页面显示
    getAndShowData()
})
```

#### 3）继续抽离为模块

```js
// es5 的封装方式
function C($container) {
    this.$container = $container // 外部容器
    this.$date = null // 基本数据存放
    this.show() // 实例化后得到的方法
}

// 原型方法, 加上传入的2个参数，和$date 相当于用到了3个参数
C.prototype.setDate = function(p1, p2) {
    p2 = typeof time === "undefined" ? 100 : time
    this.$date = p1/p2
}

// ES6 直接使用 Class 关键字封装类，比较方便，但是本质是一样的
```



### 2 编程语言的面向对象

面向对象开发 -> 类的继承、封装和多态。

- 封装：将复用性高的代码放在一起
- 继承：子类继承父类中的属性和方法
- 多态：当前方法的多种形态。后台语言中，多态包含（重载和重写）
  - 重载：方法名相同，参数不一样。包括数量和数据类型
  - 重写：子类重写父类的方法（覆盖原有方法）

```java
// JAVA 多态
public void sum(int num1, int num2){}
public void sum(string str1, int num2){}
sum(1); // 第一个
sum('1'); // 第二个
```

JS中不存在重载，但是可以说存在多态（有重写），方法名一样，后面的覆盖前面的

```js
// JS 代码。在预处理阶段，就覆盖了重名方法
function sum(num1, num2){}
function sum(num1) {} // 覆盖了上面的重名方法
sum(1,2) // 只有第一个参数被读到
```

JS中可以根据参数不一样，实现不同的功能，来模仿重载（并不是重载）。

```js
// JS 参数传与不传的不同处理
function sum(num){
  if(typeof num==='undefined'){return 0}
  return num
}
sum(100)
sum()
```

