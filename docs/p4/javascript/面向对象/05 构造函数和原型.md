# 构造函数和原型对象

JS 缺少类（至少 ES6 之前是这样），利用`构造函数`和`原型对象`给对象带来与类相似的功能，但不完全一致。

## 构造函数

> 就是用 new 创建对象时调用的函数。
>
> 用一个构造函数创建的实例都拥有同样的属性和方法。这也是使用它的原因。
>
> 行业约定构造函数首字母大写，就跟私有变量约定首字符为 `_`  一样



### new 操作符

通过`new`调用构造函数创建的 100 个对象实例，独立拥有 100 套变量和方法。这在一些场景显然内存开销过大。我们就要通过原型对象去创建一些共享的变量和方法。



#### 普通函数执行过程

- 创建该函数的`执行上下文`
- 先拿到 `fn` 的私有属性 `arguments` 并且赋值得到 `[100]`
- 然后给形参进行赋值 `x = 100`



到此为止，都是函数默认的行为，后面才开始执行内部代码

- 声明局部（let 作用域限制在函数内，所以没有变量提升），`y = 200`
- 此时因为是直接执行的 fn 函数，所以 `this` 指向的是 `window`，也就是 `window.x = x = 100`
- 最后该函数没有 `return` 东西，默认返回了 `undefined`

```js
function fn(x) {
  let y = 200
  this.x = x
}
let res = fn(100)
console.log(res) // undefined
```



#### new 执行原理

`new` 操作符自动创建给定类型的对象并返回

这些实例都独立拥有构造函数的变量和方法

```js
function Fn(name){
	// 可以声明一些变量和方法
  this.name = name || 'wjy'
  this.sayName = function(){}
  
  // 若这里显式 return 了一个对象，则会返回该对象。return 原始类型是无效的
}

// 创建对象
// 没有参数传入时，可以省略括号
let obj1 = new Fn; 
// 被创建的实例拥有原来在构造函数中的变量和方法
obj1.name // 'wjy'
obj1.sayName()

obj1 instanceof Fn // true
```



##### new 原理

若不用 `new` 调用构造函数，那么原本构造函数中的 this 都是指向全局的，容易出现错误。

- new 首先将普通函数作为`类` 来执行，返回当前类的`实例` （对象类型）
- 也是先创建函数创建新的 `执行上下文`
- 执行与普通函数执行一样的行为

到此为止，跟普通函数执行没有什么区别，接下来 `new` 开始让 `V8 引擎`发挥作用

- V8 引擎默认创建一个`空对象(实例 obj)`，并将其 `__proto__` 指向 `构造函数.prototype`
- V8 引擎把上下文中的 `this` 指向该空对象实例（就是把空对象赋值给构造函数内部的 this）

做完这些事，再开始执行函数中的代码，返回第一步创建的对象或构造函数的显式返回值



##### 案例

- 创建私有变量 `y = 100` （this 都是创建私有属性）
- 执行 `this.x` 时，this 已经指向了上面创建的空对象，且创建私有属性 `x` ，也就是 `obj.x = x = 100`
- V8 判断没有写 `return` 或返回的不是一个`对象类型`的值，就默认把创建的 `实例对象` 返回

```js
function fn(x) {
  let y = 200
  this.x = x
  return 10
}
res = new fn(100) // 根据类 fn 创建实例 res
console.log(res) // 实例对象 res
```



#### 实现 new

要实现的效果

```js
// 原生的 new
let dog = new Dog('汪汪')

// 自己实现的 new
let dog = _new(Dog, '汪汪')
```



##### ES5 版本

```js
function _new(Fn) { // 可以用 ...args 拿到剩下的参数
  // 1 用 ES5 的方式:借用数组原型上的方法，把类数组转为数组
  // 去掉第一个参数，获取剩下的参数数组
  let args = Array.prototype.slice.call(arguments, 1)
  
  // 2 创建空对象，并将原型正确指向
  let obj = {}
  obj.__proto__ = Fn.prototype
  
  // 3 ES6 用法 => Fn(...args)
  // 还是用 ES5 实现：可以把 args 数组一项项传给 Fn
  let res = Fn.apply(obj, args)
  
  // 4 判断是否是引用对象（对象、函数，排除 null），直接返回
  if (res !== null && (typeof res === 'Object' || typeof res === 'function')) {
    return res
  }
  
  // 5 返回空对象实例
  return obj
}
```



##### ES6 版本

- 用 Object.create 将 obj 的 `__proto__ `指向构造函数的原型
- 使用 apply/call 方法，将构造函数内的 this 指向为 obj
- 在 obj 要先判断是对象或者是函数类型

```js
function _new(Fn, ...args) { // ...args 拿到剩余参数数组
  let obj = Object.create(Fn.prototype) // 创建空对象，且原型指向 Fn

  let res = Fn.call(obj, ...args) // call 性能较好
  
  if (res !== null && (typeof res === 'Object' || typeof res === 'function')) {
    return res
  }
  
  return obj
}
```



### 构造函数属性 constructor

对象实例拥有的原生属性，指向创建它的构造函数

```js
obj1.constructor === Fn // true
```

但是任然建议使用 `instanceof`来判断实例是否属于某个构造函数。因为 `constructor`会被覆盖，不是很准确。



### 私有变量

在 java 中有 private 等修饰符以保证类中变量是私有的，即外界无法访问

在 JS 新特性中有 `#` 操作符来修饰一个变量来定义成私有的

目前大多数去情况下，可能需要自己用技巧去实现私有变量

```js
function Book(name) {
  // 1 箭头函数，绑定了 this
  // 2 闭包。让自由变量 name 得以保存
  // 3 getXXX 方法，外界不能直接访问 name
  this.getName = () => {
    return name;
  };
  this.setName = (newName) => {
    name = newName;
  };
}
let book = new Book("Life");
book.setName("Time");
console.log(book.getName()); // Time
console.log(book.name); // 无法访问私有属性 name 的值
```



### 构造函数与原型对象的关系

- 原型对象才是类的唯一标识。实例对象是继承于一个原型对象，而非构造函数。
- 两个不同构造函数的 prototype 属性可能指向同一个原型对象。一般来说构造函数与类同名。

```js
Array: function(){} // 1 构造函数
Array.prototype // 2 Array 的原型对象（包含了类所需要的方法，也是实例的原型）
Array.prototype.constructor // 3 指向构造函数，也就是 Aarry 本身（只有函数才有 prototype 属性）

// 使用 instanceof 函数，检查的就是该对象的 prototype（原型对象） 属性， 而非其构造函数
let arr = new Array()
arr instanceof Array  // 4 判断 arr 的构造函数 Array ，是否在 arr 原型链上的任意位置
```



### 方法为什么要写在原型上

- 写在构造函数中，会让每个实例对象都拥有。会资源浪费。
- 写在原型对象中，实例对象不需要拥有，可以通过原型链回溯找到并直接使用
- 修改原型链，在修改之前就被实例化的对象也能使用新增或修改的方法或属性



## 原型和原型对象

### 基本属性和 API

- 原型：原型对象的引用地址

- 原型对象：放了很多共享属性和方法的对象

- 对象的原型： `obj.__proto__`

  - 与下面的 `prototype `指向的是同一个地方
  - 注意是左右各2个下划线

- 虽然这个 `__proto__`被所有浏览器兼容，但是不是纳入标准的。因为有性能上的问题。所以推荐使用新的 API 来读写分离

  - `Object.getPrototypeOf()` 来代替该属性的读取功能，作用就是获取对象的原型

  - `Object.setPrototypeOf()` 设置对象的原型
  - `Object.create`，创建指定原型的新对象，原型可以是 `null`

- 构造函数的原型： `fn.prototype`

  - 该属性，可读写，不可枚举

- 通过原型找构造函数

  -  `Fn.prototype.constructor === Fn` （constructor 属性是在 prototype 这个对象上的）
  - `[].constructor ===  Array` （实际上是先通过 `__proto__` 在通过上面的 `constructor`属性）

- `a instanceof A`：判断左边的对象是否是右边构造函数创建的，即测试一个对象在其原型链中是否存在一个构造函数的 `prototype` 属性

- `A.isPrototypeOf(B)` , A 对象是否存在于 B 对象的原型链上

- `obj.hasOwnProperty('fn')`：判断属性或者方法 fn 是否属于obj这个实例。是的话true， 不是的话false。一般用来判断这个属性或方法到底在实例中定义 (true) 的还是在原型对象中定义 (false) 的。



### instanceof  鉴别对象原型

实现一下原理

```js
function instanceof(left, right) {
  let prototype = right.prototype // 1 获得构造函数的原型
  left = left._proto_ // 2 获得对象的原型
  while (true) { // 3 判断对象的类型是否等于构造函数的原型
    if ( left === null ) { return false } // 该对象没有原型对象。直接结束。
    if ( prototypr === left ) { return true } // 原型对象一致
    left = left._proto_
  }
}
```



### hasPrototypeProperty 鉴别原型属性

```js
function hasPrototypeProperty(obj, name) {
  // in 操作符判断是自有属性和原型属性
  // 同时满足该属性不是自有属性
  // 那么就相当于是判断该属性是否是原型属性
  return name in object && !object.hasOwnProperty(name)
}
```



### [[Prototype]] 属性

用内部属性 `[[Prototype]]`跟踪对象实例的原型对象。

当用new创建一个对象，构造函数的原型对象就会赋值给该对象的 `[[Prototype]]`属性

- 用 `Object.getPrototypeOf`读取 [[Prototype]]属性的值

```js
let obj = {}
let prototype = Object.getPrototypeOf(obj)

// obj 是泛用对象，所以都是指向 Object
prototype === Object.prototype
```

- 大多数浏览器 JS 引擎给所有对象上增加了 `_proto_`的属性，可以直接读写 `[[Prototype]]`的值。但是这个有性能上的问题，所以 ES 标准建议使用2个替代的方法
  - **Object.setPrototypeOf** 改写[[prototype]]属性
  - **Object.getPrototypeOf **读取[[prototype]]属性



### 在构造函数中使用原型对象

> 原型对象的机制让他们成为一次性为所有对象定义方法的理想手段

- 通过原型对象增加变量或方法

```js
// 给 Fn 构造函数的原型对象增加 getName 方法
// 这样所有通过 Fn 创建的实例对象都可以该方法
Fn.prototype.getName(){
  return this.name
}
```

- 要特别注意原型对象上的引用类型。因为内存也是共享的

```js
Fn.protytype.arr = []

// 创建2个实例
let obj1 = new Fn()
let obj2 = new Fn()

// 操作原型对象上的数组变量 arr
obj1.arr.push(1)
obj2.arr.push(2)
obj2.arr // [1,2]，原型对象上的数组被修改2次，因为是引用类型
```

- 字面量形式替换原型对象

```js
Fn.prototype = {
  // 字面量形式改变了原型对象属性，因为现在指向 Object 而不是 Fn。所以要重置该属性
  // 且注意要放在第一行，避免在没有正确指向的时候调用了方法。
  constructor:Fn, 
  sayName:function(){},
  toString:function(){}
}
```



### 改变原型对象

简单来说就是后来增删的原型对象上的变量或属性，都会立即反应到所有实例上。

因为这个原型对象就是一个指向它的指针引用



### 内建对象的原型对象

就是可以修改一些内建对象的原型对象

```js
Array.prototype.sum = function(){
  // 可以自己重写以赋予更多能力
  // 实际开发不建议这样做，这会让新人无法确定该方法的作用
}
```



### JS 和 JAVA 的区别

JAVA 创建的实例对象，会把类中的特性继承下来

JS 创建的实例不会默认继承他们，而是通过原型链去找（这就是 JS 轻量的原因）



## 原型链机制

> 原型链，解决对象创建时的内存开销。通过链式查找共享属性和方法

每个对象都有原型对象，当然通过 `Object.create(null)`  是没有原型对象的

当我们需要使用对象的某个方法时 `obj.fn `，它的回溯查找顺序

- 对象自己身上的方法
- 原型对象上的方法
- `Object.prototype` 上的方法
  - `Object.prototype`  是所有对象的祖宗原型
  - Object 也有很多内置方法，如之前看到的 `toString` 和 `hasOwnProperty` 
  - 创建的每个对象，默认的原型是Object对象。我们可以改变这些对象的原型指向，但重点都是Object
- null —— 返回 Undefined



### 类和实例对象

在 JS 中的类，本质上都是 `函数`。

```js
Array 是一个数组类
[1,2,3] | [100,200] 这些都是数组的实例对象
```



### 原型对象

- 对于类来说

有一个保存自己基因的地方，这就是 `原型对象`，也就是每个类（函数）的 `prototype` 属性。

- 对于实例对象来说

除了自己的私有属性、方法，还能根据 `__proto__` 属性找到所属类的原型对象 `prototype` 



### 原型链机制

比如要找 `[1,2,3].push()` 中的 push 方法，其过程如下

- 先找 `[1,2,3]` 这个实例对象的私有方法
- 再通过 `__proto__` 找到所属类的原型对象上的方法
- 还是找不到，就一直顺着这个链子上去，直到 `Object.prototype` 为止

```js
let arr = [] // 数组对象
function foo(){} // 函数对象

arr -> Array.prototype -> Object.prototype -> null // arr 数组对象的原型链
foo -> Function.prototype -> Object.prototype -> null // function 函数对象的原型链

// 原型对象上有许多方法，是共享的。也就是实例对象本身不需要拥有就可以直接使用的方法，可以理解为 类中的静态方法。
Array.indexOf()
Function.apply()
```



