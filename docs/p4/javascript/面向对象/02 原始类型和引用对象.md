# 二、原始类型和引用对象

## （一）类型的概念

### 1 原始类型和引用类型

JS 虽然没有类的概念（ES6 后有 class 语法糖），但仍然有两种类型：

- 原始类型：保存为简单的数据值
- 引用类型：保存为对象，本质是指向内存位置的地址引用



### 2 对比其他语言的类型处理

其他编程语言用不同的数据结构来储存这2个不同的类型

- 栈：存原始类型
- 堆：存引用类型

而 JS 使用一个变量对象追踪变量的生存期。

- 原始值：直接保存在变量对象内
- 引用值：作为指针保存在变量对象内，该指针指向内存中的实际存储位置







## （二）原始类型

### 1 字面量和变量

JS 有 6 种原始类型，都有自己的字面量形式

- boolean：布尔值 true 或 false
- number：任何整型或浮点数值
  - 如 11.2； 100
- string：单引号或双引号的任意个数字符（不区分字符类型）
  - 如 "xx"；'xxx'
- null：空类型。只有一个 null 值
- undefined：未定义。只有一个值 undefined （会给到未初始化的变量上）
- symbol (ES6 新增)



大多数语言包括 JS ，用变量保存字面量时，都是直接保存值（而不是保存指向对象的指针地址）。

所以简单类型赋值给变量后，再次赋值给其他变量，这两个变量的存储地址是不同的。

```js
let str = 'xxx'
let str2 = str1
```



### 2 用 typeof 鉴别原始类型

对于以下四种类型能够准确判断

```js
typeof 5 // "number"
typeof 'lucas' // "string"
typeof undefined // "undefined"
typeof true // "boolean"
```

对于 null 类型，结果是返回一个对象类型。

> 这被 TC39 （JS设计维护委员会）认定是一个错误。

```js
typeof null // "object", Null 会被判断成 object

// 最好的方式：用值直接与 null 进行比较看是否是空类型
// 注意是 ===
value === null // true or false
```



### 3 原始类型的方法

三个原始类型 string, number, boolean 都可以用 `.` 的方式使用方法。

在体验上感觉像是调用对象的方法，实际上他们不是对象。

这是设计者故意设计成这样的，让我们有一致的语言使用体验。

```js
let lowercaseNmae = 'Nich'.toLowerCase()
```



## （三）引用类型

### 1 引用类型基本概念

- 引用类型就是 JS 中的对象，也是最接近类的东西
- 对象是属性的无序列表，属性包含键（始终是字符串）值对
- 若属性的值是函数，则它是一个方法
- 使用对象前，首先得创建

在 JS 中，引用类型主要有3个

- 对象
- 数组
- 函数

#### 1）内建对象

就是可以通过 `new xx`方式实例化的对象

- Array 数组类型个
- Date
- Error 运行期错误类型（还有一些子类型）
- Function
- Object
- RegExp 正则表达式对象



### 2 对象的创建和删除

#### 1）创建对象

使用 `new` 操作符来实例化对象。

在 JS 中，构造函数就是通过 new 来创建对象的函数。任何函数都可以是构造函数，只是在命名上，大家约定首字母大写的为构造函数。

```js
let obj = new Object() // 被创建的 obj 实例，是一个指针地址
let obj = {} // 这种方式也可以

let obj2 = obj // obj2 与 obj 是同一个指针地址，所以指向同一个对象
```



#### 2）释放内存（解除对象引用）

JS 自带垃圾回收机制（垃圾收集器自动对引用类型进行内存的优化）。

也可以手动清除，那就是让对象变量置为 `null`。这对于大型程序来说很有必要。节省内存的开销。

```js
let obj = new Object()
obj = null
```



#### 3）增删对象属性

JS 对象的一个特性，可以随时修改对象，及时开始没有定义他们。

```js
let obj = {}
obj.x = 1 // 可以增加属性
delete obj.x // 删除属性
```



### 3 对象实例化

直接用字面量的形式创建，可以省略 new 的操作。

这里以对象为例，其他类型的引用对象都是类似的实例化方式

```js
// 对象
// 对象的属性名字是标识符或者字符串
// 当属性名字中有特殊字符串时就可以用字符串的形式
let obj = {
  name:'wjy',
  "a-g-e":12
}
// 可以随时创建
obj.grade = 100
```



### 4 访问属性

访问对象属性有两种方式

```js
let obj = []
let b = 'push'

obj.push(123) // . 号
obj['push'](123) // 中括号
obj[b](123) // 动态属性，也就是对应变量 b 的值。这里就是调用了 obj.push(123)
```



### 5 鉴别引用类型

#### 1）用 typeof 鉴别 function

在 JS 的几个引用类型中， 使用`typeof`仅可以鉴别 `Function` 类型的对象。其他对象都是返回 `object`

```
function fn(){}
typeof fn // 'function'
```

#### 2）用 instanceof 鉴别其他对象

> 参数是对象和构造函数，用于判断该对象是否是该构造函数的一个实例

```js
let arr = []
let obj = {}
function fn() {}

arr instanceof Array // true
obj instanceof Object // true
fn instanceof Function // true
```

这个操作符也是用于鉴别继承类型的，由于所有的引用类型都是继承自 Object，所以

```js
let arr = []
arr instancof Object // true
```

#### 3）用 isArray 鉴别数组对象

用 `isArray` 的原因是，在 ES5 被提出：当网页存在多个框架时（多个全局环境），那么实例化数组的 Array 构造函数是有多个的。此时用 `instanceof`无法判断数组。

```
let arr = []
Array.isArray(arr) // true
```



### 6 原始封装类型（包装对象）

#### 1）自动打包过程

`包装对象`就是只用于临时使用，使用完后会被自动销毁。在 JS 的 String、Number、Boolean 类型进行读取操作时会创建相应的包装对象。

```js
// 字面量形式使用
// 为什么普通对象可以使用，对象.属性/方法 的操作呢？
let str = 'wjy'
let newStr = str.charAt(0)

// 上面代码的底层执行过程
// 字符串对象的存在仅用于该语句并随后销毁
let str = 'wjy'
let temp = new String(str) // 创建临时包装对象，此时是一个对象
let newStr = temp.charAt(0) // 调用对象方法
temp = null // 内存收回，销毁临时对象
```

#### 2）立即销毁的临时对象

对于一个真的对象可以在任何时候去修改它，但是对于原始封装类型的属性，会立即消失。

```js
let str = 'wjy'
str.name = 'xxx' // str.name === undefine
```

JS 引擎实际执行内容

```js
let str = 'wjy'
let temp = new String(str)
temp.name = 'xxx'
temp = null
```

所以，每当我们访问 `str.name` 时，创建的原始封装类型对象是被立即清除的。

```js
let temp = new String(str)
temp.name
temp = null
```

同时，使用 `instanceof` 无法判断这些类型，返回的都是 false。

> 因为临时对象仅在被读取时创建，而 `instanceof`并没有读取任何东西，也就没有任何临时对象的创建。

```js
let str = 'wjy'
str instanceof String // false
```

#### 3）手动创建原始封装类型

这样做有一些副作用，使用 `typeof` 得到的都是 Object 类型，就无法判断真实的原始类型。

```js
let str = new String('wjy')
let no = new Number(123)
let flag = new Boolean(true)
typeof str // object
```

还有一个点，就是把对象作为判断条件，无论是否有值，都会被当做 true

```js
let obj = new Number(1)
if(obj) return true // true
```

