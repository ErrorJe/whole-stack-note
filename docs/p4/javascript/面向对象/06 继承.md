# 六、继承

JS 的继承方式是基于原型对象的。

## （一）原型链和 Object.prototype

### 1 原型链

原型对象的属性和方法，可以被对象实例给访问，这就是继承的体现。

原型对象也是对象，也有属于自己的上级原型对象，以此类推形成`原型对象链`。



### 2 Object.prototype

所有以字面量形式创建的对象 `let obj = {}`，其原型对象都是 `Object.prototype`，也即是该对象的`[[Prototype]]`值。

```js
let obj = {}
Object.getPrototypeOf(obj) == Object.prototype // true
```



### 3 Object 原型对象常用的方法

> 尽量不要去修改 `Object.prototype` 上的属性或方法。如果增加了，则默认是可枚举。
>
> 那么在 for-in 语句中最好搭配判断 `Object.hasOwnProperty`

#### 1）valueOf

在对象上使用`操作符`时，就会默认调用 `valueOf`方法，且默认返回对象实例本身。对不同类型的数据做出不同的反应

- String 类型，返回字符串
- Boolean 类型，返回布尔
- Number 类型，返回数字
- Date 类型，返回 epoch 时间，单位是毫秒

```js
new Data > new Date(2010) // true
```

其实可以自定义 valueOf 方法，也就是去重写他。

#### 2）toString

当 `valueOf` 返回的是一个引用而不是原始值的时候，就会回退调用 `toString`方法。

```js
let obj = {}
let msg = 'this is' + obj  // 'this is [object object]' 自动调用 toString
```

当然也可以重写该方法

```JS
let obj = {
  toString:function(){
   return 'toString'
  }
}
let msg = 'this is' + obj  // 'this is toString'
```



## （二）对象继承

就是指定新对象的 `[[Prototype]]`是哪个父对象。

- Object.prototype 是对象字面量形式默认的
- Object.create 可以显式指定

### 1 Object.create 继承创建对象

```js
// 参数1：指定新对象的 [[Prototype]] 属性
// 参数2：就是对象特征的描述

// 1 字面量形式创建。自动继承于 Object.prototype
let obj = {
  msg:'wjy'
}

// 2 使用 create 方法创建 obj
let obj = Object.create(Object.prototype, {
  msg:{
    value:'wjy',
    writable:true,
    configurable:true,
    enumerable:true,
  }
})
```

创造出一个没有原型对象的对象

`let obj = Object.create(null)` 意味着如 toString 之类的方法都不存在了，只是一个哈希容器。也没有别的用处



### 2 构造函数继承

#### 1）构造函数的 JS 机制

- 默认继承于 Object.prototype
- 重置 constructor 属性为自己

```js
// 1 自己创建的构造函数
function myConstructor(){}
// 2 JS 引擎底部做的事。
// 默认继承于 Object.prototype,
myConstructor.prototype = Object.create(Object.prototype, {
  // 重置 constructor 属性为自己
  constructor: {
    value:myConstructor,
    configurable:true,
    enumerable:true,
    writable:true
  }
})
```

#### 2）改写 prototype 实现继承

```js
// 1 创建 2 个构造函数
function Father(){}
obj1.prototype.fn = function(){}

function Son(){}

// 2 实现继承
// constructor 是 xxx.prototype 原型对象的属性
Son.prototype = new Father() // 此时 constructor 为 Father
Son.prototype.constructor = Son // 将 constructor 重置回自己
```

事实上， Son 对于继承唯一需要关心的是原型对象要指向 Father。

- 这里需要注意，如果在 Son 的原型对象上要新增方法，必须在完成继承之后。不然之前的都会被丢失

那么就可以用 `Object.create`来简化。

对比上面的实现，会出现调用 `new  Father`时若有初始参数的传入要求，但是没有传会出现报错。现在这种方法就可以避免（没有调用父类构造函数来初始化）

```js
// 1 创建 2 个构造函数
function Father(){}
obj1.prototype.fn = function(){}

function Son(){}

// 2 用 Object.create 简化代码
Son.prototype = Object.create(Father.prototype, {
  constructor: {
    value:Son,
    configurable:true,
    enumerable:true,
    writable:true
  }
})
```



### 3 构造函数的窃取（伪类继承）

JS 的继承是通过原型链实现的，所以不用调用对象的父类构造函数。

若确实有这个需要，就要利用 JS 函数工作的特性。如 `call, apply`方法。模仿那些基于类的语言的类继承。

```js
// 1 创建 2 个构造函数
function Father(length,width) {
  this.length = length
  this.width = width
}

// 2 在子类中调用父类构造方法
function Son(size) {
  Father.call(this, size, size)
}

// 3 实现继承
Son.prototype = Object.create(Father.prototype, {
  constructor: {
    value:Son,
    configurable:true,
    enumerable:true,
    writable:true
  }
})

// 4 创建实例
let son = new Son(6) // son.length = 6; son.width = 6
```



### 4 访问父类方法

ES6 之前没有 `super` 关键词，还是依靠 call, apply 等方法在调用父类原型对象中的方法时使用

```js
Son.prototype.toString = function(){
  let text = Father.prototype.toString.call(this) // 拿到父类 toString 方法
  return text.replace('Father', 'Son')
}
```

