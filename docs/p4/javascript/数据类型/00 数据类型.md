# JS 数据类型

## 数据类型的分类

数据类型一共有7种：undefined, Null, Boolean, String, Number, Symbol, Object

> 除了对象、数组，其他都是基本数据类型

- null

- undefined：变量未拥有值时

- boolean

- number

- string

- object: 包括function, array, date等

- - function 内置 [[call]] 属性 ，是一个可以被调用的“对象”。其 length 属性是其参数个数
  - array， length 属性是其元素个数。以有序数字作为索引键

- symbol



### 按性质分类

> 一般来说都以这分类方式为标准

原始类型：不可更改

- 基本类型: boolean, number, string, symbol(ES6)
- 特殊类型: null, undefined

对象类型（引用类型）：有深浅拷贝的问题

- 对象：属性(键值对)的无序集合
- 数组：带编号的值的有序集合
- 函数：使用 `Typeof` 时返回 `function`类型

 

### 按是否有方法分类

不可拥有方法类型: null, undefined

可拥有方法类型：除上面2个之外的所有



### 按值类型是否可变分类

可变类型：值可以修改

- 对象， 数组

不可变类型：

- number, boolean, null, undefined, string



## Number 类型

JS中的数字都是浮点数（双精度，64位二进制）表示的，也就是 IEEE 754 标准。 

JS中 Number 有 2^64-2^53+3 个值



数字类型支持

- 十进制，30
- 二进制，0b111
- 八进制，0o13
- 十六进制，0xFF

字符串语法还包括科学计数法

- 1e3
- -1e-3



### 语法

#### 多进制字面量

其他进制都支持 0 后面字母的大小写形式，但是大写 O 和数字 0 容易搞混。所以建议都用小写字母区分

```js
// 1 默认十进制
42
42.3
  .3 // 省略 0 
42. // 小数后的 0 也可以省略。从代码可读性上说不建议这样写

// 2 十六进制 0x 开头

// 3 八进制 0o 开头
// ES6中禁止使用0开头的八进制。chrome中可以用

// 4 0b 二进制
```



#### 科学计数

```js
var a = 5E10 // 5 的十次方， 数字表示
a.toExponential() // 科学计数法字符串表示
```



#### 常用 API

```js
var a = 42.33
a.toFixed(1) // 42.3 指定小数位
a.toPrecision(2) // 42 指定有效位数的显示
```



### Math API

#### Math 内置对象

```js
Math.pow(2, 53)  = 2的53次幂
Math.round(0.6) = 四舍五入 1
Math.ceil(0.6) = 向上求整 1
Math.floor(0.6) = 向下取整 0
Math.abs(-5) = 绝对值 5
Math.max(x, y, z) = 最大值
Math.min(x, y, z) = 最小值
Math.random() = 生成[0, 1.0)的伪随机数
Math.PI = 圆周率π
Math.E = 自然对数的底数 e
Math.sqrt(3) = 平方根
Math.pow(3, 1/3) = 3的立方根
Math.sin(0) = 三角函数, 还有cos, atan等
Math.log(10) = 10的自然对数
Math.log(100) / Math.LN10 = 以10为底100的对数
Math.exp(3) = e的三次幂
```



#### 整数检测

```js
Number.isInteger(42.000 ) // true
// polyfill 实现
if (!Number.isInteger) {
    Number.isInteger = function(){
        return typeof num == 'number' && num % 1 == 0
    }
}

// 安全浮点数的 polyfill 实现
if (!Number.isSafeInteger) {
    Number.isSafeInteger = function(num) {
        return Number.isInteger(num) && Math.abs(num) <= Number.MAX_SAFE_INTEGER
    }
}
```



### 常见问题

#### 点.运算符

> 是做一个有效的数字字符，优先识别为字面量的一部分，然后才作为对象属性访问运算符

```js
24.toFixed(2) // 报错。被当做 24.0， 那么就没有 . 来调用 toFixed 方法了

// 解决办法
(24).toFixed(2)
24..toFixed(2)
24 .toFixed(2) // 空格
```



#### 数据异常：不报错

> 为了不让除以 0 时出错

- 溢出或下溢：

- - 溢出上限返回表示无限大的保留字： infinity
  - 溢出下限， 无限小： - infinity
  - 下溢（结果无限接近于0）： 返回0 或者是 -0（两者在加法中没有区别，在除法中有区别）

- 被0整除：引入无穷的概念

- - 一般是返回infinity（除以0）或-infinity（除以-0）。同样可以来判断是除以了(-0)还是(0)
  - 但是当0/0， 无穷运算无穷时，都返回NaN表示非数字值



#### 零值

```js
0 === -0 // true

// 使用绝对等式 Object.is()
Object.is(0, -0) // false

// 但是能用 === 就尽量不用这个，效率不高
```



#### 非数字值 NaN

表示无效数值

不与任何值（包括自己）相等

```js
NaN !== NaN // true
NaN === NaN // false

// 所以要用内置方法来判断这个值
Number.isNaN(NaN)
```

占用了 9007199254740990

- isNaN()，判断非数字值，如NaN、字符串等
- isFinite()， 判读是否为有限数字， 还能把如字符数字'12'先自动转为数字再判断。NaN为参数时返回false



#### 极值和安全范围

最大的浮点数范围

```js
Number.MAX_VALUE // 1.798e+308 
Number.MIN_VALUE // 5e-324,无限接近于0
```

在 ES6 中对浮点安全范围做了常量

```js
Number.MAX_SAFE_INTEGER // 9007199254740991
Number.MIN_SAFE_INTEGER // -9007199254740991
```



#### 二进制浮点数误差 0.1+0.2 != 0.3

> 所有遵守 IEEE 754 规范的语言都如此

JS的Number使用浮点数表示。没有整数的概念。

根据双精度浮点数的定义，Number中有效整数范围： -0x1fffffffffffff至0x1ffffffffffffff(13个f)。超出后无法精确表示。

根据浮点数的定义，非整数的数字无法用 ==(===) 来比较。 ——> 这样就出现了 0.1+0.2 != 0.3

```js
var x = 1 // 1
var x = 0.1 // 0.1
var x = 0.2 - 0.1 // 0.08999999...
```



尽管JS的精确度可以极度接近0.1，但是这却是一个近似值，而非自然的真实数值。当我们来判断相等的时候就会出现问题。

这个问题不仅是在JS中有，而是所有使用二进制来表示浮点数的语言都存在这个问题。

而且，不是结果错了，而是我们比较的方法错了。

**此时，**可以使用四舍五入的方法来修正数值。

- Math.round() = 四舍五入
- toFixed(小数后位数), 也可以达到目的

**最终的解决办法**：使用 JS 提供的最小精度值 **Number.EPSILON**

- 这个值通常是 2^-52

```js
// es5 的 polyfill
if (!Number.EPSILON) {
    Number.EPSILON = Math.pow(2, -52)
}
```

- 注意要使用 abs() 来取差值的绝对值

```js
Math.abs(0.1+0.2-0.3) <=  Number.EPSILON
```



## undefined / null / void

### undefined

#### 基本特点

- 它只有一个值，就是 Undefined。
- 任何变量在赋值之前都是 Undefined 类型，值为 undefined



#### 基本用法

当我们创建了一个变量，有时候我们会想要先给它一个类型，如

var s = '' // 就是代表了字符串类型的空值

也有的时候，我们只是想创建这个变量，并不想给他数据类型。此时就可以直接使用全局变量 undefined

```js
var x = undefined
var y // 也是 undefined
```



#### ES5 的设计失误

> 总结：ES5之前，undefined是可以被赋值的，之后现代浏览器将其设置为一个 non-configuration和non-writable属性的值了。

在JS代码中的 undefined 的是一个变量，而不是一个关键字。防止被篡改，建议使用 void 0 来获取 undefined 的值。

因为 void 运算可以把任意表达式变为 undefined 值，如

```js
var a = 1
var x = void(a + 1) // undefined
var y = void 0 // undefined
```



undefined 在全局中无法赋值，在局部使用时，可以赋值

```js
// 打印 'foo string' PS：说明undefined的值和类型都已经改变
(function() {
var undefined = 'foo';
console.log(undefined, typeof undefined)
})()
```



### null

与 undefined 有语义上的区别。 null 表示数据定义了但是值为空。

Null类型也只有一个值， null。同时 null 是关键字，所以不存在 undefined 作为变量的情况。

实际使用中，一般不会把创建的变量直接赋值为 undefined，这样可以保证那些值为 undefined 的变量确实没有被使用

```js
// 一般创建一个变量，但是不知道暂时赋值为什么就会写个 null
var a = null
```



### void

不改变表达式结果，但不返回值，也就是返回 undefined

```js
if(config) {
    setTimeout(xxx, 100)
    return 
}

// 使用 void 与上结果一致
if (config) {
    return void setTimeout(xxx, 100)
}

// 另外这三个本质上没有区别
void 1
void 0
undefined 
```



## Boolean 类型

只有两个值， true 和 false。这2个都是关键词。比较简单。



## String 类型

表示文本数据

### 基本认识

#### 字符串的最大长度

字符串有其最大长度的限制，但是数量不是以字符数来计算的。String 的最大长度为 2^53-1。

实际上，字符串是UTF16编码。所有的字符操作都是在UTF16编码的基础上。也就是字符串的长度受制于编码长度。

- 国际标准，字符以Unicode表示。UTF是其编码方式。
- 基本字符区域BMP：0-65536(U+0000 - U+FFFF)



#### 字符串无法更改

字符串具有值类型的特征，一旦被构造出来，无法用任何方式改变字符串内容。

也就是用字符串的成员函数是无法改变原字符串的，而是返回操作后的新字符串。

JS字符串是将每个 UTF16单元 作为一个字符来处理的，也就是范围在 BMP 的字符。



#### 特殊字符

```js
\n 换行
\t 制表符
\b 退格
\r 回车
```



### 字符串操作

#### 基本操作

```js
// 1 判断相等或者包含
log('good' == 'good') //true
log('good' == 'bad') //false
log('good' != 'bad') //true

// 2 判断包含
log('impossible'.includes('possible'))//true

// 3 拼接得到新字符串
log('very' + 'good')//当出现很多字符串需要拼接的时候就很麻烦
log('very ' + ' good')//空格也被当做字符

// 4 模板字符串
var name = 'gua'
var a3 = `${name}, 您好`//${变量名}，可以用来替换成新字符串

// 5 字符串相当于数组array，可以用数字下标获取元素
var s = 'iamgood'
for (var i = 0; i < s.length; i++) {
  log(s[i])
}
```



#### 常用 API

```js
// 1 字符串切片，array也可以.
s.slice(0, 3) //下标0开始，取3个数
s.slice(1, 3)
s.slice(2)  //省略下标，从下标2开始取到底。'mgood'

// 2 substring() 方法 和 indexOf() 方法
// 提取字符串中介于两个指定下标之间的字符
var url = 'string#123'
var x = url.indexOf('#') // 返回#在字符串的index索引位置
var y = url.substring(url.indexOf("#")) // 返回#123
var z = url.substring(url.indexOf("#" + 1)) // 返回123，常用于取地址栏中的某值

// 3 substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符
substr(start,length)

// 4 JS 中原字符串都是不变的，一些方法只是返回了一个新生成的数组
s.charAt(s.length-1) // 最后一个字符，返回字符串的某一位
s.substring(1, 4) // [1,4)之间的字符,不包括结束位置
s.substring(1) // 从索引1开始到结尾
s.slice(1, 4) // 同上
s.slice(-3) // 最后3个字符
s.split(',') // 根据 , 分割字符串成数组
s.indexOf('i') // i 首次出现的位置
s.lastIndexOf('i') // i 最后一次出现的位置
s.indexOf('i', 3) // 在位置3及之后首次出现 i 的位置
s.replace('h', 'H') // 全文字符替换成H
s.toUpperCase() // 全大写
s.search(3) // 查3第一次出现的位置。会跟正则一起用
s.includes('2') // 是否存在 2
s.startsWith('123') // 判断是否以 123 开头
```



字符串也是个类数组，但是却没有数组成员函数。所以可以借用

```js
var a = 'foo'
var b = ['f','O','o']
var c = Array.prototype.join.call(a, '-') // f-o-o
// 'F.O.O.'
var d = Array.prototype.map.call(a, function(v){
    return v.toUpperCase()+'.'
}).join('')
```



由于字符串不能直接修改，若要求对字符串进行反转操作是无法像上面一样借用方法。而是要先转成数组，操作后再转回字符串

```js
var a = 'foo'
var c = a.split('').reverse().join('') // 'oof'
```



### API 封装

#### 基本方法

```js
/* 1.将数组中的元素用某符号连接成字符串
  del， 字符
  array, 数组
*/
var join = function(del, array) {
  var s = array[0]
  for (var i = 1; i < array.length; i++) {
    var a = array[i]
    // 将每个符号和元素作为一个整体加起来
    s += (del + a)
  }
  return s
}

/* 2.将字符串以某字符隔开，返回新的数组
  s, 字符串
  del, 原有字符串中的某字符， 默认为空格。del不再作为字符的一部分。
*/
var split = function(s, del=' ') {
  var l = []
  // space 是分隔符的长度，分隔符长度不一定为 1
  var space = del.length
  // 用 start 存储每次的开始下标
  var start = 0
  for (var i = 0; i < s.length; i++) {
    // 检查分隔符
    if (s.slice(i, i+space) === del) {
      // 若检查到了检查符，则存储一个数据
      l.push(s.slice(start, i))
      // 设置新的开始下标
      start = i + space
    }
  }
  l.push(s.slice(start))
  return l
}

/* 3.替换字符串
  s, 字符串
  old， 某原字符子串
  newString, 拿来替换的字符子串
*/
var replaceAll = function(s, old, newString) {
  // 以 old 字符串为分隔符，返回新的数组
  var s1 = split(s, old)
  // 用 new 作为连接符，返回新的字符串
  var s2 = join(newString, s1)
  return s2
}

/* 4.str1(n)
  返回这样规律的字符串, 特殊情况不考虑
  n       返回值
  1       '1'
  2       '121'
  3       '12321'

  n 是 int类型
*/
var str1 = function(n) {
  var s = ''
  // 左边, 注意下标
  for (var i = 0; i < n; i++) {
    s += String(i+1)
  }
  // log('str1 zobm', s)
  // 右边, 注意下标和 i--
  for (var i = n - 1; i > 0; i--) {
    s += String(i)
  }
  return s
}

/* 5.str2(n)
  返回这样规律的字符串, 特殊情况不考虑
  n       返回值
  1       'A'
  2       'ABA'
  3       'ABCBA'
*/
var str2 = function(n) {
  // 用下标来取字符
  var upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  var s = ''
  // 左边
  for (var i = 0; i < n; i++) {
    s += upper[i]
  }
  // 右边, 注意下标
  for (var i = n - 2; i >= 0; i--) {
    s += upper[i]
  }
  return s
}
```



#### 凯撒加密（字符串加解密）

- 找某字符是否在字符串中

```js
/* 1.找某字符是否在字符串中
  string, 字符串
  el, 某字符
  存在返回 下标，不存在返回 -1
*/
var find = function(string, el) {
  var index = -1
  for (var i = 0; i < string.length; i++) {
    if (string[1] == el) {
      // 找到后就结束循环
      index = i
      break
    }
  }
  return index
}
```



- 返回一个字符串的小写/大写形式

也就是对字符串做预处理格式化

```js
/* 2.返回一个字符串的小写形式
  传参是一个字符串，假设都是大写字母， 返回其小写形式
  需要先定义所有字母的大小写形式
*/
var lower = 'abcdefghijklmnopqrstuvwxyz'
var upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

var lowercase = function(s) {
  // 初始化空字符串
  var result = ''
  for (var i = 0; i < s.length; i++) {
    // 调用“1”中的查找字母函数
    // 先去大写字母表里去找，得到索引
    var index = find(upper, s[i])
    // 根据索引到对应的小写字母表去找到该元素的小写
    result += lower[index]
  }
  return result
}

/* 3.返回一个字符串的大写形式
  传参string，一个字符串,并假设都是小写字母
  返回大写后的字符串
*/
var uppercaseA = function(string) {
  var result = ""
  for (var i = 0; i < string.length; i++) {
    var index = find(lower, string[i])
    result += upper[index]
  }
  return result
}
```



- 修复处理本身就有大写字符串的字符串

```js
var uppercaseB = function(s) {
  var result = ""
  for (var i = 0; i < s.length; i++) {
    var index = find(lower, s[i])
    if (index > -1) {
      // 找到了，说明是小写字母，进行大写转换后添加
      result += upper[index]
    } else {
      // 若是大写字母，就直接添加
      result += s[i]
    }
  }
}
```



- 凯撒加密算法

```js
/* 5.凯撒加密算法
  对原有字符串的序列进行移位，从而得到新的密文
  实现encodeA函数，将明文加密(以右移 1位 为例)并返回
  实现decodeA函数，将密文解密后返回
*/
// 调用加密算法并返回密文
var encodeA = function(s, shift) {
  var result = ""
  for (var i = 0; i < s.length; i++) {
    // 原字符
    var c1 = s[i]
    // 偏移 shift 位加密后的字符
    var c2 = shiftedChar(c1, shift)
    // 形成密文
    result += c2
  }
  return result
}


// 实现右移函数, 返回字符 char 偏移 n 位后的字符
var shiftedChar = function(char, n) {
  // 创建字母表（字典）
  var lower = 'abcdefghijklmnopqrstuvwxyz'
  var upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  // 目前只考虑是字符的情况, 验证是否是大写字母
  var index = find(upper, char)
  // 确定为大写字母时, 并算出偏移n位后的下标
  if (index > -1) {
    // +了 26 是因为字母有26个，再因为是防止当左移的时候出现负数
    var newIndex = (index + n + 26) % 26
    // 返回偏移后的字母
    return upper[newIndex]
  } else {
    index = find(lower, char)
    // 小写字母时
    if (index > -1) {
      var newIndex = (index + n + 26) % 26
      // 返回偏移后的字母
      return lower[newIndex]
    } else {
      // 不是字母的情况，直接返回
      return char
    }
  }
}
```



凯撒解密

```js
// 解密成明文并返回
var decodeA = function(s, shift) {
  var result = ""
  for (var i = 0; i < s.length; i++) {
    var c1 = s[i]
    var index = find(upper, s[i])
    // 大写字母
    if (index > -1) {
      // 就是反偏移
      var c2 = shiftedChar(c1, -shift)
      // 明文
      result += c2
    } else {
      index = find(lower, s[i])
      // 小写字母
      if (index > -1) {
        // 就是反偏移
        var c2 = shiftedChar(c1, -shift)
        // 明文
        result += c2
      } else {
        // 不是字母的情况, 不反偏移，直接加
        result += c1
      }
    }
  }
  // 返回明文
  return result
}

/* 6.解密一个凯撒密文
  不知道偏移了多少，所以1-25都试试
*/
// 原密文
var code = 'VRPHWLPHV L ZDQW WR FKDW ZLWK BRX,EXW L KDYH QR UHDVRQ WR FKDW ZLWK BRX'

// 解密
var decodeB = function(s) {
  // 解密26次
  for (var i = 0; i < 26; i++) {
    // 调用上面的反偏移方法
    var source = decodeA(s, i)
    }
}
```



#### 工具方法封装

- 获取字符串的字节长度

```js
// 1 获取字符串的字节长度
const byteSize = str => new Blob([str]).size;

byteSize('😀'); // 4
byteSize('Hello World'); // 11

```



- 字符转换

```js

// 2 首字母大写
const capitalize = ([first, ...rest]) =>
  first.toUpperCase() + rest.join('');

capitalize('fooBar'); // 'FooBar'
capitalize('fooBar', true); // 'Foobar'

// 首字母小写
const decapitalize = ([first, ...rest]) =>
  first.toLowerCase() + rest.join('')

decapitalize('FooBar'); // 'fooBar'
decapitalize('FooBar'); // 'fooBar'
```



- 删除

```js
// 3 每个单词首字母大写
const capitalizeEveryWord = str => str.replace(/\b[a-z]/g, char => char.toUpperCase());

capitalizeEveryWord('hello world!'); // 'Hello World!'
```



与`String.prototype.split('')`结合使用，以获取数字数组。获得最后一个数字。实施luhn算法。如果被整除，则返回，否则返回

> 银行卡号码的校验采用Luhn算法，校验过程大致如下：
>
>   从右到左给卡号字符串编号，最右边第一位是1，最右边第二位是2，最右边第三位是3….
>
>   从右向左遍历，对每一位字符t执行第三个步骤，并将每一位的计算结果相加得到一个数s。
>
>   对每一位的计算规则：如果这一位是奇数位，则返回t本身，如果是偶数位，则先将t乘以2得    到一个数n，如果n是一位数（小于10），直接返回n，否则将n的个位数和十位数相加返回。
>
>   如果s能够整除10，则此号码有效，否则号码无效。
>
> 因为最终的结果会对10取余来判断是否能够整除10，所以又叫做模10算法。
>
> 当然，还是库比较香: bankcardinfo

```js
// 4 银行卡号码校验（luhn算法, 模10算法)
const luhnCheck = num => {
  let arr = (num + '')
    .split('')
    .reverse()
    .map(x => parseInt(x));
  let lastDigit = arr.splice(0, 1)[0];
  let sum = arr.reduce((acc, val, i) => (i % 2 !== 0 ? acc + val : acc + ((val * 2) % 9) || 9), 0);
  sum += lastDigit;
  return sum % 10 === 0;
};

luhnCheck('4485275742308327'); // true
luhnCheck(6011329933655299); //  false
luhnCheck(123456789); // false
```



## Symbol 类型

是一切非字符串的对象Key的集合。ES6中，整个对象系统都用 Symbol 重塑了。

### 创建 symbol 数据类型

使用的是全局 Symbol 函数

```js
var mySb = Symbol("my symbol")  // Symbol(my symbol) 
```

这里虽然有字符串类型的描述，就算这样，不同的 Symbol 也不相等



### Symbol.iterator

为每一个对象定义默认的迭代器，该迭代器可以被 for ... of 循环使用

```js
var o = new Object
// 定义了0-10的迭代器
o[Symbol.iterator] = function() {
    var v = 0
    return {
        next: function() {
            return { value: v++, done: v > 10 }
        }
    }        
};
// 可以使用 o 对象
for(var v of o) 
    console.log(v); // 0 1 2 3 ... 9
```



## Object 对象类型

JS中最复杂的类型，也是核心机制之一。就是属性的集合。

- function
- array
- date等

属性分为数据属性和访问器属性，都是kv结构，key可以是字符串或者是Symbol类型

### 基本概念

#### 类的概念

其他语言如 C++， JAVA，他们的每个类都是一个类型。

而在JS中，类仅仅是运行时对象的一个私有属性，且是无法自定义类型的。



#### 对象有基本类型

- Number
- String
- Boolean
- Symbol

要注意的是，3 与 new Number(3) 是完全不同的值。

- 前者是数据类型，后者是数据类型的对象类型



#### new 关键词

new 的使用实际上限定了 this 在对象实例的上下文范围。

Number、String、Boolean 他们的构造器都是两用的。也就是说直接使用时，是强制类型转换。而与new搭配使用，是产生一个该类型的对象。

对于 Symbol， 直接用 new 会抛出错误。但是它仍然是 Symbol 对象的构造器



#### 一切皆对象

JS试图模糊基本类型和对象之间的关系。我们完全可以把一个基本数据类型的变量当作对象来使用。如

```js
"abc".charAt(0) // a
```



同时，也要知道对象中存储的 key:Value 键值对，其 key 是字符串形式的（有可能不是字符串，基本上什么类型都可以）。

所以下面数字 0 和字符串 '0' 其实指向的是同一个 Key

```js
let obj = {}
let a = 0
let b = '0'

obj[a] = '1'
obj[b] = '2'
obj[a] // '2'
```

上面说到，key 不一定是字符串，那可能是 symbol，用 symbol 创建的都是具有唯一性的.

此时用于做对象的 key，永远是唯一的，如下

```js
let a = symbol('1')
let b = symbol('1')
// true ，尽管从字面上看是字符串1 ，但是他是具有唯一性的 symbol，所以不相等
a !== b
```

还需要注意若 Key 是引用之类的类型

- 对象：会被字符串化成 `[object Object]`
- 数组：会调用 `toString` 转换

```js
let o = {}
let a = ['b', 'a']
let b = {m:2}
o[a] = 3
o[b] = 4

o[a] // 3 , ['b', 'a'].toString() 后a变成了 'b,a'
o[b] // 4，因为引用对象作为 key，被转换成了 [object Object]，两者是相同的
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200113112604.png)



#### 添加原型

在基本类型的原型上增加方法

```js
Symbol.prototype.hello = () => console.log("hello");

var a = Symbol("a");
console.log(typeof a); //symbol，a 并非对象
a.hello(); //hello，有效
```

这里在 Symbol 原型上增加了 hello 方法，之后任何 Symbol 类型变量都可以直接调用



### 数组类型

#### 组是对象的子类

本质也是对象，“约定”用有序数字作为属性 key。

其实我们用字符串作为 key，也是可以的，但是一般不会这么做。

```js
var arr = []
arr['aa'] = 1

// 若字符串是可以被转为数字的，就转为数字了
arr['12'] = 1 // arr[12]
```



#### 稀疏数组

```js
a[0] = 1
a[2] = 3
// 这个时候 a[1] 是 undefined
// 但是这个 undefined 和直接显式给 a[1] 赋值 undefined 是不同的
```



#### 类数组

如方法里的 arguments 就是类数组，如 DOM 操作的元素列表也是类数组

```js
var a = 'foo'
var b = ['f', 'g']
```

一般会通过数组方法去转换成真正的数组，以便操作

```js
indexOf,concat,forEach
slice
Array.from 
```



#### 创建指定位数使用

```js
 // 创建 1-24 的数组，且格式化2位字符，不足2位前置补0
 const List24 = [...Array(25).keys()].slice(1).map(i => i.toString().padStart(2, '0'))
 
 // 创建指定位数的稀疏空数组
 [...Array(10).fill(null)]
```

