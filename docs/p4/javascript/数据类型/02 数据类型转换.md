# 数据类型转换

JS是弱类型语言，所以在代码中会常见的运算都会先进行类型转换。

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200110092256.png)



大部分的转换都简单，复杂的只有 `Number` 和 `String` 之间的转换，以及 `对象` 和 `基本类型` 之间的转换。

## 转 Boolean 类型

在条件判断时，除了 `undefined, null, false, NaN, "", 0, -0` 之外的其他值，都转为 `true`，包括所有对象



### 相等运算符

#### == 和 ===

相等运算符（`==`）和严格相等运算符（`===`），它们都有缺点

- 前者会自动转换数据类型
- 后者的`NaN`不等于自身，以及`+0`等于`-0`。

JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 



#### Object.is

是 ES6 提出的"同值相等"算法，用于解决以上运算符的问题。

它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致 

 不同之处只有两个：

- `+0`不等于`-0`
- `NaN`等于自身 

```js
+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```



### 假值

JS 中的假值

```js
undefined, null, false, NaN, '', 0, -0
```



过滤假值

```js
const compact = arr => arr.filter(Boolean)

// [ 1, 2, 3, 'a', 's', 34 ]
compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]) 
```



### 关于 new Boolean

```js
Boolean(true) // true， 函数，返回 boolean 类型
new Boolean({key:value}) // 返回对象，永远是真的。
```



注意使用 ，当为引用类型时，不能用于判断是不是 true/false，都会为真

```js
var a = "0";
var b = [];
var c = {};

var d = "";
var e = 0;
var f = null;
var g;

Boolean( a ); // true
Boolean( b ); // true
Boolean( c ); // true

Boolean( d ); // false
Boolean( e ); // false
Boolean( f ); // false
Boolean( g ); // false
```





### 应用：!!运算符判断奇偶数

```js
const num = 3;
!!(num & 1) // true
!!(num % 2) // true
```



## Number 和 String 互转

### String 转 Number

多数情况下，直接使用 `Number()` ，比使用下面2种调用 API 的方式都好。



#### parseInt(str, n) 解析整数

全局方法，解析整数。忽略字符串前的任意空格，跟数字后任意字符。

- 第一位不是空格，也不是数字直接量，则NaN。

- 遇到'0x'会转为16进制

> 建议任何情况下，都应该给出第二个参数，来显示表明进制数。

```js
//  n 为进制数，n 参数可选
parseInt('   3.14 sad', 10) = 3.14
```

若不给第二个参数，则只支持16进制且前缀为“0x”，还忽略非数字字符，也不支持科学计数法。



`parseInt` 还是很靠谱的，不要因为下面一些不当用法就觉得是 bug

```js
parseInt( 0.000008 ); // 0 ("0" 来自于 "0.000008")
parseInt( 0.0000008 ); // 8 ("8" 来自于 "8e-7")
parseInt( false, 16 ); // 250 ("fa" 来自于 "false")
parseInt( parseInt, 16 ); // 15 ("f" 来自于 "function..")
parseInt( "0x10" ); // 16
parseInt( "103", 2 ); // 2
```



#### parseFloat(str) 解析浮点数

直接将源字符串作为十进制来解析，不会引入任何其他进制。

```js
parseFloat('0xff') = 255
```



#### 其他方式

##### 乘以一，`*1`

```js
'3' * 1 // 成功转换为数字 3
null *1 // 0
// 失败转换。成为 NaN。需要调用 Number.isNaN 判断是否为NaN
let a = 'xx' * 1 


// 验证方式
Number.isNaN('xx' * 1) // 返回 boolean
a !== a // 判断的第二种方式。因为 NaN !== NaN
```



##### 加号 `+`

```js
+ '123' // 123
+ 'ds' // NaN

```

若满足以下条件，则用 + 时将进行字符串拼接操作

- 其中一个操作数是对象或数组，先用 ToPrimitive 抽象操作（valueOf 或 toString）
- 再用 [[DefaultValue]] 以数字作为上下文，所以调用 valueOf
- 但是数组用 valueOf 无法得到基本类型值，所以调用了 toString

```js
// 所以数组的拼接会出现这种情况
var a = [1,2];
var b = [3,4];
a + b; // "1,23,4"
```



### Number 转 String

#### toString(n)

参数 n 表示进制数,范围是 `2-32`。最后转为字符串

```js
17.toString(2) = '10001'
'0x' + 17.toString(16) = '0x11'
```



#### toFixed(n)

n 表示小数点后位数，四舍五入，不足补0。转为字符串

```js
(123.45).tofixed(0) = '123'
```



#### toExponential(n)

转为科学计数法的字符串， n为小数点后位数，整数部分只有1位

```js
(1223.444).toExponential(2) = '1.22e+3'
```



#### toPrecision(n)

n 表示有效数字位数，若整数部分位数多于指定有效数字位数，则用科学计数法。

反之直接使用。转为字符串

> 科学计数法，其实是字符串。这样做的目的是为了字符串不会太长。

```js
(123.2131).toPrecision(2) = '1.2e+2'
(2131.23232).toPrecision(5) = ’2131.2‘
```



## 对象转基本类型

>  在JS中，一切皆对象，即所有的数据、对象都可以使用方法。
>
> 除了 null 和 undefined 是不能拥有方法的。

### 基础知识

在默认类型转换时，对象中有3个内置执行方法

- `Symbol.toPrimitive()` 覆盖原有行为，ES6后使用

- `valueOf()`， 对象转到数字

- - 一般对象都是复合值，所以默认是返回对象本身
  - 数组、函数和正则都是默认返回对象本身

- `toString()`， 对象转到字符串



### Object 转 String

只有 Date 对象才用，因为日期`Date`类，是唯一预先定义了有意义的 `toString()`  和 `valueOf()`方法。

它的转换步骤就是：先用 toString()， 再用 alueOf()， 最后 JS 返回字符串。否则报错



### Object 转 Number

>  非 `Date` 日期对象之外的对象用

先用 `valueOf()`， 再用 `toString()`，最后返回数字，否则报错

```js
x = []， 
- 先用valueOf返回对象本身，空数组 []
- 再用toString()， 返回空字符串 ''
- 然后JS再转换成数字 0
```



### Object 转 Array

```js
// 1 原对象
const object = {
  "name": "Chaoyang Gan",
  "title": "Engineer",
  "subject": "Maths"
}

// 2 拿到对象 Key 数组
const keys = Object.keys(object) // ["name", "title", "subject"]

// 3 map 方法转换成（对象数组）
const list = keys.map(key => {
  return {
    key, value: object[key]
  }
})

// 3.1 结果
console.log(list)
//=> [
// {key: "name", value: "Chaoyang Gan"},
// {key: "title", value: "Engineer"},
// {key: "subject", value: "Maths"}
// ]

// 4 也可以转换成（二维数组）
const pairs = keys.map(key => {
  return [ key, object[key] ]
})

// 4.1 结果
console.log(pairs)
// => [
// ["name", "Chaoyang Gan"],
// ["title", "Engineer"],
// ["subject", "Maths"]
// ]
```



### 重写 valueOf 和 toString

```js
const foo = {
  toString () {
    return 'error'
  },
  valueOf () {
    return 1
  }
}

alert(foo) // error。更加倾向于 toString 
console.log(1 + foo) // 2
```



#### 面试题：a===1&&a===2&&a===3 可能为true吗

如果a是数字，是不可能为true的。所以肯定是从类型转换上来考虑

##### == 的宽松匹配 

> a==1 && a==2 && a==3

要满足这样一个表达式：

- 首先 `a` 本身就不是一个简单数值类型。内部一定进行了 `+1` 的逻辑处理。



这里先要了解 JS 对象中有**两个原型方法**

- 原型，可以暂时理解为 Java 中的抽象类。
- 这两个方法是 `valueOf` 和 `toString` 



##### 关于 == 的一些规则

- 对象 == 字符串，会让对象 .toString 转为字符串，再用 Number 转为数字
- null == undefined 相等，但是与其他值不相等
- NaN == NaN 不相等
- 剩下的情况都转为数字比较



###### **如何触发这2个方法？**

如现在的情况，使用 `==` 让 `a` 不得不进行类型转换去与 `1/2/3` 进行比较时，就会触发这2个方法。



###### **这2个方法的触发顺序？**

若两个方法同时存在， 先执行 `valueOf` 若返回的不是基本类型数据则再执行 `toString` 方法。



解决该题目本身，只需要重写其中一个方法就可以了。两者选其一

```js
// 改写 toString
var a = {
  value:1,
  toString(){
    return a.value++
  }
}

// 改写 valueOf
var a = {
  value:1,
  valueOf(){
    return a.value++
  }
}
```



##### 2）=== 的严格匹配

在 `===` 严格匹配，还要进行类型的校验。所以是不会触发上述的两个原型方法的。

那就得继续从对象本身找方法了。



在 JS 对象中，能够做到这种行为的方式有很多，特别是在 ES6 之后。

就跟 `javabean` 一样，一个字段有 `get/set` 方法，这在 JS 中也是通用的

这里仅介绍一种主流方式 `Object.defineProperty` 

```js
let value = 0
Object.defineProperty(window, 'a', {
  get: function() {
    return ++value
  }
})
```



### Array 和 String 互转

```js
'1,2,3,4,5'.split(',') // [ 1, 2, 3, 4, 5 ]， 字符串转数组
[ 1, 2, 3, 4, 5 ].join() // 1,2,3,4,5，数组转字符串
```



## 包装对象

### 基本知识

#### 临时对象

在存取字符串、数字或布尔值的属性时， 创建的临时对象。

> 根据上面的定义，他们只是在用的时候临时存在，而在语句结束后就进行销毁这临时对象。
>
> 简单的说就是能够使用他们的方法，但是他们并不是对象，只是在用他们方法的时候生成了临时对象。
>
> 所以在一些要求高性能的地方，要避免频繁做装箱转换。



#### 获取包装对象的私有Class属性

每一类包装对象都有私有的class属性，且在JS中没有办法更改他们。

需要注意，call本身会产生装箱操作，最后还是要配合 typeof 来区分基本类型还是对象类型。

```js
// 所有用 typeof 返回值为 object 的对象都包含一个内部属性 [[class]]
// 可以用下面的方式来查看
var symbolObject = Object((Symbol("a"));
//[object Symbol]
console.log(Object.prototype.toString.call(symbolObject)); 
```



### 装箱转换

指的是把基本类型（Number， String， Boolean， Symbol）转换为对应的对象。

#### new 显式创建对象

```js
var  s = 's'
var S = new String(s)
var n = 1
var N = new Number(n)
var b = true
var B = new Boolean(b)
```

尽管这样创建之后，他们的值是一样的，但实际上类型是不一样的。

```js
s == S // true
s === S // false
```



#### Symbol 函数装箱

全局的 `Symbol` 函数无法使用` new` 来调用，但是可以用装箱机制得到 Symbol 对象。利用函数的 `call` 方法强迫产生装箱。

```js
// 定义函数，调用 call 方法到一个Symbol类型的值上，就产生了 SymbolObject
var symbolObject = (function(){ return this; }).call(Symbol("a"));

// 方法2，可以显示调用 Object 调用装箱能力。结果都是一样的
var symbolObject2 = Object((Symbol("a"));
    
console.log(typeof symbolObject); //object
//true, 的确是 Symbol 类的实例
console.log(symbolObject instanceof Symbol); 
console.log(symbolObject.constructor == Symbol); //true
```



### 拆箱转换

#### 隐式类型转换

##### Object 转 Number/String

对象到 String 或者是 Number 都是先拆箱后转换。

- 通过拆箱，将对象变为基本类型
- 然后再转换为对应的 String 或 Number

```js
// 定义对象 o，且重写2个方法。
var o = {
    valueOf : () => {console.log("valueOf"); return {}},
    toString : () => {console.log("toString"); return {}}
}

o * 2 // Number 类型拆箱
// 拆箱尝试调用 valueOf 和 toString 来获得基本类型。若他们都不存在，则产生类型错误 TypeError
// 下面是先执行 valueOf, 再执行 toString，最后执行TypeError，说明拆箱转换失败。
// valueOf
// toString
// TypeError

o + "" //String 类型拆箱，会先调用 toString
// toString
// valueOf
// TypeError
```



#### Symbol.toPrimitive

> ES6之后，允许对象显式指定 Symbol.toPrimitive， 来覆盖原有行为
>
> 可以用于 Object 转 基本类型

```js
var o = {
    valueOf : () => {console.log("valueOf"); return {}},
    toString : () => {console.log("toString"); return {}}
}

o[Symbol.toPrimitive] = () => {console.log("toPrimitive"); return "hello"}


console.log(o + "")
// toPrimitive
// hello
```



#### JSON.stringify 序列化成 JSON 字符串

```js
// 参数1，需要序列化的对象
// 参数2：数组或函数，决定序列化哪些属性
// 若是函数，则先针对对象本身调用一次，然后对每个属性调用一次函数
// 每次传递 k,v
JSON.stringify( a, function(k,v){
    if (k !== "c") return v;
});
// 参数3：打印格式化，缩进的数量或者占位符
JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```



#### 转 JSON

我们用 `JSON.stringify` 进行序列化成字符串，而 `ToJSON` 就是想要返回一个字符串化的安全的 JSON 值，而不是简单的转为字符串

```js
var a = {
  val: [1,2,3],
  // 可能是我们想要的结果！
  toJSON: function(){
    return this.val.slice( 1 );
  }
};
var b = {
  val: [1,2,3],
  // 可能不是我们想要的结果！
  // 是对返回的字符串又做了字符串转化，最终就不是数组本身了
  toJSON: function(){
    return "[" +
      this.val.slice( 1 ).join() +
      "]";
  }
};
JSON.stringify( a ); // "[2,3]"
JSON.stringify( b ); // ""[2,3]""
```



#### 转 Boolean

假值，用布尔强制转换结果为 false

```js
undefined
null
false
+0, -0, NaN
""
```

假值对象，布尔转换后是 true

```js
var a = new Boolean( false ); // 注意这种用法，但是转换后还是 true
var b = new Number( 0 );
var c = new String( "" );
[], {}, function(){} // 也都是真值
```



#### 显式类型转换

推荐用显示强制类型转换，可读性和维护性高。

一般来讲，一元运算符基本可以作为转换符来使用

##### Date 转 Number

```js
var timestamp = +new Date(); // 时间戳
var timestamp = Date.now(); // ES5 加入方法。推荐使用
new Date(..).getTime() // 来获得指定时间的时间戳。

// 老浏览器的 polyfill
if (!Date.now) {
    Date.now = function() {
        return +new Date();
    };
}
```



##### ~ 运算符

这是非操作。字位运算符只适用于 32 位整数，会调用抽象操作 `ToInt32` 实现。

首先执行 `ToNumber` 转为数字类型，然后执行 ToInt32 转为 32 位数字，后执行字位非操作对每个字位进行反转

主要是与如 `indexOf` 这种失败返回 -1 的方法一起用，对结果反转。只要不是 -1，都是真

> ~x 大致等同于 -(x+1)

```js
var a = "Hello World";
~a.indexOf( "lo" ); // -4 <-- 真值!
if (~a.indexOf( "lo" )) { // true
    // 找到匹配！
}
~a.indexOf( "ol" ); // 0 <-- 假值!
!~a.indexOf( "ol" ); // true
```



##### ~~ 小数截除

第一个 `~` 将值截除为 32 位整数并反转，第二个再一次反转回到原值，结果仍是 ToInt32 的结果。

虽然与 `Math.floor` 一样，用于取整。但是对于负数的处理有点不同

```js
Math.floor( -49.6 ); // -50
~~-49.6; // -49
```



## 可变对象和不可变值

在 JS 中对象引用是可以进想改变的，而原始值如（String， number等）是不可变的。



### 不可变的基本值

很多人初看的时候发现，`var a = 1`, 继续 `a = 2`，不是改变了吗？

其实是每次创建变量的时候，值是保存在了一个内存地址中，然后a指向的是这个地址。

当你重新创建变量，也就是改变了a对于内存地址的指向，指向了2，但是1仍然在原来的内存中。这个原有地址中的值（1）无法修改，只能等JS垃圾回收。

```js
var x = false // 定义的时候是一个Boolean
var y = x.toString() // y = 'false'， 这里是字符串
x // 还是false，boolean类型的数据
```





### 可变的对象引用

#### 复制一个数组

不能简单做 = 处理。这样复制的只是原数组的地址引用。

```js
var a = [1, 2]
var b = a // 复制的是引用地址
b[0] = 2 // 做出修改，此时a[0]也是2。所以这样做有风险
```



#### 比较两个数组

数组的比较不同于字符串的比较，由于字符串是不可变类型数据，所以比较的时候只要满足每个字符完全相等就可以了。

但是数组是引用类型，直接比较，比的是他们的引用地址



#### 上面重视情况的解决方案

- 复制数组：利用遍历来显示复制每一个数组元素到新数组对象中
- 比较数组：先比较两数组的长度，然后通过遍历对比每一个元素的值



