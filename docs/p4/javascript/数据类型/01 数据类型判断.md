# 数据类型判断

## 基础知识

### 七类数据

目前 JS 有 7 种数据类型

- null
- undefined：变量未拥有值时
- boolean
- number：里面还有个 `NaN` 要注意
- string
- object: 包括 function, array, date 等
- symbol



### 四种判断方式

大致上有 4 种判断方式

- typeof
- instanceof
- Object.prototype.toString
- constructor



## typeof

> 先说结论，无法用 `typeof` 判断所有类型

可以判断除了 `null` 之外的基本类型，以及  `symbol`



### 判断基本类型

#### 正常类型判断

```js
typeof null // "object", Null 会被判断成 object
typeof 5 // "number"
typeof 'error' // "string"
typeof undefined // "undefined"
typeof true // "boolean"
typeof Symbol('xx') // 'symbel'
```



#### NaN 的判断

也是属于 `Number` 类型

```js
typeof NaN // number
```



#### Null 的判断

这确实是 JS 语言的一个 bug，不太可能会修复，因为20多年了，涉及了太多的 web 程序

```js
// 注意点
typeof null === 'object' // true
```



所以若要判断是否为 `null` 需要用复合条件

```js
// 判断 null 类型需要用复合条件
(!val && typeof val === 'object') // true
```



同样因为这个 bug，在判断对象类型 `object` 的时候也要先排除 `null`

```js
if (someVal !== null && typeof someVal === 'object') {
  // someVal 是一个对象
}
```



#### undefined 的判断

`undefined` 和 `undeclared` 两个完全是两码事

```js
var a
a // 'undefined'，声明了变量但没有赋值
b // ReferenceError: b is not defined，没有声明过该变量
```



但是若用 typeof 去判断，结果是一样的，很无语

```js
typeof a // 'undefined'
typeof b // 'undefined', 没有报错是因为 typeof 有特别的安全机制
```





### 判断复杂类型

#### 特殊的 function 类型

```hs
// 在复杂对象中，只有 function 会被直接解析，其他都是 object
const foo = () => 1
typeof foo // "function"
```



#### 其余对象类型

复杂类型也就是一些引用对象，如 `date`

```js
// 对象，数组，方法


const foo = {}
typeof foo // "object"

const foo = []
typeof foo // "object"

// 日期
const foo = new Date()
typeof foo // "object"
```



#### 特殊用法

连续使用两次 `typeof`

```js
// 特殊用法
// 第一次 typeof 42 ，为 'number'
// 第二次 typeof 'number' 为 'string'
typeof typeof 42 
```



### typeof 的弊端安全防范措施

<a data-fancybox title="" href="https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109144441.png">![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200109144441.png)</a>

下面是使用 typeof 的运算结果，与运行时类型的规定有很多不一致的地方。有2个特例。

- Object -> Null
- Function -> Object



虽然有上述的弊病，但是也有好处，如一个命名空间的变量，是通过引入其他配置文件拿到的

```js
// 改文件是根据运行环境来决定是否加载

// 这种情况若变量不存在，则会报错
if (config) {}

// 使用 typeof 避免报错。就是变量未定义或者未赋值的情况
if (typeof config === 'undefined') {}

// 常见的处理方案：存在就用，不存在就自己定义
typeof config !== 'undefined' ? config : function() {}
```



## instanceof

> 先说结论，无法用 `instanceof` 判断所有类型

`a instanceof B`

判断的是 a 是否是 B 的实例，本质上就是：a 的原型链上是否存在 B 构造函数

其中有个坑，就是跨页面（`iframe`）判断父页面的某个类型，会出现错误。因为同一个数据，在父子页面的地址内存不一样。如果是当前页面，没有问题。



### 用法

因为 p 是Person构造出来的实例，顺着原型链能找到Object的原型。

```js
function Person(name) {
    this.name = name
}
const p = new Person('lucas')

p instanceof Person // true
// p.__proto__.__proto__ === Object.prototype
p instanceof Object // true。
```



### 特殊情况

#### 基本类型判断

比如 string 和 boolean 类型的基本数据类型。

5 不是 new 出来的实例，而是基本类型。这是需要注意的

```js
5 instanceof Number // false
new Number(5) instanceof Number // true
```



#### 数组的判断

因为 `Array` 也是  `Object` 

```js
const obj = {}
const arr = []
obj instanceof Object // true
arr instanceof Object // true
arr instanceof Array // true
```



### instanceof 原理

```js
// L 表示左表达式，R 表示右表达式
const instanceofMock = (L, R) => {
  if (typeof L !== 'object') {
    return false
  }
  while (true) { 
    if (L === null) {
      // 已经遍历到了最顶端
      return false
    }
    if (R.prototype === L.__proto__) {
      return true
    }
    L = L.__proto__ // 一直顺着原型链找
  } 
}
```



使用方式

```js
instanceofMock('', String) // false
instanceofMock(new String(''), String) // true

function Person(name) {
  this.name = name
}
const p = new Person('lucas')

instanceofMock(p, Person) // true
```



## constructor

>  查看目标的构造函数

但是对于 `undefine` 和 `null`。若尝试取其 `constructor` 属性，会报错。

且 `constructor` 返回的是构造函数本身，一般不用于判断类型。

```js
var foo = 5
foo.constructor
// ƒ Number() { [native code] }

var foo = 'Lucas'
foo.constructor
// ƒ String() { [native code] }

var foo = true
foo.constructor
// ƒ Boolean() { [native code] }

var foo = []
foo.constructor
// ƒ Array() { [native code] }

var foo = {}
foo.constructor
// ƒ Object() { [native code] }

var foo = () => 1
foo.constructor
// ƒ Function() { [native code] }

var foo = new Date()
foo.constructor
// ƒ Date() { [native code] }

var foo = Symbol("foo") 
foo.constructor
// ƒ Symbol() { [native code] }

var foo = undefined
foo.constructor
// VM257:1 Uncaught TypeError: Cannot read property 'constructor' of undefined at <anonymous>:1:5

var foo = null
foo.constructor
// VM334:1 Uncaught TypeError: Cannot read property 'constructor' of null at <anonymous>:1:5
```



## toString 终极解决方案

```js
console.log(Object.prototype.toString.call(1)) 
console.log(Object.prototype.toString.call(NaN))
// [object Number]

console.log(Object.prototype.toString.call('lucas')) 
// [object String]

console.log(Object.prototype.toString.call(undefined)) 
// [object Undefined]

console.log(Object.prototype.toString.call(true)) 
// [object Boolean]

console.log(Object.prototype.toString.call({})) 
// [object Object]

console.log(Object.prototype.toString.call([])) 
// [object Array]

console.log(Object.prototype.toString.call(function(){})) 
// [object Function]

console.log(Object.prototype.toString.call(null)) 
// [object Null]

console.log(Object.prototype.toString.call(Symbol('lucas'))) 
// [object Symbol]
```



可以封装出通用方法

```js
var type = function(data) {
  var toString = Object.prototype.toString;
  var dataType =
      data instanceof Element
        ? "element" // 为了统一DOM节点类型输出
        : toString
          .call(data)
          .replace(/\[object\s(.+)\]/, "$1")
          .toLowerCase()
  return dataType
};

```



使用方式

```js
type("a") // string
type(1) // number
type(window) // window
type(document.querySelector("h1")) // element
```

