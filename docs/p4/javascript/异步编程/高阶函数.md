# 高阶函数与 AOP

## 高阶函数

### 基础知识

#### 什么是高阶函数

- 函数的参数是一个函数（回调函数）
- 函数返回一个函数

```js
function(fn) {
  // fn 是函数，也是参数
  return function(){
    // 返回一个函数
    fn()
  }
}
```



#### 数据类型的判断

##### 四种判断方式

- typeof，无法判断对象类型，但可以特别判断 `function`
- constructor，判断当前变量的构造函数是谁，如  `[]` 就是 `Array` 构造出来的
- instanceof，只能判断 A 是 B 的实例，主要是利用 `__proto__`，无法判断一些基本类型。
- Object.prototype.toString.call，精准判断

```js
function isType(content, type) {
  return Object.prototype.toString.call(content) === `[Object ${type}`
}
console.log(isType('hello', 'String'))
```



##### 高阶函数优化判断

利用高阶函数，实现保存变量（闭包）

> 闭包就是在函数定义的时候，就决定了他所在的作用域。
>
> 或者说一个函数不在自己所在作用域下执行

```js
function isType(type) {
  // 将 type 变量保存在这个作用域下，该区域无法被销毁
  // 相当于闭包把变量私有化在这里
  return function(content) {
    return Object.prototype.toString.call(content) === `[Object ${type}`
  }
}

let isString = isType('String')
isString('str')
```



#### 函数的柯里化/反柯里化

- 柯里化（原本多个参数可以一次传一个，每次生成一个函数），让函数作用更具体

- 反柯里化（扩大函数的范围），如 Object.prototype.toString 只能在字符串原型范围用，然后要扩展成直接调用 toString() 就行





### 函数切片/劫持（AOP）

> 面向切面编程 AOP
>
> 也可以叫装饰模式，保留原有的功能

让在某函数执行之前，先执行一些逻辑

可以解决的问题很多，比如写一个公共方法，避免多人维护引起新的 bug

```js
function say(who) {
  console.log('say' who)
}

// 让所用方法都有这个 before
// 统一扩展公共方法
Function.prototype.before = function(cb) {
  // 谁调 before ，谁就是 this。用 => 函数，绑定 this
  // 箭头函数中没有 this 和 arguments，用剩余运算符
  return (...args) => { // 这个就是 newSay
    cb() // 先执行 Before 中的逻辑
    
    // 执行调用这个方法的所有者，这里是 say()
    // 用展开运算符传入所有参数
    this(...args) 
  }
}

// 在执行 say 之前执行 before 中的逻辑
// 先通过 prototype 找
// 找不到去原型链上找 __proto__
let newSay = say.before(function() {
  console.log('before say')
})

newSay('我') 
// 'before say'
// ‘say 我’
```



### 高阶函数在异步中的应用

#### 什么是异步

> 异步的解决方案，最早就是基于 `回调函数`

- 执行后的返回结果不能立马获取，比如 ajax 请求要等待同步代码执行完毕后，才会获取最终结果



#### node 中的异步

- node 中的文件操作都是异步的
  - node 中的回调函数第一个参数，永远是 `error`
- 异步不能使用 `try...catch`，它只能捕获同步代码

```js
let fs = require('fs') // 文件系统模块，读写文件

// 基于回调获取结果
function after(times, cb) { // lodash 中常用
  // times 会被保存在当前执行上下文中
  let renderObj = {}
  return function(key, value){ // 就是 out 函数
    renderObj[key] = value
    if(--times == 0) {
      // 就是 out 函数中回调函数
      cb(renderObj)
    }
  }
}

let out = after(2, function(renderObj) {
  console.log(renderObj)
})

// 文件读取（异步操作）
fn.readFile('./name.txt', 'utf-8', function(err, data) {
  out('name', data)
})
```





## 发布订阅和观察者模式

### 发布订阅模式

> 基本所有库都存在发布订阅模式
>
> 主要是在多个类之间接触耦合关系，订阅和发布可以不在一起

```js
let fs = require('fs') // 文件系统模块，读写文件

// 订阅
// 每次发布 emit 时都会触发该函数
let e = {
  _obj: {},
  _cb: [], // 可能订阅多件事
  
  // 订阅：将函数放到数组中
  on(cb) {
    this._cb.push(cb)
  },
  // 发布，广播一下所有订阅的事件（遍历）
  emit(key, value) {
    this._obj[key] = value
    // 让订阅中的方法，依次执行，并把值传进去
    this._cb.forEach(method => {
      method(this._obj)
    })
  }
}

// 订阅一下
e.on(function(obj) {
  // 用户自己根据结果执行代码
  if (Object.keys(obj).length === 2) {
    console.log(obj)
  }
})

fn.readFile('./name.txt', 'utf-8', function(err, data) {
  // 发布一下
  e.emit('获取结果', 'key', data) // 发布
})
```



### 观察者模式

- **发布订阅模式**，特点是订阅/发布双方之间没有任何关系

- **观察者模式**，需要有观察者去监视被观察者，被观察者状态发生变化，需要通知所有的观察者（基于发布订阅模式）

```js
// 被观察者类
class Subject {
  constructor(name) {
    this.name = name
    this.state = '开心'
    this.observers = []
  }
  
  attach(o) { // 需要将注册者放在自己身上
    this.observers.push(o) // 就是 on
  }
  
  // 改变状态方法
  setState(state) {
    this.state = state
    // 发布订阅，依次执行。
    // 就是 emit
    this.observers.forEach(o => {
      // o 就是每一个观察者实例
      o.update(this)
    })
  }
}

// 观察者类
class Observer {
  constructor(name) {
    this.name = name
  }
  // 等被观察者的状态发生变化，就会调用该方法
  update(s) {
    console.log(this.name + ':' + s.name + '当前的状态是' + s.state)
  }
}

ley baby = new Subject('宝宝')
let parent = new Observer('爸爸')
let mother = new Observer('妈妈')
baby.attach(parent)
baby.attach(mother)
baby.setState('不开心')
```

