# 异步解决方案总结

现在从一个动画需求，实现一个“运动路径动画”的流程

- 移到页面目标元素 `(document.querySelectorAll("#main")[0]`

- 运动轨迹： 从原点出发，向左20px，向上50px，再向左30px

- 整个运动流程是串联的，上一个任务结束后就进入下一个任务。

将运动的过程封装成 walk 函数，且接受 `3` 个参数

```js
function walk(direction, distance, callback){
    // direction：字符串。移动方向。简化成枚举['left', 'top]
    // distance：整型。移动距离。可正可负。在原有2个方向上多出2个，一共4个方向
    // callback：动作执行后回调
}
```



## callback 回调函数

### 基本使用

这是ES5中常配合 `AJAX` 和 `nodejd-express` 请求使用。

`callback` 就是被当做某个方法参数的函数，可以在这个方法中任意位置执行，就像使用变量一样。

```js
function A(callback){
    console.log("我是主体函数");
    callback();
}
function B(){
    console.log("我是回调函数");
}
A(B);

/*输出结果
我是主体函数
我是回调函数
*/
```



### 解决问题

```js
const target = document.querySelectorAll('#man')[0] // 获取元素DOM
// 定义DOM样式。初始化DOM位置定位
target.style.cssText = `
position: absolute;
left: 0px;
top: 0px
`
// 使用回调方案，封装运动方法
const walk = (direction, distance, callback) => {
  setTimeout(() => {
    // 元素当前的位置
    let currentLeft = parseInt(target.style.left, 10) // 解析成整数
    let currentTop = parseInt(target.style.top, 10)

    // 终止位置：向左distance距离， 向上distance距离
    const shouldFinish = (direction === 'left' && currentLeft === -distance) 
    || (direction === 'top' && currentTop === -distance)

    if (shouldFinish) { // 本次运动结束，执行下一个回调
      callback && callback()
    }
    else { // 本次运动没有结束，继续位移
      if (direction === 'left') { // 规定向左运动时。改值后赋值给DOM位置样式信息
        currentLeft--
        target.style.left = `${currentLeft}px`
      }
      else if (direction === 'top') { // 同理
        currentTop--
        target.style.top = `${currentTop}px`
      }

      walk(direction, distance, callback) // 继续进行本次运动
    }
  }, 20) // 每20ms，位移1px
}

// 执行方法。多层回调嵌套，回调地狱。
walk('left', 20, () => {
  walk('top', 50, () => {
    walk('left', 30, Function.prototype)
  })
})
```



## Promise 对象

### 基本使用

ES6中配合 `axios` 使用。`promise` 对象有2个参数

- 成功时调用 `resolve`（不一定是显示写法，成功调用后使用 `return` 也算是调用了 resolve）
- 失败时调用 `reject`。其中分别可以在 `then`， `catch` 中的回调中直接获取到通过他们传递的值。

```js
return new Promise((resolve, reject) => {
  if ('成功调用') { resolve(data) }
  else if ('失败调用') { reject(msg) })
}).then(data => {}) .catch(err => {})
```



then和catch返回的都是相同的 promise 对象，所以可以 `链式调用`。



### 解决问题

不需要 callback。而是函数整体返回一个 promise，以利于后续任务的控制和执行。

```js
const target = document.querySelectorAll('#man')[0]
target.style.cssText = `
position: absolute;
left: 0px;
top: 0px
`

const walk = (direction, distance) => 
new Promise((resolve, reject) => { // 已经没有了callback
  // 将运动逻辑作为函数封装在 Promise 内，作为一个 Promise对象，以方便后续链式调用
  const innerWalk = () => {
    setTimeout(() => {
      let currentLeft = parseInt(target.style.left, 10)
      let currentTop = parseInt(target.style.top, 10)

      const shouldFinish = (direction === 'left' && currentLeft === -distance) 
      || (direction === 'top' && currentTop === -distance)

      if (shouldFinish) { // 本次动画结束, resolve()当前promise
        resolve()
      }
      else {
        if (direction === 'left') {
          currentLeft--
          target.style.left = `${currentLeft}px`
        }
        else if (direction === 'top') {
          currentTop--
          target.style.top = `${currentTop}px`
        }

        innerWalk() // 每20ms进行1px位移的递归调用
      }
    }, 20)
  }
  innerWalk()
})

// 因为 walk 函数本身返回的是promise，所以可以链式调用
walk('left', 20)
  .then(() => walk('top', 50))
  .then(() => walk('left', 30))
```



## Generator 迭代生成器

### 基本使用

这是一个生成器，生成的是`迭代器`，可以让代码执行暂停。之前是没有这种特性的，一段代码要么执行要么不执行。这里只需要在函数之前加一个`*` 号，就表示要使用 `generator`。

```js
function *main() {
  var result1 = yield readFile("a.txt");
  console.log(result1);

  var result2 = yield readFile("b.txt");
  console.log(result2);

  var result3 = yield readFile("c.txt");
  console.log(result3);
}
```



使用 `yield` 让代码分块，在执行这个函数的时候，必须执行 `main()`, `next()`才能一步步执行下去。

我们可以用递归函数去自动执行生成器 `next()`

```js
function next() {
    let {value, done} = gen.next() // 启动。注意第一次next传参数是没有意义的，无法传参
    console.log(value) // 依次打印 yield 返回值
    if (!done) next() // 直到迭代完成
}
next()

// 循环的方式
let done = false 
while(!done) {
  // 传参会给 yield 之后的表达式
  let obj = it.next('xx')
  done = obj.done
  console.log(value)
}
```



### generator + promise

```js
const util = require('util');
const fs = require('fs');
let read = util.promisify(fs.readFile);
function * readAge(){ // 暂停的功能
    let content =  yield read('./name.txt','utf8');
    let age = yield {}
    return age;
}
```



### co 库

TJ 大神

```js
function co(it) {
  return new Promise((resolve, reject) => {
    // 异步迭代，需要 next 函数
    function next(r) {
      let {value, done} = it.next(r)
      if(done) {
        resolve(value)
      } esle {
        Promise.resolve(value).then(data => {
          next(data)
        }, reject)
      }
    }
    next()
  })
}

// 返回 promise，直接使用 co 函数
co(readAge()).then(data => {
  console.log(data)
})

// try..catch 的用法
function* test() {
  try {
    yield 100
  } catch{
    console.log('error')
  }
}
let it = test()
it.next()
it.throw('hello') // 手动抛错

// 依次去执行生成器，不停调用 next 方法，将最终结果返回
```

后面的 async/await 也就是基于 co 库来实现



### 解决问题

generator 本身是用来作为迭代器的，但是本身又非常适用于异步控制

```js
const target = document.querySelectorAll('#man')[0]
target.style.cssText = `
position: absolute;
left: 0px;
top: 0px
`

const walk = (direction, distance) => 
new Promise((resolve, reject) => {
  const innerWalk = () => {
    setTimeout(() => {
      let currentLeft = parseInt(target.style.left, 10)
      let currentTop = parseInt(target.style.top, 10)

      const shouldFinish = (direction === 'left' && currentLeft === -distance) 
      || (direction === 'top' && currentTop === -distance)

      if (shouldFinish) {
        resolve()
      }
      else {
        if (direction === 'left') {
          currentLeft--
          target.style.left = `${currentLeft}px`
        }
        else if (direction === 'top') {
          currentTop--
          target.style.top = `${currentTop}px`
        }

        innerWalk()
      }
    }, 20)
  }
  innerWalk()
})

// 前面部分与promise没有区别，在调用时用到了生成器函数
function *taskGenerator() {
  yield walk('left', 20)
  yield walk('top', 50)
  yield walk('left', 30)
}
const gen = taskGenerator() // 实例一个生成器任务列表

// 要让其执行，需要手动执行 next()
gen.next() // 向左20px
gen.next() // 向上50px
gen.next() // 向左30px
```



## async/await 函数

### 基本使用

> 返回一个promise对象，如果不是一个promise对象，也会将其封装成promise对象返回。

`await` 阻塞代码执行，直到之后的表达式处理完，才能执行下面的代码。

await之后可以是 `promise对象`，表达式或者是值。如果返回的是一个 promise，那 await 会等待其返回的 `resolve` 或者是 `reject`。

```js
async function B(){
  return "World";
}
async function C(){
  //等待一个promise对象，await的返回值是promise对象resolve的值，也就是"World"
  var s2=await B()
  console.log(s2); // World
}
```



#### 继续使用 .catch

因为 await 后面的表达式都是 promise，所以可以这样用

```js
// 1 直接链式
a = await ajax(a).catch(e => console.log('axx'))

// 2 捕获整个 async
arrAjax(1, 2)
.then()
.catch()
```



### 什么时候用 async/await

并不是所有的异步代码都需要使用到这组语法

```js
// 使用 async 的情况
// 1 返回值不是一个 Promise， 使用 async 可将函数返回值包装成 promise
// 2 使用了 await，就必须在 async 函数中

// 使用 await 的情况
// 当异步后续还有处理逻辑，且要求是同步执行顺序时，可以使用 await
```



### async 的错误处理和重启

#### 重启方式：计数

```js
const NUM_RETRIES = 3;

async function test() {
  let i;
  // 失败后尝试重试3次
  for (i = 0; i < NUM_RETRIES; ++i) {
    try {
      await axios.get('http://google.com/this-throws-an-error');
      break;
    } catch(err) {}
  }
  console.log(i); // 3
}

test();
```



#### try...catch 捕获错误

```js
try {
  const user3 = await fetchUser(true)
} catch (err) {
  console.error('user3 error:', err)
}
```



#### 基于 promise 统一返回格式

```js
// 包装promise, 使其返回统一的错误格式
// @param {Promise} promise 
function to (promise) {
  return promise.then(res => [null, res]).catch(err => [err])
}

const [err, res] = await to(fetchUser(true))
if (err) {
  console.error('touser err:', err)
}
```



### 并行调用 async

```js
// 1 异步操作
function ajax(param) {
  return new Promise(resolve => {
    setTimeout(resolve(param * 2), 1000)
  })
}

// 2 并发
async function arrAjax(a, b) {
  [a, b] = await Promise.all([ajax(a), ajax(b)])
}

// 3 使用
arrAjax(1, 2).then(/*...*/)
```



### for...of...await 异步迭代

使用 `for...of..` 的原因是，使用 `forEach` 是不支持 async/await 的。

当然用普通的 for 循环也是可以的。

forEach 有诸多限制，比如不能使用 `break`

```js
// 1 promise 数组
const promises = [
  new Promise(r => r(1)),
  new Promise(r => r(2)),
  new Promise(r => r(3))
]

// 2 不会等待 promise 返回 resolve 的用法
async function t1(){
  for(const obj of promises) {console.log('t1>>>', obj)}
}

// 3 正确的用法，每此迭代都会等待 resolve 的返回
async function t2(){
  for (const obj of promises){
    let res = await obj.catch(err=>console.log('失败处理>>>', err))
    res ? console.log('成功处理>>>', res) : void 0
  }
}
```



使用 `for..of..`还有一个好处，就是可以拿到 `index 索引`，这是普通 for 不能直接做到的

注意要配合数组方法 `entries` 拿到`键值对`（key 就是数组索引）

```js
for (let [index, cur] of arr.entries()) {
  console.log(index, cur);
}
```





### 解决问题

可以看到 Promise 依旧是核心。async/await就是generator的语法糖而已。能够自动执行生成器函数，更加方便实现异步流程。

```js
const target = document.querySelectorAll('#man')[0]
target.style.cssText = `
position: absolute;
left: 0px;
top: 0px
`

const walk = (direction, distance) => 
new Promise((resolve, reject) => {
  const innerWalk = () => {
    setTimeout(() => {
      let currentLeft = parseInt(target.style.left, 10)
      let currentTop = parseInt(target.style.top, 10)

      const shouldFinish = (direction === 'left' && currentLeft === -distance) 
      || (direction === 'top' && currentTop === -distance)

      if (shouldFinish) {
        // 任务之行结束
        resolve()
      }
      else {
        if (direction === 'left') {
          currentLeft--
          target.style.left = `${currentLeft}px`
        }
        else if (direction === 'top') {
          currentTop--
          target.style.top = `${currentTop}px`
        }

        innerWalk()
      }
    }, 20)
  }
  innerWalk()
})

// async 定义方法，await 用于异步执行阻塞
const task = async function () {
  await walk('left', 20)
  await walk('top', 50)
  await walk('left', 30)
} 
```

