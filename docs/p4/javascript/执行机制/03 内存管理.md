# 内存管理

内存管理是计算机科学中的概念，不论什么程序语言，内存管理都是指对内存生命周期的管理

```js
// 基本上就是创建、读写和释放
var foo = 'bar' // 在堆内存中给变量分配空间
alert(foo) // 使用内存
foo = null // 释放内存空间
```



## 基础知识

### 内存空间的两种类型

- 栈空间 ：由操作系统自动分配释放、存放函数的参数值和局部变量的值等。其操作方式类似于数据结构中的栈
- 堆空间：由开发者分配释放，这部分空间就要考虑垃圾回收的问题



### JS 中的数据类型

- 基本数据类型：如undefined, null, number, boolean, string等
- 引用类型， 如object, array, function等
- 还有ES Next 新的数据类型 symbol（基本数据类型）

基本数据类型放于栈内存，引用类型放在堆内存中

```js
var a = 11
var b = 10
var c = [1, 2, 3]
var d = { e: 20 }
```

对应的内存分配

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200119162502.png)



## 内存泄漏

### 内存泄漏的危害

> 内存泄漏：指内存空间明明已经不再被使用，但是某种原因并没有被释放的现象

分配内存和读写内存的行为所有语言都基本一样。但是释放内存空间，不用语言的处理方式不一样。

javascript 是依赖宿主浏览器的垃圾回收机制，一般情况下也不用我们自己去释放。但是也有一些场景会有内存泄漏现象。

内存泄漏会直接导致程序运行缓慢，甚至奔溃。



### 内存泄漏场景

#### 删除 DOM 节点

获取一个 DOM，移除节点后，但是 element 变量仍然存在。如果去访问 element 变量，还会返回这些节点

```js
var element = document.getElementById("element")
element.mark = "marked"

// 移除 element 节点
function remove() {
  element.parentNode.removeChild(element)
  // 为了防止内存泄漏，还需要 element = null
}
```



#### 事件绑定

element 元素中有 button，为这个按钮绑定事件，然后清空 element 后，因为事件存在还是无法释放内存。

所以还需要解绑事件

```js
var element = document.getElementById('element')
element.innerHTML = '<button id="button">点击</button>'

var button = document.getElementById('button')
button.addEventListener('click', function() {
  // ...
})

element.innerHTML = ''
// 解绑事件才能释放内存  button.removeEventListener('click')
```



#### 循环定时器

window.setInterval 的存在，所以内存无法释放。要手动在合适的时机用 clearInterval 清理

```js
function foo() {
  var name  = 'lucas'
  window.setInterval(function() {
    console.log(name)
  }, 1000)
}

foo()
```



### 垃圾回收机制

浏览器会依靠两种算法来主动进行垃圾回收

- 标记清除
- 引用计数

推荐阅读

- [通过垃圾回收机制理解 JavaScript 内存管理](https://juejin.im/post/5c4409fbf265da616f703d5a)
- [如何处理 JavaScript 内存泄漏](https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585408&idx=1&sn=4de7b5bbfa969d9587c163e98bc90684&source=41#wechat_redirect)
- [垃圾回收](https://segmentfault.com/a/1190000003641343)
- [编写内存友好的代码](https://segmentfault.com/a/1190000007887891)
- [JavaScript 中 4 种常见的内存泄漏陷阱](https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651551451&idx=1&sn=b8447a12eceb467992d432b014d9c026&chksm=8025a11ab752280c7915db4ef726611f645d2fee590d6f0f3f9aeedd55c956454f66f786873a&scene=0#wechat_redirect)
- [记一次网页内存溢出分析及解决实践](https://juejin.im/post/5c3dce07e51d4551e960d840)



## 垃圾回收

### 闭包会占有内存

使用闭包，就会一直占有内存，导致无法被自动回收。

下面这种情况，value 会被保存在内存中。

```js
function foo() {
  let value = 123
  function bar() { alert(value) }
  return bar // 返回的是闭包，用到了外层变量 value
}

let bar = foo()
```



### chrome 查看内存情况

在chrome performance 标签中可以看到内存的变化线。

在chrome memory 标签中去找内存大的数据类型，然后找到变量。

