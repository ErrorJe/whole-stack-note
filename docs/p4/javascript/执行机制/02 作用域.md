# 作用域

作用域在大部分语言中都是差不多的概念，就是一个确定在特定范围场景下如何去查找变量的规则。



## 作用域和编译原理

### 基本常识

在函数内部**声明变量要**使用 `var`

```js
var x = 1
```



若**不通过var声明**，则此变量会在全局对象中注册了该属性

```js
x = 1
```

使用 var 声明的变量是无法被` delete` 的，而在全局对象中注册的属性是可以通过 delete 关键字进行删除回收。



### 编译原理

#### 编译步骤

在传统编译语言的源代码被执行前，都需要经过编译的三个步骤：

- 分词(token）/词法分析：就是讲代码看做字符串，然后找到和划分有意义的最小单位的代码块。这里也叫词法化。
- 解析/语法分析：将上面的字符数组，转换成AST，即抽象语法树
- 代码生成：将AST转换为可执行代码

JS是动态、编译型语言。编译的时机就在代码要执行前非常短暂的时间。如一个代码片段

```js
var a = 2
```

这个变量的赋值操作实际上分为两个部分：

- 编译器：在当前作用域声明该变量 a，并与其作用域进行关联
- 生成执行代码：在作用域中，寻找该变量并赋值



#### 引擎对变量的查找

查找分为两种：

- LHS（写），需要这个值的某个变量——赋值操作的左侧

```js
a = 2 // 要找到 a 变量自己是谁，此时要给 a 赋值
```

- RHS（读），查找某变量的值——赋值操作的非左侧，因为如形参、函数传值等都没有赋值操作，但实际上是赋值

```js
console.log(a) // 要找到 a 的值。相当于是 a = ? 这个表达式右侧的部分
```

LHS 和 RHS 同时存在的地方

```js
function foo(a){
  console.log(a) // 2
}
foo(2)
```

现在来分析一下这段代码的两种查询操作：

- foo(..)，执行时不知道这个东西是什么，所以要执行RHS查询，去找到这个foo的值
- foo(2)，中的2，实际上是隐式地赋值给了 foo(a)中的形参a， 也就是a=2。执行了LHS查询，找到了需要该值的变量，也就是foo中的形参a
- 然后在打印时，需要执行RHS查询去找a在哪里定义的
- 最后执行.log时，还要去执行RHS找这个方法的定义



### 作用域链

当引擎需要找到一个变量时，会去遍历作用域链：从当前的执行作用域开始找变量，若没有则去上一层继续找，直到找到该变量或者顶层（全局作用域）停止。

RHS和LHS查询也会从当前作用域开始一直往顶层找，要是在全局作用域中都没有找到，则会有不同的表现：

- RHS

- - 未找到变量，抛出未定义异常——ReferenceError
  - 找到变量但进行不合理操作如，调用非函数类型、引用null或undefined中的属性，抛出 TypeError 类型异常。也就是作用域判别成功，但是操作非法

- LHS

- - 严格模式下同RHS
  - 非严格模式下会在全局作用域中隐式创建该未找到的变量声明。



#### 词法作用域

编译器在第一步的时候对代码进行了词法化，然后经过词法分析，产生此法作用域。

> 词法作用域，在书写代码时函数声明的位置来决定。
>
> 意义，就是在词法分析阶段就知道所有的标识符在哪里，以及如何声明的。所以在执行的时候能很快找到他们。

但是，JS有2个机制可以欺骗词法作用域。就是eval()和with。

- `eval('var b = 2')` 可以对写入的字符串当作表达式来进行执行，若在字符串中定义了一些标识符，则会动态改变词法作用域。

```js
// 相当于是这段字符串本来是就是写在那的，跟在哪里定义的无关。
function fn(str) {
  eval(str) //  b = 2
}

var b = 3
fn('var b = 2')
```

- `with` 将一个对象作为独立的作用域处理

```js
let obj = {
  a:2,
  b:3
}

// 省略如 obj.a 这样的写法
with(obj) {
  a = 3
  b = 2
}
```

引擎无法在编译时，对他们2个进行查找优化。所以会影响性能。





## 作用域层级

> 模块、全局、函数和块级作用域

### 块级作用域

> 自从JS进入ES6后，引入了let和const以及{}等块级作用域限定，让JS作用域更加丰富。

#### 块作用域

在块级作用域之前，JS只有全局作用域和函数体作用域。

- ES3，try/catch结构在catch分句中具有块作用域。
- JS（ES5）中，变量的局部作用域是方法体。而不是块级（花括号）区域。
- ES6之后，使用let定义的变量作用域是在 { 块级区域 } 内有效。



#### let 作用域

`let` 的出现解决了 `var` 的诸多问题。因为它引入了块级作用域。

以下语句会产生 `let` 使用的作用域， 这个过程是隐式的：

- for
- if
- switch
- try/catch/finally

```js
// 这是为什么 let 应用到 for 循环可以保证每次迭代正确的原理
let j
for(j=0; j<10; i++) {
  let i = j // 每次迭代都重新绑定
  console.log(i)
}
```



函数的参数也算是函数内的块级作用域

- 参数中的 arg1 是属于该函数作用域的
- 所以let无法再次声明同名变量

```js
function foo(arg1) {
  let arg1
}
foo('arg1') // arg1 has already benn declared
```



块级作用域应用的垃圾回收

```js
// a 在块级作用域中，这是显式告诉引擎这个 a 用过后就没用了。可以被回收
{
  let a = {}
  console.log(a)
}

// 如果上面的 a 没有被块级包裹
// 引擎可能会认为这个 a 也许会被 fn 使用（看 fn 具体实现）
function fn(n) {}
```



#### 其他作用域

- with：with 也是块作用域的一个例子，用 with 从对象中创建的作用域仅在 with 声明中有效
- try/catch：其中的 catch 会创建一个块级作用域
- const：跟 let 一样，区别是用于常量。对于原始简单数据类型是常量，也就是修改会报错。



### 全局和函数作用域

> 在ES6之前，JS中只有函数和全局两个作用域。闭包也是利用了函数作用域来创建独立的作用域。在ES6后，增加了模块作用域

变量 `a` 在函数 `foo` 作用域下，直接打印

变量 `b` 在全局作用域下，在 `foo` 函数作用域中没有找到，所以往外找，到全局中找到了变量 `b`

```js
var b = 'xxx'
function foo() {
  var a = 'bar'
  console.log(a, b) 
}
foo() // bar, xxx
```



### 立即执行函数 IIFE

#### 匿名函数

好的地方也是其不好的地方，所以要根据需要去选择。不好的地方有2个：

第一个：匿名函数没有函数名，不好调试，也不好理解函数作用

第二个：无法第二次引用自己，在递归和事件解绑的情况下

```js
var x = function() { ... } // 这个函数的名字是x
function x() {} // 也有这样定义的，函数名字也是x
window.onload = function { ... } // 后面这没有名字的函数就是匿名函数，执行一次。
```



#### 立即执行函数 IIFE 写法

##### 双 () 写法

var 会穿透 for、if等语句。在没有let的时代，利用一个技巧创建一个函数并且立即执行，来构造一个控制var范围的作用域。

```js
// function(){} 是一个函数声明
// (function(){}) 是一个表达式
// (function(){})()    相当于是 fn()， 执行了fn函数。所以这里是自执行函数

// 1 第一个 () 让这个是一个表达式
// 第二个 () 让函数立即执行
(function(){
  var a;
  //code
})();

// 2 第二种写法，没有任何区别，习惯问题
(function(global){
  var a;
  //code
}(window)); // 这里还将window对象作为参数传入

// 3 倒置代码运行顺序的写法：代码冗长，但是更容易理解
// 函数名对于 IIFE 来说不是必须的，但是也可以存在
void function IIFE(def) {
  def(window)
}(function def(global) {
  //code
})
```



##### 分号写法

JS规定function开头是函数声明，要想立即执行，就得是一个表达式，所以要加点的东西。

通常是加个括号，缺点是若上一行代码没有分号，括号会被解释为上一行代码末尾的函数调用，就产生误会。

```js
;(function(){
    var a;
    //code
}())
```



##### void 关键字写法

更加推荐的写法，是使用 `Void` 关键字

它的本意是忽略后面的返回值，变为 `undefined`。我们此时并不在乎返回值，所以可以这样用。

```js
void function(){
  var a;
  //code
}();
```



虽然是匿名函数，但是社区也约定用IIFE来作为自执行函数的名字

```js
void function IIFE(){
    var a;
    //code
}();
```



#### IIFE 解决了什么问题

- 解决了变量的命名污染和变量安全问题。因为变量都在函数作用域内

- 解决利用函数带来自身的命名污染问题，IIFE 是一个匿名函数



### 作用域链

> 若在函数内无法找到该变量，就要跳出该函数作用域，到更外层作用域去找

下面代码中，foo函数无法找到在bar中定义的变量b。

foo 和 bar 是两个独立的作用域。当 foo 作用域中没有找到 变量b 回去外层找，发现全局中也没有，所以 报错

```js
function bar() {
  var b = 'bar'
}
function foo() {
  console.log(b)
}
foo() // b is not defined
```

作用域链就是会一直找到全局作用域

```js
var b = 'bar'
function bar() {
  function foo() {
    console.log(b)
  }
  foo()
}

bar() // bar
```





## 变量提升

### 提升的本质

包括变量和函数在内的所有声明，都会在任何代码被执行前首先被处理。

```js
var a = 2
```

实际上是2个部分：

- var a，在编译阶段声明
- a=2， 等待引擎执行代码



所谓变量提升，也就是变量和函数的声明被提到了前面

```js
console.log(a)
var a = 2 // undefiend

// 为什么会这样呢？来看下真实的代码顺序
var a
console.log(a) // undefined
a=2
```



### 不同作用域下的声明提升

```js
foo()
function foo() {
  console.log(a) // undefined
  var a = 2
}
```



同样来看下真实的代码顺序

```js
// 首先是在全局作用域下的提升
function foo() {
  // 然后是该作用域下的提升
  var a
  console.log(a) // 所以是 undefined，因为没有给值
  a = 2
}
foo()
```



但是要注意的是函数表达式不会被提升

```js
foo() 
var foo = function bar() {}

// 真实的代码顺序
// 标识符被提升，但是foo是表达式，所以foo此时并没有值。所以不是作用域相关的ReferenceError报错，而是对undefined非法操作报的typeError异常
var foo
foo()
foo = function bar() {}
```



### 函数优先

变量和函数的声明都会被提升，但是函数是优先于变量的。

```js
console.log(foo) // [Function: foo]
foo() //1
var foo
function foo(){log(1)}
foo = function(){log(2)}

// 真实的执行顺序
function foo(){log(1)}
// var foo, 这句由于是重复声明，所以被忽略
console.log(foo) // [Function: foo]
foo() //1
foo = function(){log(2)}
```



在看一题

```js
foo(10)
function foo (num) {
  console.log(foo) // undefined
  foo = num;       
  console.log(foo) // 10
  var foo
} 
console.log(foo) // [Function: foo]
foo = 1
console.log(foo) // 1

// ==> 相当于

function foo (num) { // 1 函数提升
  var foo // 2 变量提升
  console.log(foo) // undefined
  foo = num;       
  console.log(foo) // 10
}
foo(10)
console.log(foo) // [Function: foo]
foo = 1
console.log(foo) // 1
```



## 暂时性死区 TDZ

跟块级作用域相关，在该作用域之中，存在“死区TDZ”。它的范围是函数的开头，终止与相关变量声明的那一行。在这个范围内，无法访问let或const声明的变量

### var 声明

foo1执行。在预编译时会进行“变量提升”，但是未赋值。相当于

```js
var bar
console.log(bar) // undefined
bar = 3
```



### let 声明

foo2 执行。存在 TDZ，在打印 bar 时发现并没有对其声明

```js
function foo1() { 
  console.log(bar)
  var bar = 3  
}

function foo2() {
  console.log(bar)
  let bar = 3
}

foo1() // undefined。
foo2() // ReferenceError:bar is not defined
```



### 函数的默认参数受 TDZ 影响

- 当两个参数都传入时，正常显示。

- 但是若第一个参数没有传参，那么根据定义是用了第二个参数arg2的值，但是该阶段相当于 arg2 还没有声明，所以报错

- null 和 undefined 有区别，null 会被认为是值，只是空值而已

```js
function foo(arg1 = arg2, arg2) {
  console.log(`${arg1} ${arg2}`)
}
foo('arg1', 'arg2') // 返回：arg1 arg2
foo(undefined, 'arg2') // Uncaught ReferenceError: arg2 is not defined
foo(null, 'arg2') // null arg2
```

