# 事件机制

## IE6 前的兼容事件处理

在之前有要对 IE 浏览器进行兼容处理的，现在都是使用 chrome 内核的浏览器，所以不用再在乎。

- IE8 和更早版本支持大多数基于 `on` 的事件属性
- IE8和更早版本使用的是 `ttachEvent`。
- IE8和更早版本在事件被调用时， 事件对象 `event` 不是作为回调参数，而是直接挂载在 ` window` 下



> 核心思想就是判断该执行环境下有没有对应的 API

```js
// 脚本加载
window.onload = function() { // IE 是支持 onload() 方法的
  var div = document.getElementById('clickme')
  if (div.addEventListener) { // 判断是否支持这个方法
    div.addEventListener('click', handleClick, false)
  } else if (div.attachEvent) { // IE支持的事件方法， 但事件都是基于on 开头
    div.attachEvent('onclick', handleClick)
  }
}
 
// 方法定义
function handleClick(e) {
  var evt = e || window.event // IE9 以上支持事件对象 e 直接使用。否则只能去 window 中获取
  var target
  if (evt.target) { // IE8和更早版本，触发元素是 srcElement
    target = evt.target
  } else {
    target = evt.srcElement
  }
  alert('You clicked on ' + target.id)
}
```



## 浏览器事件

> 事件来自于输入设备，如键盘，鼠标和触摸屏

其中，触摸屏和鼠标有一定的共性，为 `pointer` 设备，就是它的输入最终会被抽象成屏幕上的一个点。也存在一定的区别，就是精度、反应时间和支持的点数量不一样。



### 捕获与冒泡

- 捕获：从外向内。点击事件来自于触摸屏或者鼠标，计算机将点击的坐标转换为具体元素上的事件的过程。

- 冒泡：从内向外。按电视机的开关，也是按了电视机。因为电视机包含了开关按钮。



#### 捕获与冒泡的过程

对body和input元素分别绑定事件。

```html
<body>
  <input id="i"/>
</body>
```



显示顺序

`key1 -> key2 -> key22 -> key11`

```js
// 捕获，body
document.body.addEventListener("mousedown", () => {
  console.log("key1")
}, true)

// 捕获，input
document.getElementById("i").addEventListener("mousedown", () => {
  console.log("key2")
}, true)

// 冒泡，body
document.body.addEventListener("mousedown", () => {
  console.log("key11")
}, false)

// 冒泡，input
document.getElementById("i").addEventListener("mousedown", () => {
  console.log("key22")
}, false)
```



#### 实际开发与阻止冒泡

建议默认使用冒泡模式，开发组件时，遇到需要父元素控制子元素的行为，才去使用捕获机制。

```js
/* 多个元素嵌套，有层次关系，这些元素都注册了相同的事件
  若里面的元素事件触发了，则外面的元素的该事件也会自动触发
*/
// 事件处理参数对象 event
DOM.event = function(e) { // 事件触发时产生的 e(event)
  // 阻止向外冒泡
  window.event.cancelBubble = true // 谷歌， IE8支持， 火狐不支持
  e.stopPropagation() // 谷歌， 火狐支持, IE8不支持(没有e这个参数对象)
}
```



### addEventListener

> `addEventListener`，同样第三个参数默认是false，即冒泡模式。一般的开发者无需关心，如果是组件开发则需要关心捕获过程。



#### 三个参数

- 事件名

- 处理函数

- 捕获还是冒泡。不一定是boolean值，可以是个对象，提供更多详细的选项

- - once，就执行一次
  - passive，承诺该事件监听不会调用 PreventDefault，有助于性能
  - useCapture，是否捕获（否则冒泡），默认是冒泡模式
  - 可以不传第三个参数。



#### 绑定事件案例

```js
// 1, 获得按钮
var loginButton = document.querySelector('#id-button-login')
// 2, 声明一个函数, 用于在按钮点击后执行
var clicked = function() {
  log('按钮被点击到了')
}
// 3, 添加事件, 使用 addEventListener 函数, 它有两个参数
// 第一个是事件的名字, 第二个是事件发生后会被自动调用的函数
loginButton.addEventListener('click', clicked)

// 4 给多元素挂上同一个事件
// 选择多个元素使用函数 querySelectorAll
var buttons = document.querySelectorAll('.radio-button')
// 循环遍历每个元素, 并且绑定点击事件
for (var i = 0; i < buttons.length; i++) {
  var button = buttons[i]
  button.addEventListener('click', function(event){//匿名函数直接使用
    // 我们增加了一个 event 参数,名字是自定义的不重要，
    // 浏览器会给事件响应函数传递一个参数, 它代表了事件本身

    var self = event.target  // 取出响应事件的元素

    clearActive()  // clearActive 函数是我们自己定义的.把所有的active先清除了
    // add 可以增加一个 class，给自己加上一个active类样式（通过class的增删来改变样式，而不是直接修改样式）
    self.classList.add('active')
  })
}
// 5 目的是删除元素的 active(一个class)
var clearActive = function() {
  var active = document.querySelector('.active')//用同名变量存有active类的元素
  if (active != null) {//存在active
    // 使用 classList 可以访问一个元素的所有 class
    // remove 可以删除一个 class
    active.classList.remove("active")
  }
}
```



## DOM 元素事件

> 只能在DOM元素上使用自定义事件

```js
var evt = new Event("look", {"bubbles":true, "cancelable":false}); // 创造新的事件
document.dispatchEvent(evt); // 在特定元素上触发
```



### 事件的绑定与解绑

#### 元素事件绑定

```js
// 同一个元素可以绑定多个相同的事件 ( IE8不兼容 )
// 事件名字如 click / 事件处理函数 / 是否在捕获阶段触发，冒泡阶段 false, 捕获阶段 true
DOM.addEventListener('click', function(){}, false)
// IE8 中方法, 参数： 事件名（微软的事件有on）/ 匿名函数
// 谷歌、火狐不支持
DOM.attachEvent('onclick', function(){})
 
/* 绑定事件的区别
  addEventListener / attachEvent
  相同： 都可以为元素绑定元素
  不同：
    1.方法名不一样
    2.参数个数不一样
    3.addEventListener 谷歌，火狐，IE11支持 / IE8不支持
      attachEvent 谷歌，火狐, IE11不支持 / IE8支持
    4.this 不同， addEventListener 中的 this 是当前绑定事件的对象， 后者是 window
    5.前者中事件的类型（事件的名字）没有on
      后者有on
*/
```



#### 绑定多个事件

```js
/* 给同一个元素绑定多个不同的事件 */DOM.onclick = fn
DOM.onmouseover = fn
function fn(e) {
  switch (e.type) {
    // 使用 e.type 获取的事件名字是没有 on 的
    case 'click':
      // xxx
      break;
    case 'mouseover':
      // xxx
      break;
  }
}
```



#### 元素事件解绑

```js
// 用什么方式绑定，就应该用对应的方式来解绑
DOM.onEvent = null  // 将事件指向空
DOM.removeEventListener('event', fn, false) // 这种需要在绑定的时候使用命名函数， 这里假定绑定函数 fn()
DOM.detachEvent('onevent', fn)  // 也是需要命名函数来删除指定函数
```



### 元素绑定与解绑的兼容性封装

#### 兼容元素绑定事件

```js
// 名字虽然跟系统中一样，但是不冲突。系统中的是对象的方法， 调用是 DOM.xxx()。这里是函数，是单独调用 xxx()
function addEventListener(ele, type, fn) { // 元素， 事件类型， 处理函数
  // 判断浏览器是否支持这个方法: 对象中是否有方法
  if (ele.addEventListener) {
    ele.addEventListener(typr, fn, false) // 事件名称， 事件处理函数， 是否冒泡标识
  } else if (ele.attachEvent) {
    ele.attachEvent('on'+type, fn)
  } else {
    ele['on'+type] = fn
    // 与这句相等, ele.onclick = fn， 对象中用点.号获取的，都可以中括号获取
  }
}
// 使用
addEventListener(ele, type, fn)

// 下次这块代码时，要注意区分，addEventListener函数和方法，是两个不同的。
// 函数是我们这边自定义的。
// 当我们有一定开发经验时，会想到去取消事件的绑定，以免造成业务开发的影响
// 配套的是 removeEventListener('click', fn, false)
```



#### 兼容元素解绑事件 

```js
//为任意的一个元素,解绑对应的事件
function removeEventListener(element,type,fnName) {
  if(element.removeEventListener){
    element.removeEventListener(type,fnName,false);
  }else if(element.detachEvent){
    element.detachEvent("on"+type,fnName);
  }else{
    element["on"+type]=null;
  }
}
// 使用
removeEventListener(DOM, 'event', fnName)
```



