# 闭包

## 基础知识

### 基本概念

闭包就是，让函数在其原有词法作用域之外执行。

函数嵌套调用时，内层函数引用了外层函数作用域下的变量，且内层函数在全局环境下，可以被访问。就是闭包了。

```js
// 函数返回值的方式产生闭包
function foo() {
  var a = 2
  return function bar() {
    console.log(a) // 引用并返回 foo 函数中变量a 的函数
  }
}
var baz = foo()
baz() // 2。还是可以访问到a，即相关调用栈出栈后，变量a还没有消失。此时变量a被标记成Closure即闭包变量
```



### 闭包的原理

来解析这段代码，来清楚认识闭包的概念：

- 正常情况下，外面无法访问函数内部变量。因为函数执行完后，上下文就被销毁
- 首先bar是作为foo的内部函数存在的，且bar覆盖了foo的词法作用域，即bar可以使用foo作用域下的变量，这里是a
- bar将自己作为foo的返回值，返回给外界并赋值给baz。当baz执行，相当于bar脱离了原有foo的词法环境，在外界执行。这就是闭包
- 每个闭包都有自己的环境，所以互不干扰。



### 闭包的特性

- 最显而易见的也就是定义，脱离原有词法作用域，且可以拿到原有作用域的变量
- 内存不会被销毁，因为是bar自己占用了自己的作用域，且同时覆盖了foo的作用域且一直引用这个作用域，所以一直存在



### 闭包应用场景

根据定义，只要函数脱离原有词法作用域在其他地方执行，就会形成闭包。于是对上面的代码，更改参数传递方式仍然可以构造多种闭包

```js
// 函数在别处调用时产生闭包
function foo(){
  var a = 2
  function baz(){console.log(a)}
  bar(baz)
}
function bar(fn){fn()} // 这就是闭包, 这里的fn实际就是baz，而他脱离了原有词法环境直接执行
foo()

// 间接传递函数产生闭包
var fn
function foo(){
  var a = 2
  function baz() {console.log(a)}
  fn = baz // baz分配给了全局变量fn
}
funcion bar() {
  fn() // 出现闭包，实际上是baz
}
bar() // 2
```



## 回调函数就是闭包

实际就是将可以访问各自词法作用域的函数当作传参导出传递，只要使用了回调函数，那就是在使用闭包。

应用上如定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或其他任何异步（或同步）任务中，回调函数其实就是闭包应用。



### IIFE 不一定是闭包

```js
var a = 2
(function IIFE(){
  console.log(a) // 2。a本来就是全局作用域，哪里都可以用，并不是这里的闭包发现的。
})()
```



### 循环和闭包

for循环是常见的例子

```js
for(var i=1; i<=5; i++) {
  setTimeout(function timer(){console.log(i)}, i*1000)
}
// 实际上输出了5次6
```



定时器就算间隔为0，也是延迟的。所以当执行定时器之前，i 已经是6了。

这里的缺陷就是：每次迭代需要一个闭包作用域才能解决这个问题

```js
for(var i=1; i<=5; i++) {
  void function(){
    setTimeout(function timer(){console.log(i)}, i*1000)
  }()
}
// 实际上，这样子还是不行。还是输出了5次6
```



因为上面的IIFE作用域是空的，他没有自己的变量用来在每次迭代中存储 i 的值。每次迭代的时候，由于定时器还是延迟的，所以循环结束才开始执行定时器，此时的i仍然是6

```js
for(var i=1; i<=5; i++) {
  void function(j){
    setTimeout(function timer(){console.log(j)}, j*1000)
  }(i)
}
```



每次调用定时器前，都给他传入一个正确的i，让它在自己的作用域中延迟执行。



### 块作用域和闭包

上面的解决方案就是用IIFE在每次迭代时都创建一个新的作用域。换句话说就是每次都需要一个独立的块作用域。

```js
for(var i=1; i<=5; i++) {
  let j = i // 闭包的块作用域。原因是使用let 将变量 j 和下面的定时器隐式地包含在了{}块中
  setTimeout(function() {
    console.log(j)
  }, j*1000)
}
```



let在for循环头部使用，还能在每次迭代的时候都用上一次迭代结束时的值来重新声明这个变量

```js
for(let i=1; o<=5; i++){
  setTimeout(function timer(){console.log(i)}, i*1000)
}
```



### 基于闭包访问私有变量

```js
var Foo = function () {
  var name = 'fooname'; // 在构造器中，var声明的变量是私有属性，不能直接通过对象访问
  this.age = 12; // 当new后，this会指向Foo对象，其中的属性也可以访问
  this.getName = function () { // 就是对私有属性的访问
    return name;
  };
};
var foo = new Foo();
foo.name; //  => undefined
foo.age; //  => 12
foo.getName(); //  => 'fooname
```



## 闭包模块机制

### 结合模块

一般的模块，就定义一个函数，里面写一些属性和方法，然后通过return暴露对象，将提供给外部用的方法放进这个暴露的对象中

```js
function CoolModule() {
  var x = [1, 2, 3]
  function doSomething(){
    console.log(x)
  }
  return {
    x,
    doSomething
  }
}
// 新建模块，每次调用都新建了一个模块
var foo = CoolModule()
foo.doSomething()
```



像JQ这样的库，一般都是单例模式，就是只需要一个实例。这个时候就用IIFE模式

```js
var foo = (function CoolModule(id) {....})('id') // 作为函数，其实也可以传参
foo.doSomething()
```



### 现代的模块机制

一般模块都依赖加载器和管理器。

注意在使用 IIFE 时，模块需要 return 公共的 API，所以不能使用 void 开头的方式

```js
// 模块管理器
var MyModules = (function Manager(){
  var modules = {} // 模块列表
  function define(name, deps, impl) { // 模块加载器
    for (var i=0; i<deps; i++) {
      deps[i] = modules[deps[i]]
    }
    modules[name] = impl.apply(impl, deps)
  }
  function get(name) {
    return modules[name]
  }
  return {
    define:define,
    get:get
  }
})()

// 定义两个模块
MyModules.define('bar', [], function() { // 这一步实际是 modules.bar = hello(who)
  function hello(who) {
    return `let me introduce ${who}`
  }
  return {
    hello
  }
})
MyModules.define('foo', ['bar'], function(bar){
  var hungry = 'hippo'
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase())
  }
  return {
    awesome
  }
})

var bar = MyModules.get('bar')
var foo = MyModules.get('foo')
console.log(bar.hello('hippo'))
foo.awesome()
```



### ES6 模块机制

ES6 为模块增加了一级语法支持，将每个文件当作独立的模块来处理

基于函数的模块，无法被静态编译器识别，只能在运行时判断

```js
// 1 模块定义和导出 bar.js
function fn(who){
  console.log(who)
}
// export 会将当前模块的一个标识符（变量、函数）作为导出公共 API
export fn

// 2 模块导入和使用 foo.js
import fn from 'bar'

function fn2(){
  console.log(fn(123))
}
```

































































