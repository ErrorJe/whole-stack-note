# 面向对象

## TS中的类

### 类的新写法

> 在ES6中也支持了class的写法，但是没有那么严格。
>
> 在TS中， 对于类有几点要求：
>
> 1*变量需要提前声明并规定类型，并且要在构造函数中进行初始化*
>
> 2 *方法需要加上类型*

> 当然，也增加了一些特性
>
> 1 增加了访问修饰符。*public 所有， private 类内部， protected 类和子类*
>
> 2 访问修饰符最小访问原则。*属性都是 private, protected， 方法可以是 public*

```js
class Person{
  public name:string
  private age:number

  constructor(name:string, age:number) {
    this.name = name
    this.age = age
  }

  show():void {
    console.log(`名字:${this.name}, 年龄:${this.age}`)
  }
}

let p:Person = new Person('wjy', 21)
p.show()
console.log('访问公有属性 name: ', p.name);
// console.log('访问私有属性 age: ', p.age); // 报错
```

上面对于类中构造器和变量的写法，过于繁杂。还有一种简写方式

```js
// 简写模式，将变量声明定义和变量赋值进行简写
constructor(private name:string, public age:number) {}
```

### 子类

> 子类还是只能访问父类中 protected 或 Public的变量

```js
class Staff extends Person {
  private job:string
  constructor(name:string, age:number, job:string){
    super(name, age) // 初始化父类变量
    this.job = job
  }

  show():void{
    super.show()
    console.log('打印父级变量>>>', this.name); 
    console.log('打印自己变量>>>', this.job)
  }
}
let staff:Staff = new Staff('wjy', 22, '打杂的')
staff.show()
```

### 静态方法

> *static 静态。无法通过实例访问，而是升级成为类本身的属性或者方法。不需要实例化就可以调用*
>
> *可以修改，且不能同时与 const(常量) 一起使用*

```js
class Person2 {
  public static user:string = 'wjy'
  constructor(name:string, age:number) {
    
  }
}
let p2:Person = new Person('wjy', 22)
console.log('静态属性访问>>>', Person2.user);
```

> *const 只读，不能修改*

### 存取器 set/get

对于属性访问普通的解决方式

```js
// 普通的使用方法
public getName():string {
  return this.name
}
public setName(newName:string):void {
  this.name = newName
}
```

用存取器，对变量可以直接进行操作

```js
class Person3 {
  private _name:string
  constructor(name:string) {
    this._name = name
  }
  // 访问器
  get name():string {
    return this._name
  }
  set name(newName:string) {
    if(newName.length<8) {
      throw new Error('名字最少8位')
    } else {
      this._name = newName
    }
  }
}
// 不支持ES3,4，最低支持 ES5 的写法， 所以执行编译时， tsc -t es5 xxx.ts
let p3:Person3 = new Person3('wjy')
p3.name = 'zhanssan' // 这样就可以直接修改
console.log(p3.name)
```



## 高级特性（抽象、接口）

*一些对象具有共同的特性，实现方式： 1 继承， 2 实现接口*

### 抽象类

> *抽象类：只能作为父级使用。不能直接被实例化*
>
> *你帮我画个圆(普通类)， 你帮我画个形状(啥是形状)*
>
> *抽象类只提供模板，不自己实现。起到一个规范的作用*

#### 抽象类实现

```js
abstract class Shape{
  abstract draw(gd):void // 2 抽象方法，没有方法体

  abstract area():number

  abstract pointin(x:number, y:number):boolean
}
```

#### 子类继承

> 抽象类强迫子类必须实现其规定好的方法

```js
// 正方形
class Rect extends Shape {

  constructor(private width:number, private height:number) {
    super() // 派生类的构造方法必须有 super 调用
  }
  draw(gd):void {
    gd.fillRect(0, 0, this.width, this.height)
  }

area():number{
  return this.width * this.height
}

pointin(x: number, y: number):boolean {
  return true
}
}
```

```js
// 圆形
class Circle extends Shape {

  constructor(private cx:number, private cy:number, private r:number) {
    super() // 派生类的构造方法必须有 super 调用
  }
  draw(gd):void {
    gd.arc()
  }

area():number{
  return Math.PI*Math.pow(this.r, 2)
}

pointin(x: number, y: number):boolean {
  return true
}
}
```

> 从本质上来说，子类都是父类
>
> 狗，是动物
>
> 奔驰， 是车

```js
let a:Shape
a = new Rect(300, 200)
console.log(a.area())
a = new Circle(300, 400, 150)
console.log(a.area());
```

### 接口

> *接口、抽象目标都是一致。规定了子类*

```js
// 接口
interface Shape {
  area():number
}
// 子类实现接口
class Rect implements Shape {
  constructor(private width:number, private height:number) {} // 实现接口不用super

  // 实现接口规定的方法
  area():number{
    return this.width*this.height
  }
}

let r:Rect = new Rect(100, 200)
console.log(r.area());
```

> 对比抽象类和接口，更加推荐使用接口（因为他简单灵活）

### 抽象类和接口的区别

1 共同点：都不能被直接实例化

2 抽象类要被子类“继承 extends”， 而接口是被子类“实现 implements”

3 抽象类对于方法可以进行声明或实现，而接口只能声明

4 抽象类的抽象方法（抽象类里可以没有抽象方法）和接口的方法必须被子类全部实现，若没有全部实现，则子类也必须是抽象类。

5 若该类有抽象方法，则该类是抽象类

6 抽象类中的方法都要被实现，所以方法不能是static和private

7 类只能继承1个类，而接口可以继承多个

8 抽象级别：接口 > 抽象类 > 实现类

9 抽象类，用于抽象类别（关注事物本质）。接口，用于抽象方法功能（关注某种操作）。

10 接口具有更大的灵活性和可扩展性。而抽象类的设计必须十分谨慎。

