# 基础入门

主要是 `类型思维`，用强类型去约束原本是弱类型的 JS。



## 类型基础

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205043627.png)



### 强类型和弱类型语言

强类型：不允许改变变量类型，除非进行强制类型转换

> 至于在编译时发现错误，要不要停止程序，这要看个别语言的区别，不是决定因素
>
> 如 C /C++ 就是报错后继续执行

弱类型：变量可以被赋予不同的数据类型



### 静态和动态类型语言

静态类型语言：在编译阶段就确定了所有变量的类型

动态类型语言：在执行阶段确定所有变量的类型



经过比较，有一些区别

> 动态类型语言，在性能和内存空间上相对于静态类型语言，有较多的损耗

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205043347.png)



但是，动态类型语言有一定的措施可以弥补问题

- 性能可以改善，如 V8 引擎
- 隐藏的错误可以通过单元测试发现
- 文档可以通过工具生成



## Hello World

### 基本安装

#### 初始化项目

使用 `vscode` 作为编辑器，创建目录后初始化项目 `npm init -y` 

- 创建 `package.json` 文件

然后全局安装一下 `TS` ， `npm i typescript -g`

安装之后就可以使用常用的命名 `tsc -h`，来看一下基本的配置项

初始化 ts 配置文件， `tsc --init`

- 创建 `tsconfig.json` 文件



#### 编写 TS 源码

根目录下创建源码目录 , `src`， 然后创建 `index,ts`

```ts
let hello: string = 'Hello World'
```



#### 编译 JS 文件

命令 `tsc ./src/index.ts`，将 TS 文件在文件所在目录下编译成 JS 文件

```js
// 编译出来的结果 index.js
var hello = 'Hello World';
```



### webpack 构建

这里主要用 webpack 工具来构建项目，`npm i webpack webpack-cli webpack-dev-server -D`

还要安装 TS 的 loader  `npm i ts-loader typescript -D`（再次安装 ts 到本地，是为了与其他包配合）

> 注意个坑，如果初始化 npm 项目时，最外层目录名为 `typescipt` 则无法正常安装 ts。可以去 package.json 中修改下 name

安装插件 `npm i html-webpack-plugin -D`



#### 区分配置环境

创建构建目录 `build` 用于放不同环境的 webpack 配置

#### webpack.config.js 配置入口

- 合并配置文件， `npm i webpack-merge -D`

```js
const merge = require('webpack-merge') 
// 引入三个配置文件
const baseConfig = require('./webpack.base.config')
const devConfig = require('./webpack.dev.config')
const proConfig = require('./webpack.pro.config')

// 根据环境合并不同的配置文件
module.exports = (env, argv) => {
  let config = argv.mode === 'development' ? devConfig : proConfig;
  return merge(baseConfig, config);
};
```



#### webpack.base.config.js 公共配置

```js
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  entry: './src/index.ts', // 1 入口文件
  // 2 输出目录
  output: {
    filename: 'app.js'
  },
  // 3 指定3个扩展名
  resolve: {
    extensions: ['.js', '.ts', '.tsx']
  },
  // 4 专用于 TS 的 loader
  module: {
    rules: [
      {
        test: /\.tsx?$/i,
        use: [{
          loader: 'ts-loader'
        }],
        exclude: /node_modules/
      }
    ]
  },
  // 5 插件，通过模板生成网站的首页。
  // 还可以把输出文件嵌入到这个文件中
  // 首先要指定首页的位置
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/tpl/index.html'
    })
  ]
}
```



#### webpack.dev.config.js 开发环境

```js
// 开启 source-map
// cheap 忽略列信息
// module 定位到 ts 源码，而不是经过 webpack 转义后的源码
// eval-source-map 以 dataUrl 的形式打包到文件中
module.exports = {
  devtool: 'cheap-module-eval-source-map'
}
```



#### webpack.pro.config.js 生产环境

- 安装插件，作用时每次构建清空原有目录。`npm i clean-webpack-plugin -D`
- 因为每次构建都是在文件后增加哈希标识，每次构建都会产生不同的文件。所以要把原先的清理掉

```js
const { CleanWebpackPlugin } = require('clean-webpack-plugin')

module.exports = {
  plugins: [
    new CleanWebpackPlugin()
  ]
}
```



### 启动项目

#### 优化 npm 脚本

主要是配置2个

- 入口文件
- 启动命令：分别是开发环境、生产环境的启动命令

配置好后，运行就是 `npm start`

```json
// package.json
{
  "main": "./src/index.ts",
  "scripts": {
    // mode 设置环境
    // config 设置配置文件
    "start": "webpack-dev-server --mode=development --config ./build/webpack.config.js",
    "build": "webpack --mode=production --config ./build/webpack.config.js",
    "lint": "eslint src --ext .js,.ts",
    "test": "jest"
  },
}
```



#### 创建页面

创建目录 `src/tpl/index.html`

- 用 vscode 代码模板，输入 html5 自动生成
- 修改下 title 增加一个 div

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>TypeScript Hello World</title>
</head>
<body>
  <div class="app"></div>
</body>
</html>
```



#### 测试

修改下页面内容，测试下效果

```ts
// index.ts
let hello:string = 'Hello World'
// 改换页面内容
document.querySelectorAll('.app')[0].innerHTML = hello
```



最后可以成功看到页面，`hello world` 成功

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205052210.png)



## 基本类型

### 类型对比 

#### ES6 和 TS 的数据类型对比

- ES6

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205052451.png)

- TS：右侧就是新增的类型

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205052518.png)

### 类型注解

> 相当于强类型语言中的类型声明，语法就是 `变量/函数：type`

关于文件的模块引入，上面已经创建了 `index.ts` ，把 `datatype.ts` 引入的方式

```ts
import './datatype'
```



#### 基本类型

```ts
// src/datatype.ts 观察变量类型是不可以改变的

// 1 原始类型：布尔，数值，字符
let bool:boolean = true
let num:number = 123
let str:string = 'abc'
str = 123 // 字符类型不能拿数值来赋值，不然编辑器自己就会报错提示
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205054335.png)

#### 数组类型

```ts
// 2 数组的两种写法
let arr1: number[] = [1, 2, 3] // 元素为数值类型
let arr2: Array<number | string> = [1, 2, 3, '4'] // 泛型接口 + 联合类型
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205054323.png)

#### 元祖

```ts
// 3 元祖：限定了数组元素的类型和个数
let tuple: [number, string] = [0, '1']
// 可以push 新元素进去，但是无法越界访问
tuple.push(2)
console.log(tuple)
tuple[2]
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205054311.png)

元祖的这种 push 方式，实际开发中是不建议使用的。



#### 函数

- 要规定参数的类型，函数返回值类型可以省略，因为有自动推断
- 可以先声明函数类型，再定义函数逻辑

```ts
// 4 函数
let add = (x: number, y: number) => x + y

let compute: (x: number, y: number) => number
compute = (a, b) => a + b // 形参不一样也没有关系
```



![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205054214.png)



#### 对象 

可以是直接写死类型 `object` ，但是这样的话实际就没有对属性的类型进行限定。所以后续无法对属性进行修改。

所以要对每个属性都进行限定

```ts
// 5 对象
let obj: { x: number, y: number } = { x: 1, y: 2 }
obj.x = 3
```







#### symbol

```ts
// 6 symbol：唯一的值
let s1:symbol = Symbol()
let s2 = Symbol()
console.log(s1 === s2);

```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205054806.png)



#### undefined， null

```ts
// 7 undefiend, null
let un: undefined = undefined // 只能赋值本身
let nu: null = null
num = undefined
num = null
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205055048.png)



在 TS 中 Undefined 和 null 是任意值的子类型，所以是可以转换的

编辑器默认报错，需要另外设置，去 TS 配置文件中改下就行

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205055139.png)

如果要求比较严格，就按照默认的来。那么在不改配置的情况下，就只能让变量同时支持多个类型了

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205055357.png)



#### void

是一种操作符，让任何表达式都是返回 `undefined`

```ts
// 8 void
// 没有返回类型就是 Void
let noReturn = () => {}
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205055611.png)



#### any

就回到了  JS，什么类型都可以

也就是对  JS  的兼容

```ts
// 9 any
let x
x = 1
x = []
x = () => {}
```



#### never

```ts
// 10 never 永远没有返回值的类型
let error = () => { // 抛出异常的函数，就没有返回值
  throw new Error('error')
}
let endless = () => { // 死循环，永远不会返回
  while (true) { }
}
```

![](https://raw.githubusercontent.com/ErrorJe/ErrorJE.github.io/images/img/20200205055912.png)



### 枚举







## 接口







## 类







## 泛型





## 类型检查机制







## 高级类型

